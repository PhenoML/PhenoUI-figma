<script>
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __publicField = (obj, key2, value2) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/mersenne-twister/src/mersenne-twister.js
var require_mersenne_twister = __commonJS({
  "node_modules/mersenne-twister/src/mersenne-twister.js"(exports2, module2) {
    var MersenneTwister = function(seed) {
      if (seed == void 0) {
        seed = (/* @__PURE__ */ new Date()).getTime();
      }
      this.N = 624;
      this.M = 397;
      this.MATRIX_A = 2567483615;
      this.UPPER_MASK = 2147483648;
      this.LOWER_MASK = 2147483647;
      this.mt = new Array(this.N);
      this.mti = this.N + 1;
      if (seed.constructor == Array) {
        this.init_by_array(seed, seed.length);
      } else {
        this.init_seed(seed);
      }
    };
    MersenneTwister.prototype.init_seed = function(s2) {
      this.mt[0] = s2 >>> 0;
      for (this.mti = 1; this.mti < this.N; this.mti++) {
        var s2 = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (((s2 & 4294901760) >>> 16) * 1812433253 << 16) + (s2 & 65535) * 1812433253 + this.mti;
        this.mt[this.mti] >>>= 0;
      }
    };
    MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
      var i4, j2, k2;
      this.init_seed(19650218);
      i4 = 1;
      j2 = 0;
      k2 = this.N > key_length ? this.N : key_length;
      for (; k2; k2--) {
        var s2 = this.mt[i4 - 1] ^ this.mt[i4 - 1] >>> 30;
        this.mt[i4] = (this.mt[i4] ^ (((s2 & 4294901760) >>> 16) * 1664525 << 16) + (s2 & 65535) * 1664525) + init_key[j2] + j2;
        this.mt[i4] >>>= 0;
        i4++;
        j2++;
        if (i4 >= this.N) {
          this.mt[0] = this.mt[this.N - 1];
          i4 = 1;
        }
        if (j2 >= key_length)
          j2 = 0;
      }
      for (k2 = this.N - 1; k2; k2--) {
        var s2 = this.mt[i4 - 1] ^ this.mt[i4 - 1] >>> 30;
        this.mt[i4] = (this.mt[i4] ^ (((s2 & 4294901760) >>> 16) * 1566083941 << 16) + (s2 & 65535) * 1566083941) - i4;
        this.mt[i4] >>>= 0;
        i4++;
        if (i4 >= this.N) {
          this.mt[0] = this.mt[this.N - 1];
          i4 = 1;
        }
      }
      this.mt[0] = 2147483648;
    };
    MersenneTwister.prototype.random_int = function() {
      var y2;
      var mag01 = new Array(0, this.MATRIX_A);
      if (this.mti >= this.N) {
        var kk;
        if (this.mti == this.N + 1)
          this.init_seed(5489);
        for (kk = 0; kk < this.N - this.M; kk++) {
          y2 = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
          this.mt[kk] = this.mt[kk + this.M] ^ y2 >>> 1 ^ mag01[y2 & 1];
        }
        for (; kk < this.N - 1; kk++) {
          y2 = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
          this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y2 >>> 1 ^ mag01[y2 & 1];
        }
        y2 = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
        this.mt[this.N - 1] = this.mt[this.M - 1] ^ y2 >>> 1 ^ mag01[y2 & 1];
        this.mti = 0;
      }
      y2 = this.mt[this.mti++];
      y2 ^= y2 >>> 11;
      y2 ^= y2 << 7 & 2636928640;
      y2 ^= y2 << 15 & 4022730752;
      y2 ^= y2 >>> 18;
      return y2 >>> 0;
    };
    MersenneTwister.prototype.random_int31 = function() {
      return this.random_int() >>> 1;
    };
    MersenneTwister.prototype.random_incl = function() {
      return this.random_int() * (1 / 4294967295);
    };
    MersenneTwister.prototype.random = function() {
      return this.random_int() * (1 / 4294967296);
    };
    MersenneTwister.prototype.random_excl = function() {
      return (this.random_int() + 0.5) * (1 / 4294967296);
    };
    MersenneTwister.prototype.random_long = function() {
      var a3 = this.random_int() >>> 5, b2 = this.random_int() >>> 6;
      return (a3 * 67108864 + b2) * (1 / 9007199254740992);
    };
    module2.exports = MersenneTwister;
  }
});

// node_modules/polyfill-crypto.getrandomvalues/index.js
var require_polyfill_crypto = __commonJS({
  "node_modules/polyfill-crypto.getrandomvalues/index.js"(exports2, module2) {
    var MersenneTwister = require_mersenne_twister();
    var twister = new MersenneTwister(Math.random() * Number.MAX_SAFE_INTEGER);
    module2.exports = getRandomValues3;
    function getRandomValues3(abv) {
      var l3 = abv.length;
      while (l3--) {
        abv[l3] = Math.floor(randomFloat() * 256);
      }
      return abv;
    }
    function randomFloat() {
      return twister.random();
    }
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a3, b2) {
      var arr = [];
      for (var i4 = 0; i4 < a3.length; i4 += 1) {
        arr[i4] = a3[i4];
      }
      for (var j2 = 0; j2 < b2.length; j2 += 1) {
        arr[j2 + a3.length] = b2[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i4 = offset || 0, j2 = 0; i4 < arrLike.length; i4 += 1, j2 += 1) {
        arr[j2] = arrLike[i4];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i4 = 0; i4 < arr.length; i4 += 1) {
        str += arr[i4];
        if (i4 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i4 = 0; i4 < boundLength; i4++) {
        boundArgs[i4] = "$" + i4;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e5) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e5) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
      return x2.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e5) {
        errorProto = getProto(getProto(e5));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name2) {
      var value2;
      if (name2 === "%AsyncFunction%") {
        value2 = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value2 = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value2 = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value2 = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value2 = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value2;
      return value2;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value2 = INTRINSICS[intrinsicName];
        if (value2 === needsEval) {
          value2 = doEval(intrinsicName);
        }
        if (typeof value2 === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value: value2
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value2 = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i4 = 1, isOwn = true; i4 < parts.length; i4 += 1) {
        var part = parts[i4];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value2 = INTRINSICS[intrinsicRealName];
        } else if (value2 != null) {
          if (!(part in value2)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i4 + 1 >= parts.length) {
            var desc = $gOPD(value2, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value2 = desc.get;
            } else {
              value2 = value2[part];
            }
          } else {
            isOwn = hasOwn(value2, part);
            value2 = value2[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value2;
          }
        }
      }
      return value2;
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e5) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e5) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e5) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e5) {
        $defineProperty = false;
      }
    }
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property2, value2) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property2 !== "string" && typeof property2 !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property2);
      if ($defineProperty) {
        $defineProperty(obj, property2, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value: value2,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property2] = value2;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length2) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor(length2) !== length2) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(fn, "length", length2, true, true);
        } else {
          define2(fn, "length", length2);
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e5) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value2, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value2, newOpts, depth + 1, seen);
        }
        return inspect_(value2, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name2 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i4 = 0; i4 < attrs.length; i4++) {
          s2 += " " + attrs[i4].name + "=" + wrapQuotes(quote(attrs[i4].value), "double", opts);
        }
        s2 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s2 += "...";
        }
        s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s2;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value2, key2) {
            mapParts.push(inspect(key2, obj, true) + " => " + inspect(value2, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value2) {
            setParts.push(inspect(value2, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s2, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s2 + quoteChar;
    }
    function quote(s2) {
      return $replace.call(String(s2), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e5) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e5) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
      return key2 in this;
    };
    function has(obj, key2) {
      return hasOwn.call(obj, key2);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f3) {
      if (f3.name) {
        return f3.name;
      }
      var m3 = $match.call(functionToString.call(f3), /^function\s*([\w$]+)/);
      if (m3) {
        return m3[1];
      }
      return null;
    }
    function indexOf(xs, x2) {
      if (xs.indexOf) {
        return xs.indexOf(x2);
      }
      for (var i4 = 0, l3 = xs.length; i4 < l3; i4++) {
        if (xs[i4] === x2) {
          return i4;
        }
      }
      return -1;
    }
    function isMap(x2) {
      if (!mapSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        mapSize.call(x2);
        try {
          setSize.call(x2);
        } catch (s2) {
          return true;
        }
        return x2 instanceof Map;
      } catch (e5) {
      }
      return false;
    }
    function isWeakMap(x2) {
      if (!weakMapHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x2, weakMapHas);
        try {
          weakSetHas.call(x2, weakSetHas);
        } catch (s2) {
          return true;
        }
        return x2 instanceof WeakMap;
      } catch (e5) {
      }
      return false;
    }
    function isWeakRef(x2) {
      if (!weakRefDeref || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x2);
        return true;
      } catch (e5) {
      }
      return false;
    }
    function isSet(x2) {
      if (!setSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        setSize.call(x2);
        try {
          mapSize.call(x2);
        } catch (m3) {
          return true;
        }
        return x2 instanceof Set;
      } catch (e5) {
      }
      return false;
    }
    function isWeakSet(x2) {
      if (!weakSetHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x2, weakSetHas);
        try {
          weakMapHas.call(x2, weakMapHas);
        } catch (s2) {
          return true;
        }
        return x2 instanceof WeakSet;
      } catch (e5) {
      }
      return false;
    }
    function isElement(x2) {
      if (!x2 || typeof x2 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
        return true;
      }
      return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s2, "single", opts);
    }
    function lowbyte(c2) {
      var n3 = c2.charCodeAt(0);
      var x2 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n3];
      if (x2) {
        return "\\" + x2;
      }
      return "\\x" + (n3 < 16 ? "0" : "") + $toUpperCase.call(n3.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i4 = 0; i4 < xs.length; i4++) {
        if (indexOf(xs[i4], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i4 = 0; i4 < obj.length; i4++) {
          xs[i4] = has(obj, i4) ? inspect(obj[i4], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k2 = 0; k2 < syms.length; k2++) {
          symMap["$" + syms[k2]] = syms[k2];
        }
      }
      for (var key2 in obj) {
        if (!has(obj, key2)) {
          continue;
        }
        if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key2)) {
          xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
        } else {
          xs.push(key2 + ": " + inspect(obj[key2], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j2 = 0; j2 < syms.length; j2++) {
          if (isEnumerable.call(obj, syms[j2])) {
            xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key2) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key2) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key2) {
      var node = listGetNode(objects, key2);
      return node && node.value;
    };
    var listSet = function(objects, key2, value2) {
      var node = listGetNode(objects, key2);
      if (node) {
        node.value = value2;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key: key2,
          next: objects.next,
          value: value2
        };
      }
    };
    var listHas = function(objects, key2) {
      return !!listGetNode(objects, key2);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect(key2));
          }
        },
        get: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key2);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key2);
            }
          } else {
            if ($o) {
              return listGet($o, key2);
            }
          }
        },
        has: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key2);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key2);
            }
          } else {
            if ($o) {
              return listHas($o, key2);
            }
          }
          return false;
        },
        set: function(key2, value2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key2, value2);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key2, value2);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key2, value2);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value2) {
          return replace.call(value2, percentTwenties, "+");
        },
        RFC3986: function(value2) {
          return String(value2);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i4 = 0; i4 < 256; ++i4) {
        array.push("%" + ((i4 < 16 ? "0" : "") + i4.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j2 = 0; j2 < obj.length; ++j2) {
            if (typeof obj[j2] !== "undefined") {
              compacted.push(obj[j2]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i4 = 0; i4 < source.length; ++i4) {
        if (typeof source[i4] !== "undefined") {
          obj[i4] = source[i4];
        }
      }
      return obj;
    };
    var merge2 = function merge3(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i4) {
          if (has.call(target, i4)) {
            var targetItem = target[i4];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i4] = merge3(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i4] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key2) {
        var value2 = source[key2];
        if (has.call(acc, key2)) {
          acc[key2] = merge3(acc[key2], value2, options);
        } else {
          acc[key2] = value2;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key2) {
        acc[key2] = source[key2];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e5) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i4 = 0; i4 < string.length; ++i4) {
        var c2 = string.charCodeAt(i4);
        if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format === formats.RFC1738 && (c2 === 40 || c2 === 41)) {
          out += string.charAt(i4);
          continue;
        }
        if (c2 < 128) {
          out = out + hexTable[c2];
          continue;
        }
        if (c2 < 2048) {
          out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
          continue;
        }
        i4 += 1;
        c2 = 65536 + ((c2 & 1023) << 10 | string.charCodeAt(i4) & 1023);
        out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      return out;
    };
    var compact = function compact2(value2) {
      var queue = [{ obj: { o: value2 }, prop: "o" }];
      var refs = [];
      for (var i4 = 0; i4 < queue.length; ++i4) {
        var item = queue[i4];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j2 = 0; j2 < keys.length; ++j2) {
          var key2 = keys[j2];
          var val2 = obj[key2];
          if (typeof val2 === "object" && val2 !== null && refs.indexOf(val2) === -1) {
            queue.push({ obj, prop: key2 });
            refs.push(val2);
          }
        }
      }
      compactQueue(queue);
      return value2;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a3, b2) {
      return [].concat(a3, b2);
    };
    var maybeMap = function maybeMap2(val2, fn) {
      if (isArray(val2)) {
        var mapped = [];
        for (var i4 = 0; i4 < val2.length; i4 += 1) {
          mapped.push(fn(val2[i4]));
        }
        return mapped;
      }
      return fn(val2);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge: merge2
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key2) {
        return prefix + "[" + key2 + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
      return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value3) {
          if (value3 instanceof Date) {
            return serializeDate(value3);
          }
          return value3;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j2 = 0; j2 < objKeys.length; ++j2) {
        var key2 = objKeys[j2];
        var value2 = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
        if (skipNulls && value2 === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key2) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key2 : "[" + key2 + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value2,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i4 = 0; i4 < objKeys.length; ++i4) {
        var key2 = objKeys[i4];
        if (options.skipNulls && obj[key2] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key2],
          key2,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val2, options) {
      if (val2 && typeof val2 === "string" && options.comma && val2.indexOf(",") > -1) {
        return val2.split(",");
      }
      return val2;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i4;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i4 = 0; i4 < parts.length; ++i4) {
          if (parts[i4].indexOf("utf8=") === 0) {
            if (parts[i4] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i4] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i4;
            i4 = parts.length;
          }
        }
      }
      for (i4 = 0; i4 < parts.length; ++i4) {
        if (i4 === skipIndex) {
          continue;
        }
        var part = parts[i4];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key2, val2;
        if (pos === -1) {
          key2 = options.decoder(part, defaults.decoder, charset, "key");
          val2 = options.strictNullHandling ? null : "";
        } else {
          key2 = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val2 = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val2 && options.interpretNumericEntities && charset === "iso-8859-1") {
          val2 = interpretNumericEntities(val2);
        }
        if (part.indexOf("[]=") > -1) {
          val2 = isArray(val2) ? [val2] : val2;
        }
        if (has.call(obj, key2)) {
          obj[key2] = utils.combine(obj[key2], val2);
        } else {
          obj[key2] = val2;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val2, options, valuesParsed) {
      var leaf = valuesParsed ? val2 : parseArrayValue(val2, options);
      for (var i4 = chain.length - 1; i4 >= 0; --i4) {
        var obj;
        var root = chain[i4];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index2 = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val2, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key2);
      var parent2 = segment ? key2.slice(0, segment.index) : key2;
      var keys = [];
      if (parent2) {
        if (!options.plainObjects && has.call(Object.prototype, parent2)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent2);
      }
      var i4 = 0;
      while (options.depth > 0 && (segment = child.exec(key2)) !== null && i4 < options.depth) {
        i4 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key2.slice(segment.index) + "]");
      }
      return parseObject(keys, val2, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i4 = 0; i4 < keys.length; ++i4) {
        var key2 = keys[i4];
        var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var parse2 = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// node_modules/lottie-web/build/player/lottie.js
var require_lottie = __commonJS({
  "node_modules/lottie-web/build/player/lottie.js"(exports, module) {
    typeof navigator !== "undefined" && function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.lottie = factory());
    }(exports, function() {
      "use strict";
      var svgNS = "http://www.w3.org/2000/svg";
      var locationHref = "";
      var _useWebWorker = false;
      var initialDefaultFrame = -999999;
      var setWebWorker = function setWebWorker2(flag) {
        _useWebWorker = !!flag;
      };
      var getWebWorker = function getWebWorker2() {
        return _useWebWorker;
      };
      var setLocationHref = function setLocationHref2(value2) {
        locationHref = value2;
      };
      var getLocationHref = function getLocationHref2() {
        return locationHref;
      };
      function createTag(type) {
        return document.createElement(type);
      }
      function extendPrototype(sources, destination) {
        var i4;
        var len = sources.length;
        var sourcePrototype;
        for (i4 = 0; i4 < len; i4 += 1) {
          sourcePrototype = sources[i4].prototype;
          for (var attr in sourcePrototype) {
            if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr))
              destination.prototype[attr] = sourcePrototype[attr];
          }
        }
      }
      function getDescriptor(object, prop) {
        return Object.getOwnPropertyDescriptor(object, prop);
      }
      function createProxyFunction(prototype) {
        function ProxyFunction() {
        }
        ProxyFunction.prototype = prototype;
        return ProxyFunction;
      }
      var audioControllerFactory = function() {
        function AudioController(audioFactory) {
          this.audios = [];
          this.audioFactory = audioFactory;
          this._volume = 1;
          this._isMuted = false;
        }
        AudioController.prototype = {
          addAudio: function addAudio(audio) {
            this.audios.push(audio);
          },
          pause: function pause() {
            var i4;
            var len = this.audios.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              this.audios[i4].pause();
            }
          },
          resume: function resume() {
            var i4;
            var len = this.audios.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              this.audios[i4].resume();
            }
          },
          setRate: function setRate(rateValue) {
            var i4;
            var len = this.audios.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              this.audios[i4].setRate(rateValue);
            }
          },
          createAudio: function createAudio(assetPath) {
            if (this.audioFactory) {
              return this.audioFactory(assetPath);
            }
            if (window.Howl) {
              return new window.Howl({
                src: [assetPath]
              });
            }
            return {
              isPlaying: false,
              play: function play() {
                this.isPlaying = true;
              },
              seek: function seek() {
                this.isPlaying = false;
              },
              playing: function playing() {
              },
              rate: function rate() {
              },
              setVolume: function setVolume() {
              }
            };
          },
          setAudioFactory: function setAudioFactory(audioFactory) {
            this.audioFactory = audioFactory;
          },
          setVolume: function setVolume(value2) {
            this._volume = value2;
            this._updateVolume();
          },
          mute: function mute() {
            this._isMuted = true;
            this._updateVolume();
          },
          unmute: function unmute() {
            this._isMuted = false;
            this._updateVolume();
          },
          getVolume: function getVolume() {
            return this._volume;
          },
          _updateVolume: function _updateVolume() {
            var i4;
            var len = this.audios.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              this.audios[i4].volume(this._volume * (this._isMuted ? 0 : 1));
            }
          }
        };
        return function() {
          return new AudioController();
        };
      }();
      var createTypedArray = function() {
        function createRegularArray(type, len) {
          var i4 = 0;
          var arr = [];
          var value2;
          switch (type) {
            case "int16":
            case "uint8c":
              value2 = 1;
              break;
            default:
              value2 = 1.1;
              break;
          }
          for (i4 = 0; i4 < len; i4 += 1) {
            arr.push(value2);
          }
          return arr;
        }
        function createTypedArrayFactory(type, len) {
          if (type === "float32") {
            return new Float32Array(len);
          }
          if (type === "int16") {
            return new Int16Array(len);
          }
          if (type === "uint8c") {
            return new Uint8ClampedArray(len);
          }
          return createRegularArray(type, len);
        }
        if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
          return createTypedArrayFactory;
        }
        return createRegularArray;
      }();
      function createSizedArray(len) {
        return Array.apply(null, {
          length: len
        });
      }
      function _typeof$6(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$6 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$6 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$6(obj);
      }
      var subframeEnabled = true;
      var expressionsPlugin = null;
      var expressionsInterfaces = null;
      var idPrefix$1 = "";
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      var _shouldRoundValues = false;
      var bmPow = Math.pow;
      var bmSqrt = Math.sqrt;
      var bmFloor = Math.floor;
      var bmMax = Math.max;
      var bmMin = Math.min;
      var BMMath = {};
      (function() {
        var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
        var i4;
        var len = propertyNames.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          BMMath[propertyNames[i4]] = Math[propertyNames[i4]];
        }
      })();
      function ProjectInterface$1() {
        return {};
      }
      BMMath.random = Math.random;
      BMMath.abs = function(val2) {
        var tOfVal = _typeof$6(val2);
        if (tOfVal === "object" && val2.length) {
          var absArr = createSizedArray(val2.length);
          var i4;
          var len = val2.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            absArr[i4] = Math.abs(val2[i4]);
          }
          return absArr;
        }
        return Math.abs(val2);
      };
      var defaultCurveSegments = 150;
      var degToRads = Math.PI / 180;
      var roundCorner = 0.5519;
      function roundValues(flag) {
        _shouldRoundValues = !!flag;
      }
      function bmRnd(value2) {
        if (_shouldRoundValues) {
          return Math.round(value2);
        }
        return value2;
      }
      function styleDiv(element) {
        element.style.position = "absolute";
        element.style.top = 0;
        element.style.left = 0;
        element.style.display = "block";
        element.style.transformOrigin = "0 0";
        element.style.webkitTransformOrigin = "0 0";
        element.style.backfaceVisibility = "visible";
        element.style.webkitBackfaceVisibility = "visible";
        element.style.transformStyle = "preserve-3d";
        element.style.webkitTransformStyle = "preserve-3d";
        element.style.mozTransformStyle = "preserve-3d";
      }
      function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
        this.type = type;
        this.currentTime = currentTime;
        this.totalTime = totalTime;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMCompleteEvent(type, frameMultiplier) {
        this.type = type;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
        this.type = type;
        this.currentLoop = currentLoop;
        this.totalLoops = totalLoops;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMSegmentStartEvent(type, firstFrame, totalFrames) {
        this.type = type;
        this.firstFrame = firstFrame;
        this.totalFrames = totalFrames;
      }
      function BMDestroyEvent(type, target) {
        this.type = type;
        this.target = target;
      }
      function BMRenderFrameErrorEvent(nativeError, currentTime) {
        this.type = "renderFrameError";
        this.nativeError = nativeError;
        this.currentTime = currentTime;
      }
      function BMConfigErrorEvent(nativeError) {
        this.type = "configError";
        this.nativeError = nativeError;
      }
      function BMAnimationConfigErrorEvent(type, nativeError) {
        this.type = type;
        this.nativeError = nativeError;
      }
      var createElementID = function() {
        var _count = 0;
        return function createID() {
          _count += 1;
          return idPrefix$1 + "__lottie_element_" + _count;
        };
      }();
      function HSVtoRGB(h2, s2, v2) {
        var r3;
        var g2;
        var b2;
        var i4;
        var f3;
        var p2;
        var q;
        var t5;
        i4 = Math.floor(h2 * 6);
        f3 = h2 * 6 - i4;
        p2 = v2 * (1 - s2);
        q = v2 * (1 - f3 * s2);
        t5 = v2 * (1 - (1 - f3) * s2);
        switch (i4 % 6) {
          case 0:
            r3 = v2;
            g2 = t5;
            b2 = p2;
            break;
          case 1:
            r3 = q;
            g2 = v2;
            b2 = p2;
            break;
          case 2:
            r3 = p2;
            g2 = v2;
            b2 = t5;
            break;
          case 3:
            r3 = p2;
            g2 = q;
            b2 = v2;
            break;
          case 4:
            r3 = t5;
            g2 = p2;
            b2 = v2;
            break;
          case 5:
            r3 = v2;
            g2 = p2;
            b2 = q;
            break;
          default:
            break;
        }
        return [r3, g2, b2];
      }
      function RGBtoHSV(r3, g2, b2) {
        var max = Math.max(r3, g2, b2);
        var min = Math.min(r3, g2, b2);
        var d2 = max - min;
        var h2;
        var s2 = max === 0 ? 0 : d2 / max;
        var v2 = max / 255;
        switch (max) {
          case min:
            h2 = 0;
            break;
          case r3:
            h2 = g2 - b2 + d2 * (g2 < b2 ? 6 : 0);
            h2 /= 6 * d2;
            break;
          case g2:
            h2 = b2 - r3 + d2 * 2;
            h2 /= 6 * d2;
            break;
          case b2:
            h2 = r3 - g2 + d2 * 4;
            h2 /= 6 * d2;
            break;
          default:
            break;
        }
        return [h2, s2, v2];
      }
      function addSaturationToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[1] += offset;
        if (hsv[1] > 1) {
          hsv[1] = 1;
        } else if (hsv[1] <= 0) {
          hsv[1] = 0;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      function addBrightnessToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[2] += offset;
        if (hsv[2] > 1) {
          hsv[2] = 1;
        } else if (hsv[2] < 0) {
          hsv[2] = 0;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      function addHueToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[0] += offset / 360;
        if (hsv[0] > 1) {
          hsv[0] -= 1;
        } else if (hsv[0] < 0) {
          hsv[0] += 1;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      var rgbToHex = function() {
        var colorMap = [];
        var i4;
        var hex;
        for (i4 = 0; i4 < 256; i4 += 1) {
          hex = i4.toString(16);
          colorMap[i4] = hex.length === 1 ? "0" + hex : hex;
        }
        return function(r3, g2, b2) {
          if (r3 < 0) {
            r3 = 0;
          }
          if (g2 < 0) {
            g2 = 0;
          }
          if (b2 < 0) {
            b2 = 0;
          }
          return "#" + colorMap[r3] + colorMap[g2] + colorMap[b2];
        };
      }();
      var setSubframeEnabled = function setSubframeEnabled2(flag) {
        subframeEnabled = !!flag;
      };
      var getSubframeEnabled = function getSubframeEnabled2() {
        return subframeEnabled;
      };
      var setExpressionsPlugin = function setExpressionsPlugin2(value2) {
        expressionsPlugin = value2;
      };
      var getExpressionsPlugin = function getExpressionsPlugin2() {
        return expressionsPlugin;
      };
      var setExpressionInterfaces = function setExpressionInterfaces2(value2) {
        expressionsInterfaces = value2;
      };
      var getExpressionInterfaces = function getExpressionInterfaces2() {
        return expressionsInterfaces;
      };
      var setDefaultCurveSegments = function setDefaultCurveSegments2(value2) {
        defaultCurveSegments = value2;
      };
      var getDefaultCurveSegments = function getDefaultCurveSegments2() {
        return defaultCurveSegments;
      };
      var setIdPrefix = function setIdPrefix2(value2) {
        idPrefix$1 = value2;
      };
      var getIdPrefix = function getIdPrefix2() {
        return idPrefix$1;
      };
      function createNS(type) {
        return document.createElementNS(svgNS, type);
      }
      function _typeof$5(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$5 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$5 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$5(obj);
      }
      var dataManager = function() {
        var _counterId = 1;
        var processes = [];
        var workerFn;
        var workerInstance;
        var workerProxy = {
          onmessage: function onmessage() {
          },
          postMessage: function postMessage(path) {
            workerFn({
              data: path
            });
          }
        };
        var _workerSelf = {
          postMessage: function postMessage(data2) {
            workerProxy.onmessage({
              data: data2
            });
          }
        };
        function createWorker(fn) {
          if (window.Worker && window.Blob && getWebWorker()) {
            var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], {
              type: "text/javascript"
            });
            var url = URL.createObjectURL(blob);
            return new Worker(url);
          }
          workerFn = fn;
          return workerProxy;
        }
        function setupWorker() {
          if (!workerInstance) {
            workerInstance = createWorker(function workerStart(e5) {
              function dataFunctionManager() {
                function completeLayers(layers, comps) {
                  var layerData;
                  var i4;
                  var len = layers.length;
                  var j2;
                  var jLen;
                  var k2;
                  var kLen;
                  for (i4 = 0; i4 < len; i4 += 1) {
                    layerData = layers[i4];
                    if ("ks" in layerData && !layerData.completed) {
                      layerData.completed = true;
                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for (j2 = 0; j2 < jLen; j2 += 1) {
                          if (maskProps[j2].pt.k.i) {
                            convertPathsToAbsoluteValues(maskProps[j2].pt.k);
                          } else {
                            kLen = maskProps[j2].pt.k.length;
                            for (k2 = 0; k2 < kLen; k2 += 1) {
                              if (maskProps[j2].pt.k[k2].s) {
                                convertPathsToAbsoluteValues(maskProps[j2].pt.k[k2].s[0]);
                              }
                              if (maskProps[j2].pt.k[k2].e) {
                                convertPathsToAbsoluteValues(maskProps[j2].pt.k[k2].e[0]);
                              }
                            }
                          }
                        }
                      }
                      if (layerData.ty === 0) {
                        layerData.layers = findCompLayers(layerData.refId, comps);
                        completeLayers(layerData.layers, comps);
                      } else if (layerData.ty === 4) {
                        completeShapes(layerData.shapes);
                      } else if (layerData.ty === 5) {
                        completeText(layerData);
                      }
                    }
                  }
                }
                function completeChars(chars, assets) {
                  if (chars) {
                    var i4 = 0;
                    var len = chars.length;
                    for (i4 = 0; i4 < len; i4 += 1) {
                      if (chars[i4].t === 1) {
                        chars[i4].data.layers = findCompLayers(chars[i4].data.refId, assets);
                        completeLayers(chars[i4].data.layers, assets);
                      }
                    }
                  }
                }
                function findComp(id, comps) {
                  var i4 = 0;
                  var len = comps.length;
                  while (i4 < len) {
                    if (comps[i4].id === id) {
                      return comps[i4];
                    }
                    i4 += 1;
                  }
                  return null;
                }
                function findCompLayers(id, comps) {
                  var comp2 = findComp(id, comps);
                  if (comp2) {
                    if (!comp2.layers.__used) {
                      comp2.layers.__used = true;
                      return comp2.layers;
                    }
                    return JSON.parse(JSON.stringify(comp2.layers));
                  }
                  return null;
                }
                function completeShapes(arr) {
                  var i4;
                  var len = arr.length;
                  var j2;
                  var jLen;
                  for (i4 = len - 1; i4 >= 0; i4 -= 1) {
                    if (arr[i4].ty === "sh") {
                      if (arr[i4].ks.k.i) {
                        convertPathsToAbsoluteValues(arr[i4].ks.k);
                      } else {
                        jLen = arr[i4].ks.k.length;
                        for (j2 = 0; j2 < jLen; j2 += 1) {
                          if (arr[i4].ks.k[j2].s) {
                            convertPathsToAbsoluteValues(arr[i4].ks.k[j2].s[0]);
                          }
                          if (arr[i4].ks.k[j2].e) {
                            convertPathsToAbsoluteValues(arr[i4].ks.k[j2].e[0]);
                          }
                        }
                      }
                    } else if (arr[i4].ty === "gr") {
                      completeShapes(arr[i4].it);
                    }
                  }
                }
                function convertPathsToAbsoluteValues(path) {
                  var i4;
                  var len = path.i.length;
                  for (i4 = 0; i4 < len; i4 += 1) {
                    path.i[i4][0] += path.v[i4][0];
                    path.i[i4][1] += path.v[i4][1];
                    path.o[i4][0] += path.v[i4][0];
                    path.o[i4][1] += path.v[i4][1];
                  }
                }
                function checkVersion(minimum, animVersionString) {
                  var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                  if (minimum[0] > animVersion[0]) {
                    return true;
                  }
                  if (animVersion[0] > minimum[0]) {
                    return false;
                  }
                  if (minimum[1] > animVersion[1]) {
                    return true;
                  }
                  if (animVersion[1] > minimum[1]) {
                    return false;
                  }
                  if (minimum[2] > animVersion[2]) {
                    return true;
                  }
                  if (animVersion[2] > minimum[2]) {
                    return false;
                  }
                  return null;
                }
                var checkText = function() {
                  var minimumVersion = [4, 4, 14];
                  function updateTextLayer(textLayer) {
                    var documentData = textLayer.t.d;
                    textLayer.t.d = {
                      k: [{
                        s: documentData,
                        t: 0
                      }]
                    };
                  }
                  function iterateLayers(layers) {
                    var i4;
                    var len = layers.length;
                    for (i4 = 0; i4 < len; i4 += 1) {
                      if (layers[i4].ty === 5) {
                        updateTextLayer(layers[i4]);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i4;
                        var len = animationData2.assets.length;
                        for (i4 = 0; i4 < len; i4 += 1) {
                          if (animationData2.assets[i4].layers) {
                            iterateLayers(animationData2.assets[i4].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkChars = function() {
                  var minimumVersion = [4, 7, 99];
                  return function(animationData2) {
                    if (animationData2.chars && !checkVersion(minimumVersion, animationData2.v)) {
                      var i4;
                      var len = animationData2.chars.length;
                      for (i4 = 0; i4 < len; i4 += 1) {
                        var charData = animationData2.chars[i4];
                        if (charData.data && charData.data.shapes) {
                          completeShapes(charData.data.shapes);
                          charData.data.ip = 0;
                          charData.data.op = 99999;
                          charData.data.st = 0;
                          charData.data.sr = 1;
                          charData.data.ks = {
                            p: {
                              k: [0, 0],
                              a: 0
                            },
                            s: {
                              k: [100, 100],
                              a: 0
                            },
                            a: {
                              k: [0, 0],
                              a: 0
                            },
                            r: {
                              k: 0,
                              a: 0
                            },
                            o: {
                              k: 100,
                              a: 0
                            }
                          };
                          if (!animationData2.chars[i4].t) {
                            charData.data.shapes.push({
                              ty: "no"
                            });
                            charData.data.shapes[0].it.push({
                              p: {
                                k: [0, 0],
                                a: 0
                              },
                              s: {
                                k: [100, 100],
                                a: 0
                              },
                              a: {
                                k: [0, 0],
                                a: 0
                              },
                              r: {
                                k: 0,
                                a: 0
                              },
                              o: {
                                k: 100,
                                a: 0
                              },
                              sk: {
                                k: 0,
                                a: 0
                              },
                              sa: {
                                k: 0,
                                a: 0
                              },
                              ty: "tr"
                            });
                          }
                        }
                      }
                    }
                  };
                }();
                var checkPathProperties = function() {
                  var minimumVersion = [5, 7, 15];
                  function updateTextLayer(textLayer) {
                    var pathData = textLayer.t.p;
                    if (typeof pathData.a === "number") {
                      pathData.a = {
                        a: 0,
                        k: pathData.a
                      };
                    }
                    if (typeof pathData.p === "number") {
                      pathData.p = {
                        a: 0,
                        k: pathData.p
                      };
                    }
                    if (typeof pathData.r === "number") {
                      pathData.r = {
                        a: 0,
                        k: pathData.r
                      };
                    }
                  }
                  function iterateLayers(layers) {
                    var i4;
                    var len = layers.length;
                    for (i4 = 0; i4 < len; i4 += 1) {
                      if (layers[i4].ty === 5) {
                        updateTextLayer(layers[i4]);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i4;
                        var len = animationData2.assets.length;
                        for (i4 = 0; i4 < len; i4 += 1) {
                          if (animationData2.assets[i4].layers) {
                            iterateLayers(animationData2.assets[i4].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkColors = function() {
                  var minimumVersion = [4, 1, 9];
                  function iterateShapes(shapes) {
                    var i4;
                    var len = shapes.length;
                    var j2;
                    var jLen;
                    for (i4 = 0; i4 < len; i4 += 1) {
                      if (shapes[i4].ty === "gr") {
                        iterateShapes(shapes[i4].it);
                      } else if (shapes[i4].ty === "fl" || shapes[i4].ty === "st") {
                        if (shapes[i4].c.k && shapes[i4].c.k[0].i) {
                          jLen = shapes[i4].c.k.length;
                          for (j2 = 0; j2 < jLen; j2 += 1) {
                            if (shapes[i4].c.k[j2].s) {
                              shapes[i4].c.k[j2].s[0] /= 255;
                              shapes[i4].c.k[j2].s[1] /= 255;
                              shapes[i4].c.k[j2].s[2] /= 255;
                              shapes[i4].c.k[j2].s[3] /= 255;
                            }
                            if (shapes[i4].c.k[j2].e) {
                              shapes[i4].c.k[j2].e[0] /= 255;
                              shapes[i4].c.k[j2].e[1] /= 255;
                              shapes[i4].c.k[j2].e[2] /= 255;
                              shapes[i4].c.k[j2].e[3] /= 255;
                            }
                          }
                        } else {
                          shapes[i4].c.k[0] /= 255;
                          shapes[i4].c.k[1] /= 255;
                          shapes[i4].c.k[2] /= 255;
                          shapes[i4].c.k[3] /= 255;
                        }
                      }
                    }
                  }
                  function iterateLayers(layers) {
                    var i4;
                    var len = layers.length;
                    for (i4 = 0; i4 < len; i4 += 1) {
                      if (layers[i4].ty === 4) {
                        iterateShapes(layers[i4].shapes);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i4;
                        var len = animationData2.assets.length;
                        for (i4 = 0; i4 < len; i4 += 1) {
                          if (animationData2.assets[i4].layers) {
                            iterateLayers(animationData2.assets[i4].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkShapes = function() {
                  var minimumVersion = [4, 4, 18];
                  function completeClosingShapes(arr) {
                    var i4;
                    var len = arr.length;
                    var j2;
                    var jLen;
                    for (i4 = len - 1; i4 >= 0; i4 -= 1) {
                      if (arr[i4].ty === "sh") {
                        if (arr[i4].ks.k.i) {
                          arr[i4].ks.k.c = arr[i4].closed;
                        } else {
                          jLen = arr[i4].ks.k.length;
                          for (j2 = 0; j2 < jLen; j2 += 1) {
                            if (arr[i4].ks.k[j2].s) {
                              arr[i4].ks.k[j2].s[0].c = arr[i4].closed;
                            }
                            if (arr[i4].ks.k[j2].e) {
                              arr[i4].ks.k[j2].e[0].c = arr[i4].closed;
                            }
                          }
                        }
                      } else if (arr[i4].ty === "gr") {
                        completeClosingShapes(arr[i4].it);
                      }
                    }
                  }
                  function iterateLayers(layers) {
                    var layerData;
                    var i4;
                    var len = layers.length;
                    var j2;
                    var jLen;
                    var k2;
                    var kLen;
                    for (i4 = 0; i4 < len; i4 += 1) {
                      layerData = layers[i4];
                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for (j2 = 0; j2 < jLen; j2 += 1) {
                          if (maskProps[j2].pt.k.i) {
                            maskProps[j2].pt.k.c = maskProps[j2].cl;
                          } else {
                            kLen = maskProps[j2].pt.k.length;
                            for (k2 = 0; k2 < kLen; k2 += 1) {
                              if (maskProps[j2].pt.k[k2].s) {
                                maskProps[j2].pt.k[k2].s[0].c = maskProps[j2].cl;
                              }
                              if (maskProps[j2].pt.k[k2].e) {
                                maskProps[j2].pt.k[k2].e[0].c = maskProps[j2].cl;
                              }
                            }
                          }
                        }
                      }
                      if (layerData.ty === 4) {
                        completeClosingShapes(layerData.shapes);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i4;
                        var len = animationData2.assets.length;
                        for (i4 = 0; i4 < len; i4 += 1) {
                          if (animationData2.assets[i4].layers) {
                            iterateLayers(animationData2.assets[i4].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                function completeData(animationData2) {
                  if (animationData2.__complete) {
                    return;
                  }
                  checkColors(animationData2);
                  checkText(animationData2);
                  checkChars(animationData2);
                  checkPathProperties(animationData2);
                  checkShapes(animationData2);
                  completeLayers(animationData2.layers, animationData2.assets);
                  completeChars(animationData2.chars, animationData2.assets);
                  animationData2.__complete = true;
                }
                function completeText(data2) {
                  if (data2.t.a.length === 0 && !("m" in data2.t.p)) {
                  }
                }
                var moduleOb = {};
                moduleOb.completeData = completeData;
                moduleOb.checkColors = checkColors;
                moduleOb.checkChars = checkChars;
                moduleOb.checkPathProperties = checkPathProperties;
                moduleOb.checkShapes = checkShapes;
                moduleOb.completeLayers = completeLayers;
                return moduleOb;
              }
              if (!_workerSelf.dataManager) {
                _workerSelf.dataManager = dataFunctionManager();
              }
              if (!_workerSelf.assetLoader) {
                _workerSelf.assetLoader = function() {
                  function formatResponse(xhr) {
                    var contentTypeHeader = xhr.getResponseHeader("content-type");
                    if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                      return xhr.response;
                    }
                    if (xhr.response && _typeof$5(xhr.response) === "object") {
                      return xhr.response;
                    }
                    if (xhr.response && typeof xhr.response === "string") {
                      return JSON.parse(xhr.response);
                    }
                    if (xhr.responseText) {
                      return JSON.parse(xhr.responseText);
                    }
                    return null;
                  }
                  function loadAsset(path, fullPath, callback, errorCallback) {
                    var response;
                    var xhr = new XMLHttpRequest();
                    try {
                      xhr.responseType = "json";
                    } catch (err) {
                    }
                    xhr.onreadystatechange = function() {
                      if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                          response = formatResponse(xhr);
                          callback(response);
                        } else {
                          try {
                            response = formatResponse(xhr);
                            callback(response);
                          } catch (err) {
                            if (errorCallback) {
                              errorCallback(err);
                            }
                          }
                        }
                      }
                    };
                    try {
                      xhr.open(["G", "E", "T"].join(""), path, true);
                    } catch (error) {
                      xhr.open(["G", "E", "T"].join(""), fullPath + "/" + path, true);
                    }
                    xhr.send();
                  }
                  return {
                    load: loadAsset
                  };
                }();
              }
              if (e5.data.type === "loadAnimation") {
                _workerSelf.assetLoader.load(e5.data.path, e5.data.fullPath, function(data2) {
                  _workerSelf.dataManager.completeData(data2);
                  _workerSelf.postMessage({
                    id: e5.data.id,
                    payload: data2,
                    status: "success"
                  });
                }, function() {
                  _workerSelf.postMessage({
                    id: e5.data.id,
                    status: "error"
                  });
                });
              } else if (e5.data.type === "complete") {
                var animation = e5.data.animation;
                _workerSelf.dataManager.completeData(animation);
                _workerSelf.postMessage({
                  id: e5.data.id,
                  payload: animation,
                  status: "success"
                });
              } else if (e5.data.type === "loadData") {
                _workerSelf.assetLoader.load(e5.data.path, e5.data.fullPath, function(data2) {
                  _workerSelf.postMessage({
                    id: e5.data.id,
                    payload: data2,
                    status: "success"
                  });
                }, function() {
                  _workerSelf.postMessage({
                    id: e5.data.id,
                    status: "error"
                  });
                });
              }
            });
            workerInstance.onmessage = function(event) {
              var data2 = event.data;
              var id = data2.id;
              var process2 = processes[id];
              processes[id] = null;
              if (data2.status === "success") {
                process2.onComplete(data2.payload);
              } else if (process2.onError) {
                process2.onError();
              }
            };
          }
        }
        function createProcess(onComplete, onError) {
          _counterId += 1;
          var id = "processId_" + _counterId;
          processes[id] = {
            onComplete,
            onError
          };
          return id;
        }
        function loadAnimation2(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "loadAnimation",
            path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }
        function loadData(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "loadData",
            path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }
        function completeAnimation(anim, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "complete",
            animation: anim,
            id: processId
          });
        }
        return {
          loadAnimation: loadAnimation2,
          loadData,
          completeAnimation
        };
      }();
      var ImagePreloader = function() {
        var proxyImage = function() {
          var canvas = createTag("canvas");
          canvas.width = 1;
          canvas.height = 1;
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = "rgba(0,0,0,0)";
          ctx.fillRect(0, 0, 1, 1);
          return canvas;
        }();
        function imageLoaded() {
          this.loadedAssets += 1;
          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }
        function footageLoaded() {
          this.loadedFootagesCount += 1;
          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }
        function getAssetsPath(assetData, assetsPath, originalPath) {
          var path = "";
          if (assetData.e) {
            path = assetData.p;
          } else if (assetsPath) {
            var imagePath = assetData.p;
            if (imagePath.indexOf("images/") !== -1) {
              imagePath = imagePath.split("/")[1];
            }
            path = assetsPath + imagePath;
          } else {
            path = originalPath;
            path += assetData.u ? assetData.u : "";
            path += assetData.p;
          }
          return path;
        }
        function testImageLoaded(img) {
          var _count = 0;
          var intervalId = setInterval(function() {
            var box = img.getBBox();
            if (box.width || _count > 500) {
              this._imageLoaded();
              clearInterval(intervalId);
            }
            _count += 1;
          }.bind(this), 50);
        }
        function createImageData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createNS("image");
          if (isSafari) {
            this.testImageLoaded(img);
          } else {
            img.addEventListener("load", this._imageLoaded, false);
          }
          img.addEventListener("error", function() {
            ob2.img = proxyImage;
            this._imageLoaded();
          }.bind(this), false);
          img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
          if (this._elementHelper.append) {
            this._elementHelper.append(img);
          } else {
            this._elementHelper.appendChild(img);
          }
          var ob2 = {
            img,
            assetData
          };
          return ob2;
        }
        function createImgData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createTag("img");
          img.crossOrigin = "anonymous";
          img.addEventListener("load", this._imageLoaded, false);
          img.addEventListener("error", function() {
            ob2.img = proxyImage;
            this._imageLoaded();
          }.bind(this), false);
          img.src = path;
          var ob2 = {
            img,
            assetData
          };
          return ob2;
        }
        function createFootageData(data2) {
          var ob2 = {
            assetData: data2
          };
          var path = getAssetsPath(data2, this.assetsPath, this.path);
          dataManager.loadData(path, function(footageData) {
            ob2.img = footageData;
            this._footageLoaded();
          }.bind(this), function() {
            ob2.img = {};
            this._footageLoaded();
          }.bind(this));
          return ob2;
        }
        function loadAssets(assets, cb) {
          this.imagesLoadedCb = cb;
          var i4;
          var len = assets.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (!assets[i4].layers) {
              if (!assets[i4].t || assets[i4].t === "seq") {
                this.totalImages += 1;
                this.images.push(this._createImageData(assets[i4]));
              } else if (assets[i4].t === 3) {
                this.totalFootages += 1;
                this.images.push(this.createFootageData(assets[i4]));
              }
            }
          }
        }
        function setPath(path) {
          this.path = path || "";
        }
        function setAssetsPath(path) {
          this.assetsPath = path || "";
        }
        function getAsset(assetData) {
          var i4 = 0;
          var len = this.images.length;
          while (i4 < len) {
            if (this.images[i4].assetData === assetData) {
              return this.images[i4].img;
            }
            i4 += 1;
          }
          return null;
        }
        function destroy() {
          this.imagesLoadedCb = null;
          this.images.length = 0;
        }
        function loadedImages() {
          return this.totalImages === this.loadedAssets;
        }
        function loadedFootages() {
          return this.totalFootages === this.loadedFootagesCount;
        }
        function setCacheType(type, elementHelper) {
          if (type === "svg") {
            this._elementHelper = elementHelper;
            this._createImageData = this.createImageData.bind(this);
          } else {
            this._createImageData = this.createImgData.bind(this);
          }
        }
        function ImagePreloaderFactory() {
          this._imageLoaded = imageLoaded.bind(this);
          this._footageLoaded = footageLoaded.bind(this);
          this.testImageLoaded = testImageLoaded.bind(this);
          this.createFootageData = createFootageData.bind(this);
          this.assetsPath = "";
          this.path = "";
          this.totalImages = 0;
          this.totalFootages = 0;
          this.loadedAssets = 0;
          this.loadedFootagesCount = 0;
          this.imagesLoadedCb = null;
          this.images = [];
        }
        ImagePreloaderFactory.prototype = {
          loadAssets,
          setAssetsPath,
          setPath,
          loadedImages,
          loadedFootages,
          destroy,
          getAsset,
          createImgData,
          createImageData,
          imageLoaded,
          footageLoaded,
          setCacheType
        };
        return ImagePreloaderFactory;
      }();
      function BaseEvent() {
      }
      BaseEvent.prototype = {
        triggerEvent: function triggerEvent(eventName, args) {
          if (this._cbs[eventName]) {
            var callbacks = this._cbs[eventName];
            for (var i4 = 0; i4 < callbacks.length; i4 += 1) {
              callbacks[i4](args);
            }
          }
        },
        addEventListener: function addEventListener(eventName, callback) {
          if (!this._cbs[eventName]) {
            this._cbs[eventName] = [];
          }
          this._cbs[eventName].push(callback);
          return function() {
            this.removeEventListener(eventName, callback);
          }.bind(this);
        },
        removeEventListener: function removeEventListener(eventName, callback) {
          if (!callback) {
            this._cbs[eventName] = null;
          } else if (this._cbs[eventName]) {
            var i4 = 0;
            var len = this._cbs[eventName].length;
            while (i4 < len) {
              if (this._cbs[eventName][i4] === callback) {
                this._cbs[eventName].splice(i4, 1);
                i4 -= 1;
                len -= 1;
              }
              i4 += 1;
            }
            if (!this._cbs[eventName].length) {
              this._cbs[eventName] = null;
            }
          }
        }
      };
      var markerParser = function() {
        function parsePayloadLines(payload) {
          var lines = payload.split("\r\n");
          var keys = {};
          var line;
          var keysCount = 0;
          for (var i4 = 0; i4 < lines.length; i4 += 1) {
            line = lines[i4].split(":");
            if (line.length === 2) {
              keys[line[0]] = line[1].trim();
              keysCount += 1;
            }
          }
          if (keysCount === 0) {
            throw new Error();
          }
          return keys;
        }
        return function(_markers) {
          var markers = [];
          for (var i4 = 0; i4 < _markers.length; i4 += 1) {
            var _marker = _markers[i4];
            var markerData = {
              time: _marker.tm,
              duration: _marker.dr
            };
            try {
              markerData.payload = JSON.parse(_markers[i4].cm);
            } catch (_2) {
              try {
                markerData.payload = parsePayloadLines(_markers[i4].cm);
              } catch (__) {
                markerData.payload = {
                  name: _markers[i4].cm
                };
              }
            }
            markers.push(markerData);
          }
          return markers;
        };
      }();
      var ProjectInterface = function() {
        function registerComposition(comp2) {
          this.compositions.push(comp2);
        }
        return function() {
          function _thisProjectFunction(name2) {
            var i4 = 0;
            var len = this.compositions.length;
            while (i4 < len) {
              if (this.compositions[i4].data && this.compositions[i4].data.nm === name2) {
                if (this.compositions[i4].prepareFrame && this.compositions[i4].data.xt) {
                  this.compositions[i4].prepareFrame(this.currentFrame);
                }
                return this.compositions[i4].compInterface;
              }
              i4 += 1;
            }
            return null;
          }
          _thisProjectFunction.compositions = [];
          _thisProjectFunction.currentFrame = 0;
          _thisProjectFunction.registerComposition = registerComposition;
          return _thisProjectFunction;
        };
      }();
      var renderers = {};
      var registerRenderer = function registerRenderer2(key2, value2) {
        renderers[key2] = value2;
      };
      function getRenderer(key2) {
        return renderers[key2];
      }
      function getRegisteredRenderer() {
        if (renderers.canvas) {
          return "canvas";
        }
        for (var key2 in renderers) {
          if (renderers[key2]) {
            return key2;
          }
        }
        return "";
      }
      function _typeof$4(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$4 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$4 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$4(obj);
      }
      var AnimationItem = function AnimationItem2() {
        this._cbs = [];
        this.name = "";
        this.path = "";
        this.isLoaded = false;
        this.currentFrame = 0;
        this.currentRawFrame = 0;
        this.firstFrame = 0;
        this.totalFrames = 0;
        this.frameRate = 0;
        this.frameMult = 0;
        this.playSpeed = 1;
        this.playDirection = 1;
        this.playCount = 0;
        this.animationData = {};
        this.assets = [];
        this.isPaused = true;
        this.autoplay = false;
        this.loop = true;
        this.renderer = null;
        this.animationID = createElementID();
        this.assetsPath = "";
        this.timeCompleted = 0;
        this.segmentPos = 0;
        this.isSubframeEnabled = getSubframeEnabled();
        this.segments = [];
        this._idle = true;
        this._completedLoop = false;
        this.projectInterface = ProjectInterface();
        this.imagePreloader = new ImagePreloader();
        this.audioController = audioControllerFactory();
        this.markers = [];
        this.configAnimation = this.configAnimation.bind(this);
        this.onSetupError = this.onSetupError.bind(this);
        this.onSegmentComplete = this.onSegmentComplete.bind(this);
        this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
        this.expressionsPlugin = getExpressionsPlugin();
      };
      extendPrototype([BaseEvent], AnimationItem);
      AnimationItem.prototype.setParams = function(params) {
        if (params.wrapper || params.container) {
          this.wrapper = params.wrapper || params.container;
        }
        var animType = "svg";
        if (params.animType) {
          animType = params.animType;
        } else if (params.renderer) {
          animType = params.renderer;
        }
        var RendererClass = getRenderer(animType);
        this.renderer = new RendererClass(this, params.rendererSettings);
        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
        this.renderer.setProjectInterface(this.projectInterface);
        this.animType = animType;
        if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
          this.loop = true;
        } else if (params.loop === false) {
          this.loop = false;
        } else {
          this.loop = parseInt(params.loop, 10);
        }
        this.autoplay = "autoplay" in params ? params.autoplay : true;
        this.name = params.name ? params.name : "";
        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
        this.assetsPath = params.assetsPath;
        this.initialSegment = params.initialSegment;
        if (params.audioFactory) {
          this.audioController.setAudioFactory(params.audioFactory);
        }
        if (params.animationData) {
          this.setupAnimation(params.animationData);
        } else if (params.path) {
          if (params.path.lastIndexOf("\\") !== -1) {
            this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
          } else {
            this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
          }
          this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
          this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
          dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
        }
      };
      AnimationItem.prototype.onSetupError = function() {
        this.trigger("data_failed");
      };
      AnimationItem.prototype.setupAnimation = function(data2) {
        dataManager.completeAnimation(data2, this.configAnimation);
      };
      AnimationItem.prototype.setData = function(wrapper, animationData2) {
        if (animationData2) {
          if (_typeof$4(animationData2) !== "object") {
            animationData2 = JSON.parse(animationData2);
          }
        }
        var params = {
          wrapper,
          animationData: animationData2
        };
        var wrapperAttributes = wrapper.attributes;
        params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
        params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
        var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
        if (loop === "false") {
          params.loop = false;
        } else if (loop === "true") {
          params.loop = true;
        } else if (loop !== "") {
          params.loop = parseInt(loop, 10);
        }
        var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
        params.autoplay = autoplay !== "false";
        params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
        var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
        if (prerender === "false") {
          params.prerender = false;
        }
        if (!params.path) {
          this.trigger("destroy");
        } else {
          this.setParams(params);
        }
      };
      AnimationItem.prototype.includeLayers = function(data2) {
        if (data2.op > this.animationData.op) {
          this.animationData.op = data2.op;
          this.totalFrames = Math.floor(data2.op - this.animationData.ip);
        }
        var layers = this.animationData.layers;
        var i4;
        var len = layers.length;
        var newLayers = data2.layers;
        var j2;
        var jLen = newLayers.length;
        for (j2 = 0; j2 < jLen; j2 += 1) {
          i4 = 0;
          while (i4 < len) {
            if (layers[i4].id === newLayers[j2].id) {
              layers[i4] = newLayers[j2];
              break;
            }
            i4 += 1;
          }
        }
        if (data2.chars || data2.fonts) {
          this.renderer.globalData.fontManager.addChars(data2.chars);
          this.renderer.globalData.fontManager.addFonts(data2.fonts, this.renderer.globalData.defs);
        }
        if (data2.assets) {
          len = data2.assets.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            this.animationData.assets.push(data2.assets[i4]);
          }
        }
        this.animationData.__complete = false;
        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
      };
      AnimationItem.prototype.onSegmentComplete = function(data2) {
        this.animationData = data2;
        var expressionsPlugin2 = getExpressionsPlugin();
        if (expressionsPlugin2) {
          expressionsPlugin2.initExpressions(this);
        }
        this.loadNextSegment();
      };
      AnimationItem.prototype.loadNextSegment = function() {
        var segments = this.animationData.segments;
        if (!segments || segments.length === 0 || !this.autoloadSegments) {
          this.trigger("data_ready");
          this.timeCompleted = this.totalFrames;
          return;
        }
        var segment = segments.shift();
        this.timeCompleted = segment.time * this.frameRate;
        var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
        this.segmentPos += 1;
        dataManager.loadData(segmentPath, this.includeLayers.bind(this), function() {
          this.trigger("data_failed");
        }.bind(this));
      };
      AnimationItem.prototype.loadSegments = function() {
        var segments = this.animationData.segments;
        if (!segments) {
          this.timeCompleted = this.totalFrames;
        }
        this.loadNextSegment();
      };
      AnimationItem.prototype.imagesLoaded = function() {
        this.trigger("loaded_images");
        this.checkLoaded();
      };
      AnimationItem.prototype.preloadImages = function() {
        this.imagePreloader.setAssetsPath(this.assetsPath);
        this.imagePreloader.setPath(this.path);
        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
      };
      AnimationItem.prototype.configAnimation = function(animData) {
        if (!this.renderer) {
          return;
        }
        try {
          this.animationData = animData;
          if (this.initialSegment) {
            this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
            this.firstFrame = Math.round(this.initialSegment[0]);
          } else {
            this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
            this.firstFrame = Math.round(this.animationData.ip);
          }
          this.renderer.configAnimation(animData);
          if (!animData.assets) {
            animData.assets = [];
          }
          this.assets = this.animationData.assets;
          this.frameRate = this.animationData.fr;
          this.frameMult = this.animationData.fr / 1e3;
          this.renderer.searchExtraCompositions(animData.assets);
          this.markers = markerParser(animData.markers || []);
          this.trigger("config_ready");
          this.preloadImages();
          this.loadSegments();
          this.updaFrameModifier();
          this.waitForFontsLoaded();
          if (this.isPaused) {
            this.audioController.pause();
          }
        } catch (error) {
          this.triggerConfigError(error);
        }
      };
      AnimationItem.prototype.waitForFontsLoaded = function() {
        if (!this.renderer) {
          return;
        }
        if (this.renderer.globalData.fontManager.isLoaded) {
          this.checkLoaded();
        } else {
          setTimeout(this.waitForFontsLoaded.bind(this), 20);
        }
      };
      AnimationItem.prototype.checkLoaded = function() {
        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
          this.isLoaded = true;
          var expressionsPlugin2 = getExpressionsPlugin();
          if (expressionsPlugin2) {
            expressionsPlugin2.initExpressions(this);
          }
          this.renderer.initItems();
          setTimeout(function() {
            this.trigger("DOMLoaded");
          }.bind(this), 0);
          this.gotoFrame();
          if (this.autoplay) {
            this.play();
          }
        }
      };
      AnimationItem.prototype.resize = function(width2, height2) {
        var _width = typeof width2 === "number" ? width2 : void 0;
        var _height = typeof height2 === "number" ? height2 : void 0;
        this.renderer.updateContainerSize(_width, _height);
      };
      AnimationItem.prototype.setSubframe = function(flag) {
        this.isSubframeEnabled = !!flag;
      };
      AnimationItem.prototype.gotoFrame = function() {
        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
          this.currentFrame = this.timeCompleted;
        }
        this.trigger("enterFrame");
        this.renderFrame();
        this.trigger("drawnFrame");
      };
      AnimationItem.prototype.renderFrame = function() {
        if (this.isLoaded === false || !this.renderer) {
          return;
        }
        try {
          if (this.expressionsPlugin) {
            this.expressionsPlugin.resetFrame();
          }
          this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (error) {
          this.triggerRenderFrameError(error);
        }
      };
      AnimationItem.prototype.play = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === true) {
          this.isPaused = false;
          this.trigger("_play");
          this.audioController.resume();
          if (this._idle) {
            this._idle = false;
            this.trigger("_active");
          }
        }
      };
      AnimationItem.prototype.pause = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === false) {
          this.isPaused = true;
          this.trigger("_pause");
          this._idle = true;
          this.trigger("_idle");
          this.audioController.pause();
        }
      };
      AnimationItem.prototype.togglePause = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === true) {
          this.play();
        } else {
          this.pause();
        }
      };
      AnimationItem.prototype.stop = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.pause();
        this.playCount = 0;
        this._completedLoop = false;
        this.setCurrentRawFrameValue(0);
      };
      AnimationItem.prototype.getMarkerData = function(markerName) {
        var marker;
        for (var i4 = 0; i4 < this.markers.length; i4 += 1) {
          marker = this.markers[i4];
          if (marker.payload && marker.payload.name === markerName) {
            return marker;
          }
        }
        return null;
      };
      AnimationItem.prototype.goToAndStop = function(value2, isFrame, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        var numValue = Number(value2);
        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value2);
          if (marker) {
            this.goToAndStop(marker.time, true);
          }
        } else if (isFrame) {
          this.setCurrentRawFrameValue(value2);
        } else {
          this.setCurrentRawFrameValue(value2 * this.frameModifier);
        }
        this.pause();
      };
      AnimationItem.prototype.goToAndPlay = function(value2, isFrame, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        var numValue = Number(value2);
        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value2);
          if (marker) {
            if (!marker.duration) {
              this.goToAndStop(marker.time, true);
            } else {
              this.playSegments([marker.time, marker.time + marker.duration], true);
            }
          }
        } else {
          this.goToAndStop(numValue, isFrame, name2);
        }
        this.play();
      };
      AnimationItem.prototype.advanceTime = function(value2) {
        if (this.isPaused === true || this.isLoaded === false) {
          return;
        }
        var nextValue = this.currentRawFrame + value2 * this.frameModifier;
        var _isComplete = false;
        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
          if (!this.loop || this.playCount === this.loop) {
            if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
              _isComplete = true;
              nextValue = this.totalFrames - 1;
            }
          } else if (nextValue >= this.totalFrames) {
            this.playCount += 1;
            if (!this.checkSegments(nextValue % this.totalFrames)) {
              this.setCurrentRawFrameValue(nextValue % this.totalFrames);
              this._completedLoop = true;
              this.trigger("loopComplete");
            }
          } else {
            this.setCurrentRawFrameValue(nextValue);
          }
        } else if (nextValue < 0) {
          if (!this.checkSegments(nextValue % this.totalFrames)) {
            if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
              this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
              if (!this._completedLoop) {
                this._completedLoop = true;
              } else {
                this.trigger("loopComplete");
              }
            } else {
              _isComplete = true;
              nextValue = 0;
            }
          }
        } else {
          this.setCurrentRawFrameValue(nextValue);
        }
        if (_isComplete) {
          this.setCurrentRawFrameValue(nextValue);
          this.pause();
          this.trigger("complete");
        }
      };
      AnimationItem.prototype.adjustSegment = function(arr, offset) {
        this.playCount = 0;
        if (arr[1] < arr[0]) {
          if (this.frameModifier > 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(-1);
            }
          }
          this.totalFrames = arr[0] - arr[1];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[1];
          this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset);
        } else if (arr[1] > arr[0]) {
          if (this.frameModifier < 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(1);
            }
          }
          this.totalFrames = arr[1] - arr[0];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[0];
          this.setCurrentRawFrameValue(1e-3 + offset);
        }
        this.trigger("segmentStart");
      };
      AnimationItem.prototype.setSegment = function(init, end) {
        var pendingFrame = -1;
        if (this.isPaused) {
          if (this.currentRawFrame + this.firstFrame < init) {
            pendingFrame = init;
          } else if (this.currentRawFrame + this.firstFrame > end) {
            pendingFrame = end - init;
          }
        }
        this.firstFrame = init;
        this.totalFrames = end - init;
        this.timeCompleted = this.totalFrames;
        if (pendingFrame !== -1) {
          this.goToAndStop(pendingFrame, true);
        }
      };
      AnimationItem.prototype.playSegments = function(arr, forceFlag) {
        if (forceFlag) {
          this.segments.length = 0;
        }
        if (_typeof$4(arr[0]) === "object") {
          var i4;
          var len = arr.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            this.segments.push(arr[i4]);
          }
        } else {
          this.segments.push(arr);
        }
        if (this.segments.length && forceFlag) {
          this.adjustSegment(this.segments.shift(), 0);
        }
        if (this.isPaused) {
          this.play();
        }
      };
      AnimationItem.prototype.resetSegments = function(forceFlag) {
        this.segments.length = 0;
        this.segments.push([this.animationData.ip, this.animationData.op]);
        if (forceFlag) {
          this.checkSegments(0);
        }
      };
      AnimationItem.prototype.checkSegments = function(offset) {
        if (this.segments.length) {
          this.adjustSegment(this.segments.shift(), offset);
          return true;
        }
        return false;
      };
      AnimationItem.prototype.destroy = function(name2) {
        if (name2 && this.name !== name2 || !this.renderer) {
          return;
        }
        this.renderer.destroy();
        this.imagePreloader.destroy();
        this.trigger("destroy");
        this._cbs = null;
        this.onEnterFrame = null;
        this.onLoopComplete = null;
        this.onComplete = null;
        this.onSegmentStart = null;
        this.onDestroy = null;
        this.renderer = null;
        this.expressionsPlugin = null;
        this.imagePreloader = null;
        this.projectInterface = null;
      };
      AnimationItem.prototype.setCurrentRawFrameValue = function(value2) {
        this.currentRawFrame = value2;
        this.gotoFrame();
      };
      AnimationItem.prototype.setSpeed = function(val2) {
        this.playSpeed = val2;
        this.updaFrameModifier();
      };
      AnimationItem.prototype.setDirection = function(val2) {
        this.playDirection = val2 < 0 ? -1 : 1;
        this.updaFrameModifier();
      };
      AnimationItem.prototype.setLoop = function(isLooping) {
        this.loop = isLooping;
      };
      AnimationItem.prototype.setVolume = function(val2, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.setVolume(val2);
      };
      AnimationItem.prototype.getVolume = function() {
        return this.audioController.getVolume();
      };
      AnimationItem.prototype.mute = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.mute();
      };
      AnimationItem.prototype.unmute = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.unmute();
      };
      AnimationItem.prototype.updaFrameModifier = function() {
        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
        this.audioController.setRate(this.playSpeed * this.playDirection);
      };
      AnimationItem.prototype.getPath = function() {
        return this.path;
      };
      AnimationItem.prototype.getAssetsPath = function(assetData) {
        var path = "";
        if (assetData.e) {
          path = assetData.p;
        } else if (this.assetsPath) {
          var imagePath = assetData.p;
          if (imagePath.indexOf("images/") !== -1) {
            imagePath = imagePath.split("/")[1];
          }
          path = this.assetsPath + imagePath;
        } else {
          path = this.path;
          path += assetData.u ? assetData.u : "";
          path += assetData.p;
        }
        return path;
      };
      AnimationItem.prototype.getAssetData = function(id) {
        var i4 = 0;
        var len = this.assets.length;
        while (i4 < len) {
          if (id === this.assets[i4].id) {
            return this.assets[i4];
          }
          i4 += 1;
        }
        return null;
      };
      AnimationItem.prototype.hide = function() {
        this.renderer.hide();
      };
      AnimationItem.prototype.show = function() {
        this.renderer.show();
      };
      AnimationItem.prototype.getDuration = function(isFrame) {
        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
      };
      AnimationItem.prototype.updateDocumentData = function(path, documentData, index2) {
        try {
          var element = this.renderer.getElementByPath(path);
          element.updateDocumentData(documentData, index2);
        } catch (error) {
        }
      };
      AnimationItem.prototype.trigger = function(name2) {
        if (this._cbs && this._cbs[name2]) {
          switch (name2) {
            case "enterFrame":
              this.triggerEvent(name2, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameModifier));
              break;
            case "drawnFrame":
              this.drawnFrameEvent.currentTime = this.currentFrame;
              this.drawnFrameEvent.totalTime = this.totalFrames;
              this.drawnFrameEvent.direction = this.frameModifier;
              this.triggerEvent(name2, this.drawnFrameEvent);
              break;
            case "loopComplete":
              this.triggerEvent(name2, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
              break;
            case "complete":
              this.triggerEvent(name2, new BMCompleteEvent(name2, this.frameMult));
              break;
            case "segmentStart":
              this.triggerEvent(name2, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
              break;
            case "destroy":
              this.triggerEvent(name2, new BMDestroyEvent(name2, this));
              break;
            default:
              this.triggerEvent(name2);
          }
        }
        if (name2 === "enterFrame" && this.onEnterFrame) {
          this.onEnterFrame.call(this, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameMult));
        }
        if (name2 === "loopComplete" && this.onLoopComplete) {
          this.onLoopComplete.call(this, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
        }
        if (name2 === "complete" && this.onComplete) {
          this.onComplete.call(this, new BMCompleteEvent(name2, this.frameMult));
        }
        if (name2 === "segmentStart" && this.onSegmentStart) {
          this.onSegmentStart.call(this, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
        }
        if (name2 === "destroy" && this.onDestroy) {
          this.onDestroy.call(this, new BMDestroyEvent(name2, this));
        }
      };
      AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) {
          this.onError.call(this, error);
        }
      };
      AnimationItem.prototype.triggerConfigError = function(nativeError) {
        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) {
          this.onError.call(this, error);
        }
      };
      var animationManager = function() {
        var moduleOb = {};
        var registeredAnimations = [];
        var initTime = 0;
        var len = 0;
        var playingAnimationsNum = 0;
        var _stopped = true;
        var _isFrozen = false;
        function removeElement(ev) {
          var i4 = 0;
          var animItem = ev.target;
          while (i4 < len) {
            if (registeredAnimations[i4].animation === animItem) {
              registeredAnimations.splice(i4, 1);
              i4 -= 1;
              len -= 1;
              if (!animItem.isPaused) {
                subtractPlayingCount();
              }
            }
            i4 += 1;
          }
        }
        function registerAnimation(element, animationData2) {
          if (!element) {
            return null;
          }
          var i4 = 0;
          while (i4 < len) {
            if (registeredAnimations[i4].elem === element && registeredAnimations[i4].elem !== null) {
              return registeredAnimations[i4].animation;
            }
            i4 += 1;
          }
          var animItem = new AnimationItem();
          setupAnimation(animItem, element);
          animItem.setData(element, animationData2);
          return animItem;
        }
        function getRegisteredAnimations() {
          var i4;
          var lenAnims = registeredAnimations.length;
          var animations = [];
          for (i4 = 0; i4 < lenAnims; i4 += 1) {
            animations.push(registeredAnimations[i4].animation);
          }
          return animations;
        }
        function addPlayingCount() {
          playingAnimationsNum += 1;
          activate();
        }
        function subtractPlayingCount() {
          playingAnimationsNum -= 1;
        }
        function setupAnimation(animItem, element) {
          animItem.addEventListener("destroy", removeElement);
          animItem.addEventListener("_active", addPlayingCount);
          animItem.addEventListener("_idle", subtractPlayingCount);
          registeredAnimations.push({
            elem: element,
            animation: animItem
          });
          len += 1;
        }
        function loadAnimation2(params) {
          var animItem = new AnimationItem();
          setupAnimation(animItem, null);
          animItem.setParams(params);
          return animItem;
        }
        function setSpeed(val2, animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.setSpeed(val2, animation);
          }
        }
        function setDirection(val2, animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.setDirection(val2, animation);
          }
        }
        function play(animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.play(animation);
          }
        }
        function resume(nowTime) {
          var elapsedTime = nowTime - initTime;
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.advanceTime(elapsedTime);
          }
          initTime = nowTime;
          if (playingAnimationsNum && !_isFrozen) {
            window.requestAnimationFrame(resume);
          } else {
            _stopped = true;
          }
        }
        function first(nowTime) {
          initTime = nowTime;
          window.requestAnimationFrame(resume);
        }
        function pause(animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.pause(animation);
          }
        }
        function goToAndStop(value2, isFrame, animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.goToAndStop(value2, isFrame, animation);
          }
        }
        function stop(animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.stop(animation);
          }
        }
        function togglePause(animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.togglePause(animation);
          }
        }
        function destroy(animation) {
          var i4;
          for (i4 = len - 1; i4 >= 0; i4 -= 1) {
            registeredAnimations[i4].animation.destroy(animation);
          }
        }
        function searchAnimations2(animationData2, standalone2, renderer2) {
          var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
          var i4;
          var lenAnims = animElements.length;
          for (i4 = 0; i4 < lenAnims; i4 += 1) {
            if (renderer2) {
              animElements[i4].setAttribute("data-bm-type", renderer2);
            }
            registerAnimation(animElements[i4], animationData2);
          }
          if (standalone2 && lenAnims === 0) {
            if (!renderer2) {
              renderer2 = "svg";
            }
            var body = document.getElementsByTagName("body")[0];
            body.innerText = "";
            var div2 = createTag("div");
            div2.style.width = "100%";
            div2.style.height = "100%";
            div2.setAttribute("data-bm-type", renderer2);
            body.appendChild(div2);
            registerAnimation(div2, animationData2);
          }
        }
        function resize() {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.resize();
          }
        }
        function activate() {
          if (!_isFrozen && playingAnimationsNum) {
            if (_stopped) {
              window.requestAnimationFrame(first);
              _stopped = false;
            }
          }
        }
        function freeze() {
          _isFrozen = true;
        }
        function unfreeze() {
          _isFrozen = false;
          activate();
        }
        function setVolume(val2, animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.setVolume(val2, animation);
          }
        }
        function mute(animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.mute(animation);
          }
        }
        function unmute(animation) {
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            registeredAnimations[i4].animation.unmute(animation);
          }
        }
        moduleOb.registerAnimation = registerAnimation;
        moduleOb.loadAnimation = loadAnimation2;
        moduleOb.setSpeed = setSpeed;
        moduleOb.setDirection = setDirection;
        moduleOb.play = play;
        moduleOb.pause = pause;
        moduleOb.stop = stop;
        moduleOb.togglePause = togglePause;
        moduleOb.searchAnimations = searchAnimations2;
        moduleOb.resize = resize;
        moduleOb.goToAndStop = goToAndStop;
        moduleOb.destroy = destroy;
        moduleOb.freeze = freeze;
        moduleOb.unfreeze = unfreeze;
        moduleOb.setVolume = setVolume;
        moduleOb.mute = mute;
        moduleOb.unmute = unmute;
        moduleOb.getRegisteredAnimations = getRegisteredAnimations;
        return moduleOb;
      }();
      var BezierFactory = function() {
        var ob2 = {};
        ob2.getBezierEasing = getBezierEasing;
        var beziers = {};
        function getBezierEasing(a3, b2, c2, d2, nm) {
          var str = nm || ("bez_" + a3 + "_" + b2 + "_" + c2 + "_" + d2).replace(/\./g, "p");
          if (beziers[str]) {
            return beziers[str];
          }
          var bezEasing = new BezierEasing([a3, b2, c2, d2]);
          beziers[str] = bezEasing;
          return bezEasing;
        }
        var NEWTON_ITERATIONS = 4;
        var NEWTON_MIN_SLOPE = 1e-3;
        var SUBDIVISION_PRECISION = 1e-7;
        var SUBDIVISION_MAX_ITERATIONS = 10;
        var kSplineTableSize = 11;
        var kSampleStepSize = 1 / (kSplineTableSize - 1);
        var float32ArraySupported = typeof Float32Array === "function";
        function A2(aA1, aA2) {
          return 1 - 3 * aA2 + 3 * aA1;
        }
        function B(aA1, aA2) {
          return 3 * aA2 - 6 * aA1;
        }
        function C2(aA1) {
          return 3 * aA1;
        }
        function calcBezier(aT, aA1, aA2) {
          return ((A2(aA1, aA2) * aT + B(aA1, aA2)) * aT + C2(aA1)) * aT;
        }
        function getSlope(aT, aA1, aA2) {
          return 3 * A2(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C2(aA1);
        }
        function binarySubdivide(aX, aA, aB, mX1, mX2) {
          var currentX, currentT, i4 = 0;
          do {
            currentT = aA + (aB - aA) / 2;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i4 < SUBDIVISION_MAX_ITERATIONS);
          return currentT;
        }
        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
          for (var i4 = 0; i4 < NEWTON_ITERATIONS; ++i4) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0)
              return aGuessT;
            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }
          return aGuessT;
        }
        function BezierEasing(points) {
          this._p = points;
          this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
          this._precomputed = false;
          this.get = this.get.bind(this);
        }
        BezierEasing.prototype = {
          get: function get2(x2) {
            var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
            if (!this._precomputed)
              this._precompute();
            if (mX1 === mY1 && mX2 === mY2)
              return x2;
            if (x2 === 0)
              return 0;
            if (x2 === 1)
              return 1;
            return calcBezier(this._getTForX(x2), mY1, mY2);
          },
          // Private part
          _precompute: function _precompute() {
            var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
            this._precomputed = true;
            if (mX1 !== mY1 || mX2 !== mY2) {
              this._calcSampleValues();
            }
          },
          _calcSampleValues: function _calcSampleValues() {
            var mX1 = this._p[0], mX2 = this._p[2];
            for (var i4 = 0; i4 < kSplineTableSize; ++i4) {
              this._mSampleValues[i4] = calcBezier(i4 * kSampleStepSize, mX1, mX2);
            }
          },
          /**
               * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
               */
          _getTForX: function _getTForX(aX) {
            var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
            var intervalStart = 0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;
            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
              intervalStart += kSampleStepSize;
            }
            --currentSample;
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;
            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
              return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
            }
            if (initialSlope === 0) {
              return guessForT;
            }
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        };
        return ob2;
      }();
      var pooling = function() {
        function _double(arr) {
          return arr.concat(createSizedArray(arr.length));
        }
        return {
          "double": _double
        };
      }();
      var poolFactory = function() {
        return function(initialLength, _create, _release) {
          var _length = 0;
          var _maxLength = initialLength;
          var pool = createSizedArray(_maxLength);
          var ob2 = {
            newElement,
            release
          };
          function newElement() {
            var element;
            if (_length) {
              _length -= 1;
              element = pool[_length];
            } else {
              element = _create();
            }
            return element;
          }
          function release(element) {
            if (_length === _maxLength) {
              pool = pooling["double"](pool);
              _maxLength *= 2;
            }
            if (_release) {
              _release(element);
            }
            pool[_length] = element;
            _length += 1;
          }
          return ob2;
        };
      }();
      var bezierLengthPool = function() {
        function create() {
          return {
            addedLength: 0,
            percents: createTypedArray("float32", getDefaultCurveSegments()),
            lengths: createTypedArray("float32", getDefaultCurveSegments())
          };
        }
        return poolFactory(8, create);
      }();
      var segmentsLengthPool = function() {
        function create() {
          return {
            lengths: [],
            totalLength: 0
          };
        }
        function release(element) {
          var i4;
          var len = element.lengths.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            bezierLengthPool.release(element.lengths[i4]);
          }
          element.lengths.length = 0;
        }
        return poolFactory(8, create, release);
      }();
      function bezFunction() {
        var math = Math;
        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
          var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
          return det1 > -1e-3 && det1 < 1e-3;
        }
        function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
          if (z1 === 0 && z2 === 0 && z3 === 0) {
            return pointOnLine2D(x1, y1, x2, y2, x3, y3);
          }
          var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
          var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
          var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
          var diffDist;
          if (dist1 > dist2) {
            if (dist1 > dist3) {
              diffDist = dist1 - dist2 - dist3;
            } else {
              diffDist = dist3 - dist2 - dist1;
            }
          } else if (dist3 > dist2) {
            diffDist = dist3 - dist2 - dist1;
          } else {
            diffDist = dist2 - dist1 - dist3;
          }
          return diffDist > -1e-4 && diffDist < 1e-4;
        }
        var getBezierLength = function() {
          return function(pt1, pt2, pt3, pt4) {
            var curveSegments = getDefaultCurveSegments();
            var k2;
            var i4;
            var len;
            var ptCoord;
            var perc;
            var addedLength = 0;
            var ptDistance;
            var point = [];
            var lastPoint = [];
            var lengthData = bezierLengthPool.newElement();
            len = pt3.length;
            for (k2 = 0; k2 < curveSegments; k2 += 1) {
              perc = k2 / (curveSegments - 1);
              ptDistance = 0;
              for (i4 = 0; i4 < len; i4 += 1) {
                ptCoord = bmPow(1 - perc, 3) * pt1[i4] + 3 * bmPow(1 - perc, 2) * perc * pt3[i4] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i4] + bmPow(perc, 3) * pt2[i4];
                point[i4] = ptCoord;
                if (lastPoint[i4] !== null) {
                  ptDistance += bmPow(point[i4] - lastPoint[i4], 2);
                }
                lastPoint[i4] = point[i4];
              }
              if (ptDistance) {
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
              }
              lengthData.percents[k2] = perc;
              lengthData.lengths[k2] = addedLength;
            }
            lengthData.addedLength = addedLength;
            return lengthData;
          };
        }();
        function getSegmentsLength(shapeData) {
          var segmentsLength = segmentsLengthPool.newElement();
          var closed = shapeData.c;
          var pathV = shapeData.v;
          var pathO = shapeData.o;
          var pathI = shapeData.i;
          var i4;
          var len = shapeData._length;
          var lengths = segmentsLength.lengths;
          var totalLength = 0;
          for (i4 = 0; i4 < len - 1; i4 += 1) {
            lengths[i4] = getBezierLength(pathV[i4], pathV[i4 + 1], pathO[i4], pathI[i4 + 1]);
            totalLength += lengths[i4].addedLength;
          }
          if (closed && len) {
            lengths[i4] = getBezierLength(pathV[i4], pathV[0], pathO[i4], pathI[0]);
            totalLength += lengths[i4].addedLength;
          }
          segmentsLength.totalLength = totalLength;
          return segmentsLength;
        }
        function BezierData(length2) {
          this.segmentLength = 0;
          this.points = new Array(length2);
        }
        function PointData(partial, point) {
          this.partialLength = partial;
          this.point = point;
        }
        var buildBezierData = function() {
          var storedData = {};
          return function(pt1, pt2, pt3, pt4) {
            var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
            if (!storedData[bezierName]) {
              var curveSegments = getDefaultCurveSegments();
              var k2;
              var i4;
              var len;
              var ptCoord;
              var perc;
              var addedLength = 0;
              var ptDistance;
              var point;
              var lastPoint = null;
              if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                curveSegments = 2;
              }
              var bezierData = new BezierData(curveSegments);
              len = pt3.length;
              for (k2 = 0; k2 < curveSegments; k2 += 1) {
                point = createSizedArray(len);
                perc = k2 / (curveSegments - 1);
                ptDistance = 0;
                for (i4 = 0; i4 < len; i4 += 1) {
                  ptCoord = bmPow(1 - perc, 3) * pt1[i4] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i4] + pt3[i4]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i4] + pt4[i4]) + bmPow(perc, 3) * pt2[i4];
                  point[i4] = ptCoord;
                  if (lastPoint !== null) {
                    ptDistance += bmPow(point[i4] - lastPoint[i4], 2);
                  }
                }
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
                bezierData.points[k2] = new PointData(ptDistance, point);
                lastPoint = point;
              }
              bezierData.segmentLength = addedLength;
              storedData[bezierName] = bezierData;
            }
            return storedData[bezierName];
          };
        }();
        function getDistancePerc(perc, bezierData) {
          var percents = bezierData.percents;
          var lengths = bezierData.lengths;
          var len = percents.length;
          var initPos = bmFloor((len - 1) * perc);
          var lengthPos = perc * bezierData.addedLength;
          var lPerc = 0;
          if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
            return percents[initPos];
          }
          var dir = lengths[initPos] > lengthPos ? -1 : 1;
          var flag = true;
          while (flag) {
            if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
              lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
              flag = false;
            } else {
              initPos += dir;
            }
            if (initPos < 0 || initPos >= len - 1) {
              if (initPos === len - 1) {
                return percents[initPos];
              }
              flag = false;
            }
          }
          return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
        }
        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
          var t1 = getDistancePerc(percent, bezierData);
          var u1 = 1 - t1;
          var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
          var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
          return [ptX, ptY];
        }
        var bezierSegmentPoints = createTypedArray("float32", 8);
        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
          if (startPerc < 0) {
            startPerc = 0;
          } else if (startPerc > 1) {
            startPerc = 1;
          }
          var t0 = getDistancePerc(startPerc, bezierData);
          endPerc = endPerc > 1 ? 1 : endPerc;
          var t1 = getDistancePerc(endPerc, bezierData);
          var i4;
          var len = pt1.length;
          var u0 = 1 - t0;
          var u1 = 1 - t1;
          var u0u0u0 = u0 * u0 * u0;
          var t0u0u0_3 = t0 * u0 * u0 * 3;
          var t0t0u0_3 = t0 * t0 * u0 * 3;
          var t0t0t0 = t0 * t0 * t0;
          var u0u0u1 = u0 * u0 * u1;
          var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
          var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
          var t0t0t1 = t0 * t0 * t1;
          var u0u1u1 = u0 * u1 * u1;
          var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
          var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
          var t0t1t1 = t0 * t1 * t1;
          var u1u1u1 = u1 * u1 * u1;
          var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
          var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
          var t1t1t1 = t1 * t1 * t1;
          for (i4 = 0; i4 < len; i4 += 1) {
            bezierSegmentPoints[i4 * 4] = math.round((u0u0u0 * pt1[i4] + t0u0u0_3 * pt3[i4] + t0t0u0_3 * pt4[i4] + t0t0t0 * pt2[i4]) * 1e3) / 1e3;
            bezierSegmentPoints[i4 * 4 + 1] = math.round((u0u0u1 * pt1[i4] + t0u0u1_3 * pt3[i4] + t0t0u1_3 * pt4[i4] + t0t0t1 * pt2[i4]) * 1e3) / 1e3;
            bezierSegmentPoints[i4 * 4 + 2] = math.round((u0u1u1 * pt1[i4] + t0u1u1_3 * pt3[i4] + t0t1u1_3 * pt4[i4] + t0t1t1 * pt2[i4]) * 1e3) / 1e3;
            bezierSegmentPoints[i4 * 4 + 3] = math.round((u1u1u1 * pt1[i4] + t1u1u1_3 * pt3[i4] + t1t1u1_3 * pt4[i4] + t1t1t1 * pt2[i4]) * 1e3) / 1e3;
          }
          return bezierSegmentPoints;
        }
        return {
          getSegmentsLength,
          getNewSegment,
          getPointInSegment,
          buildBezierData,
          pointOnLine2D,
          pointOnLine3D
        };
      }
      var bez = bezFunction();
      var initFrame = initialDefaultFrame;
      var mathAbs = Math.abs;
      function interpolateValue(frameNum, caching) {
        var offsetTime = this.offsetTime;
        var newValue;
        if (this.propType === "multidimensional") {
          newValue = createTypedArray("float32", this.pv.length);
        }
        var iterationIndex = caching.lastIndex;
        var i4 = iterationIndex;
        var len = this.keyframes.length - 1;
        var flag = true;
        var keyData;
        var nextKeyData;
        var keyframeMetadata;
        while (flag) {
          keyData = this.keyframes[i4];
          nextKeyData = this.keyframes[i4 + 1];
          if (i4 === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
            if (keyData.h) {
              keyData = nextKeyData;
            }
            iterationIndex = 0;
            break;
          }
          if (nextKeyData.t - offsetTime > frameNum) {
            iterationIndex = i4;
            break;
          }
          if (i4 < len - 1) {
            i4 += 1;
          } else {
            iterationIndex = 0;
            flag = false;
          }
        }
        keyframeMetadata = this.keyframesMetadata[i4] || {};
        var k2;
        var kLen;
        var perc;
        var jLen;
        var j2;
        var fnc;
        var nextKeyTime = nextKeyData.t - offsetTime;
        var keyTime = keyData.t - offsetTime;
        var endValue;
        if (keyData.to) {
          if (!keyframeMetadata.bezierData) {
            keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
          }
          var bezierData = keyframeMetadata.bezierData;
          if (frameNum >= nextKeyTime || frameNum < keyTime) {
            var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
            kLen = bezierData.points[ind].point.length;
            for (k2 = 0; k2 < kLen; k2 += 1) {
              newValue[k2] = bezierData.points[ind].point[k2];
            }
          } else {
            if (keyframeMetadata.__fnct) {
              fnc = keyframeMetadata.__fnct;
            } else {
              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
              keyframeMetadata.__fnct = fnc;
            }
            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
            var distanceInLine = bezierData.segmentLength * perc;
            var segmentPerc;
            var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i4 ? caching._lastAddedLength : 0;
            j2 = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i4 ? caching._lastPoint : 0;
            flag = true;
            jLen = bezierData.points.length;
            while (flag) {
              addedLength += bezierData.points[j2].partialLength;
              if (distanceInLine === 0 || perc === 0 || j2 === bezierData.points.length - 1) {
                kLen = bezierData.points[j2].point.length;
                for (k2 = 0; k2 < kLen; k2 += 1) {
                  newValue[k2] = bezierData.points[j2].point[k2];
                }
                break;
              } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j2 + 1].partialLength) {
                segmentPerc = (distanceInLine - addedLength) / bezierData.points[j2 + 1].partialLength;
                kLen = bezierData.points[j2].point.length;
                for (k2 = 0; k2 < kLen; k2 += 1) {
                  newValue[k2] = bezierData.points[j2].point[k2] + (bezierData.points[j2 + 1].point[k2] - bezierData.points[j2].point[k2]) * segmentPerc;
                }
                break;
              }
              if (j2 < jLen - 1) {
                j2 += 1;
              } else {
                flag = false;
              }
            }
            caching._lastPoint = j2;
            caching._lastAddedLength = addedLength - bezierData.points[j2].partialLength;
            caching._lastKeyframeIndex = i4;
          }
        } else {
          var outX;
          var outY;
          var inX;
          var inY;
          var keyValue;
          len = keyData.s.length;
          endValue = nextKeyData.s || keyData.e;
          if (this.sh && keyData.h !== 1) {
            if (frameNum >= nextKeyTime) {
              newValue[0] = endValue[0];
              newValue[1] = endValue[1];
              newValue[2] = endValue[2];
            } else if (frameNum <= keyTime) {
              newValue[0] = keyData.s[0];
              newValue[1] = keyData.s[1];
              newValue[2] = keyData.s[2];
            } else {
              var quatStart = createQuaternion(keyData.s);
              var quatEnd = createQuaternion(endValue);
              var time2 = (frameNum - keyTime) / (nextKeyTime - keyTime);
              quaternionToEuler(newValue, slerp(quatStart, quatEnd, time2));
            }
          } else {
            for (i4 = 0; i4 < len; i4 += 1) {
              if (keyData.h !== 1) {
                if (frameNum >= nextKeyTime) {
                  perc = 1;
                } else if (frameNum < keyTime) {
                  perc = 0;
                } else {
                  if (keyData.o.x.constructor === Array) {
                    if (!keyframeMetadata.__fnct) {
                      keyframeMetadata.__fnct = [];
                    }
                    if (!keyframeMetadata.__fnct[i4]) {
                      outX = keyData.o.x[i4] === void 0 ? keyData.o.x[0] : keyData.o.x[i4];
                      outY = keyData.o.y[i4] === void 0 ? keyData.o.y[0] : keyData.o.y[i4];
                      inX = keyData.i.x[i4] === void 0 ? keyData.i.x[0] : keyData.i.x[i4];
                      inY = keyData.i.y[i4] === void 0 ? keyData.i.y[0] : keyData.i.y[i4];
                      fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                      keyframeMetadata.__fnct[i4] = fnc;
                    } else {
                      fnc = keyframeMetadata.__fnct[i4];
                    }
                  } else if (!keyframeMetadata.__fnct) {
                    outX = keyData.o.x;
                    outY = keyData.o.y;
                    inX = keyData.i.x;
                    inY = keyData.i.y;
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyData.keyframeMetadata = fnc;
                  } else {
                    fnc = keyframeMetadata.__fnct;
                  }
                  perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                }
              }
              endValue = nextKeyData.s || keyData.e;
              keyValue = keyData.h === 1 ? keyData.s[i4] : keyData.s[i4] + (endValue[i4] - keyData.s[i4]) * perc;
              if (this.propType === "multidimensional") {
                newValue[i4] = keyValue;
              } else {
                newValue = keyValue;
              }
            }
          }
        }
        caching.lastIndex = iterationIndex;
        return newValue;
      }
      function slerp(a3, b2, t5) {
        var out = [];
        var ax = a3[0];
        var ay = a3[1];
        var az = a3[2];
        var aw = a3[3];
        var bx = b2[0];
        var by = b2[1];
        var bz = b2[2];
        var bw = b2[3];
        var omega;
        var cosom;
        var sinom;
        var scale0;
        var scale1;
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }
        if (1 - cosom > 1e-6) {
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t5) * omega) / sinom;
          scale1 = Math.sin(t5 * omega) / sinom;
        } else {
          scale0 = 1 - t5;
          scale1 = t5;
        }
        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;
        return out;
      }
      function quaternionToEuler(out, quat) {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];
        var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
        var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
        var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
        out[0] = heading / degToRads;
        out[1] = attitude / degToRads;
        out[2] = bank / degToRads;
      }
      function createQuaternion(values) {
        var heading = values[0] * degToRads;
        var attitude = values[1] * degToRads;
        var bank = values[2] * degToRads;
        var c1 = Math.cos(heading / 2);
        var c2 = Math.cos(attitude / 2);
        var c3 = Math.cos(bank / 2);
        var s1 = Math.sin(heading / 2);
        var s2 = Math.sin(attitude / 2);
        var s3 = Math.sin(bank / 2);
        var w2 = c1 * c2 * c3 - s1 * s2 * s3;
        var x2 = s1 * s2 * c3 + c1 * c2 * s3;
        var y2 = s1 * c2 * c3 + c1 * s2 * s3;
        var z2 = c1 * s2 * c3 - s1 * c2 * s3;
        return [x2, y2, z2, w2];
      }
      function getValueAtCurrentTime() {
        var frameNum = this.comp.renderedFrame - this.offsetTime;
        var initTime = this.keyframes[0].t - this.offsetTime;
        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
          if (this._caching.lastFrame >= frameNum) {
            this._caching._lastKeyframeIndex = -1;
            this._caching.lastIndex = 0;
          }
          var renderResult = this.interpolateValue(frameNum, this._caching);
          this.pv = renderResult;
        }
        this._caching.lastFrame = frameNum;
        return this.pv;
      }
      function setVValue(val2) {
        var multipliedValue;
        if (this.propType === "unidimensional") {
          multipliedValue = val2 * this.mult;
          if (mathAbs(this.v - multipliedValue) > 1e-5) {
            this.v = multipliedValue;
            this._mdf = true;
          }
        } else {
          var i4 = 0;
          var len = this.v.length;
          while (i4 < len) {
            multipliedValue = val2[i4] * this.mult;
            if (mathAbs(this.v[i4] - multipliedValue) > 1e-5) {
              this.v[i4] = multipliedValue;
              this._mdf = true;
            }
            i4 += 1;
          }
        }
      }
      function processEffectsSequence() {
        if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
          return;
        }
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = true;
        this._mdf = this._isFirstFrame;
        var i4;
        var len = this.effectsSequence.length;
        var finalValue = this.kf ? this.pv : this.data.k;
        for (i4 = 0; i4 < len; i4 += 1) {
          finalValue = this.effectsSequence[i4](finalValue);
        }
        this.setVValue(finalValue);
        this._isFirstFrame = false;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      }
      function addEffect(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.container.addDynamicProperty(this);
      }
      function ValueProperty(elem2, data2, mult, container) {
        this.propType = "unidimensional";
        this.mult = mult || 1;
        this.data = data2;
        this.v = mult ? data2.k * mult : data2.k;
        this.pv = data2.k;
        this._mdf = false;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.k = false;
        this.kf = false;
        this.vel = 0;
        this.effectsSequence = [];
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }
      function MultiDimensionalProperty(elem2, data2, mult, container) {
        this.propType = "multidimensional";
        this.mult = mult || 1;
        this.data = data2;
        this._mdf = false;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.k = false;
        this.kf = false;
        this.frameId = -1;
        var i4;
        var len = data2.k.length;
        this.v = createTypedArray("float32", len);
        this.pv = createTypedArray("float32", len);
        this.vel = createTypedArray("float32", len);
        for (i4 = 0; i4 < len; i4 += 1) {
          this.v[i4] = data2.k[i4] * this.mult;
          this.pv[i4] = data2.k[i4];
        }
        this._isFirstFrame = true;
        this.effectsSequence = [];
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }
      function KeyframedValueProperty(elem2, data2, mult, container) {
        this.propType = "unidimensional";
        this.keyframes = data2.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem2.data.st;
        this.frameId = -1;
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: 0,
          _lastKeyframeIndex: -1
        };
        this.k = true;
        this.kf = true;
        this.data = data2;
        this.mult = mult || 1;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.v = initFrame;
        this.pv = initFrame;
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.addEffect = addEffect;
      }
      function KeyframedMultidimensionalProperty(elem2, data2, mult, container) {
        this.propType = "multidimensional";
        var i4;
        var len = data2.k.length;
        var s2;
        var e5;
        var to;
        var ti;
        for (i4 = 0; i4 < len - 1; i4 += 1) {
          if (data2.k[i4].to && data2.k[i4].s && data2.k[i4 + 1] && data2.k[i4 + 1].s) {
            s2 = data2.k[i4].s;
            e5 = data2.k[i4 + 1].s;
            to = data2.k[i4].to;
            ti = data2.k[i4].ti;
            if (s2.length === 2 && !(s2[0] === e5[0] && s2[1] === e5[1]) && bez.pointOnLine2D(s2[0], s2[1], e5[0], e5[1], s2[0] + to[0], s2[1] + to[1]) && bez.pointOnLine2D(s2[0], s2[1], e5[0], e5[1], e5[0] + ti[0], e5[1] + ti[1]) || s2.length === 3 && !(s2[0] === e5[0] && s2[1] === e5[1] && s2[2] === e5[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e5[0], e5[1], e5[2], s2[0] + to[0], s2[1] + to[1], s2[2] + to[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e5[0], e5[1], e5[2], e5[0] + ti[0], e5[1] + ti[1], e5[2] + ti[2])) {
              data2.k[i4].to = null;
              data2.k[i4].ti = null;
            }
            if (s2[0] === e5[0] && s2[1] === e5[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
              if (s2.length === 2 || s2[2] === e5[2] && to[2] === 0 && ti[2] === 0) {
                data2.k[i4].to = null;
                data2.k[i4].ti = null;
              }
            }
          }
        }
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.data = data2;
        this.keyframes = data2.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem2.data.st;
        this.k = true;
        this.kf = true;
        this._isFirstFrame = true;
        this.mult = mult || 1;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.frameId = -1;
        var arrLen = data2.k[0].s.length;
        this.v = createTypedArray("float32", arrLen);
        this.pv = createTypedArray("float32", arrLen);
        for (i4 = 0; i4 < arrLen; i4 += 1) {
          this.v[i4] = initFrame;
          this.pv[i4] = initFrame;
        }
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: createTypedArray("float32", arrLen)
        };
        this.addEffect = addEffect;
      }
      var PropertyFactory = function() {
        function getProp(elem2, data2, type, mult, container) {
          if (data2.sid) {
            data2 = elem2.globalData.slotManager.getProp(data2);
          }
          var p2;
          if (!data2.k.length) {
            p2 = new ValueProperty(elem2, data2, mult, container);
          } else if (typeof data2.k[0] === "number") {
            p2 = new MultiDimensionalProperty(elem2, data2, mult, container);
          } else {
            switch (type) {
              case 0:
                p2 = new KeyframedValueProperty(elem2, data2, mult, container);
                break;
              case 1:
                p2 = new KeyframedMultidimensionalProperty(elem2, data2, mult, container);
                break;
              default:
                break;
            }
          }
          if (p2.effectsSequence.length) {
            container.addDynamicProperty(p2);
          }
          return p2;
        }
        var ob2 = {
          getProp
        };
        return ob2;
      }();
      function DynamicPropertyContainer() {
      }
      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
            this.container.addDynamicProperty(this);
            this._isAnimated = true;
          }
        },
        iterateDynamicProperties: function iterateDynamicProperties() {
          this._mdf = false;
          var i4;
          var len = this.dynamicProperties.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            this.dynamicProperties[i4].getValue();
            if (this.dynamicProperties[i4]._mdf) {
              this._mdf = true;
            }
          }
        },
        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
          this.container = container;
          this.dynamicProperties = [];
          this._mdf = false;
          this._isAnimated = false;
        }
      };
      var pointPool = function() {
        function create() {
          return createTypedArray("float32", 2);
        }
        return poolFactory(8, create);
      }();
      function ShapePath() {
        this.c = false;
        this._length = 0;
        this._maxLength = 8;
        this.v = createSizedArray(this._maxLength);
        this.o = createSizedArray(this._maxLength);
        this.i = createSizedArray(this._maxLength);
      }
      ShapePath.prototype.setPathData = function(closed, len) {
        this.c = closed;
        this.setLength(len);
        var i4 = 0;
        while (i4 < len) {
          this.v[i4] = pointPool.newElement();
          this.o[i4] = pointPool.newElement();
          this.i[i4] = pointPool.newElement();
          i4 += 1;
        }
      };
      ShapePath.prototype.setLength = function(len) {
        while (this._maxLength < len) {
          this.doubleArrayLength();
        }
        this._length = len;
      };
      ShapePath.prototype.doubleArrayLength = function() {
        this.v = this.v.concat(createSizedArray(this._maxLength));
        this.i = this.i.concat(createSizedArray(this._maxLength));
        this.o = this.o.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
      };
      ShapePath.prototype.setXYAt = function(x2, y2, type, pos, replace) {
        var arr;
        this._length = Math.max(this._length, pos + 1);
        if (this._length >= this._maxLength) {
          this.doubleArrayLength();
        }
        switch (type) {
          case "v":
            arr = this.v;
            break;
          case "i":
            arr = this.i;
            break;
          case "o":
            arr = this.o;
            break;
          default:
            arr = [];
            break;
        }
        if (!arr[pos] || arr[pos] && !replace) {
          arr[pos] = pointPool.newElement();
        }
        arr[pos][0] = x2;
        arr[pos][1] = y2;
      };
      ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
        this.setXYAt(vX, vY, "v", pos, replace);
        this.setXYAt(oX, oY, "o", pos, replace);
        this.setXYAt(iX, iY, "i", pos, replace);
      };
      ShapePath.prototype.reverse = function() {
        var newPath = new ShapePath();
        newPath.setPathData(this.c, this._length);
        var vertices = this.v;
        var outPoints = this.o;
        var inPoints = this.i;
        var init = 0;
        if (this.c) {
          newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
          init = 1;
        }
        var cnt = this._length - 1;
        var len = this._length;
        var i4;
        for (i4 = init; i4 < len; i4 += 1) {
          newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i4, false);
          cnt -= 1;
        }
        return newPath;
      };
      ShapePath.prototype.length = function() {
        return this._length;
      };
      var shapePool = function() {
        function create() {
          return new ShapePath();
        }
        function release(shapePath) {
          var len = shapePath._length;
          var i4;
          for (i4 = 0; i4 < len; i4 += 1) {
            pointPool.release(shapePath.v[i4]);
            pointPool.release(shapePath.i[i4]);
            pointPool.release(shapePath.o[i4]);
            shapePath.v[i4] = null;
            shapePath.i[i4] = null;
            shapePath.o[i4] = null;
          }
          shapePath._length = 0;
          shapePath.c = false;
        }
        function clone(shape) {
          var cloned = factory.newElement();
          var i4;
          var len = shape._length === void 0 ? shape.v.length : shape._length;
          cloned.setLength(len);
          cloned.c = shape.c;
          for (i4 = 0; i4 < len; i4 += 1) {
            cloned.setTripleAt(shape.v[i4][0], shape.v[i4][1], shape.o[i4][0], shape.o[i4][1], shape.i[i4][0], shape.i[i4][1], i4);
          }
          return cloned;
        }
        var factory = poolFactory(4, create, release);
        factory.clone = clone;
        return factory;
      }();
      function ShapeCollection() {
        this._length = 0;
        this._maxLength = 4;
        this.shapes = createSizedArray(this._maxLength);
      }
      ShapeCollection.prototype.addShape = function(shapeData) {
        if (this._length === this._maxLength) {
          this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
          this._maxLength *= 2;
        }
        this.shapes[this._length] = shapeData;
        this._length += 1;
      };
      ShapeCollection.prototype.releaseShapes = function() {
        var i4;
        for (i4 = 0; i4 < this._length; i4 += 1) {
          shapePool.release(this.shapes[i4]);
        }
        this._length = 0;
      };
      var shapeCollectionPool = function() {
        var ob2 = {
          newShapeCollection,
          release
        };
        var _length = 0;
        var _maxLength = 4;
        var pool = createSizedArray(_maxLength);
        function newShapeCollection() {
          var shapeCollection;
          if (_length) {
            _length -= 1;
            shapeCollection = pool[_length];
          } else {
            shapeCollection = new ShapeCollection();
          }
          return shapeCollection;
        }
        function release(shapeCollection) {
          var i4;
          var len = shapeCollection._length;
          for (i4 = 0; i4 < len; i4 += 1) {
            shapePool.release(shapeCollection.shapes[i4]);
          }
          shapeCollection._length = 0;
          if (_length === _maxLength) {
            pool = pooling["double"](pool);
            _maxLength *= 2;
          }
          pool[_length] = shapeCollection;
          _length += 1;
        }
        return ob2;
      }();
      var ShapePropertyFactory = function() {
        var initFrame2 = -999999;
        function interpolateShape(frameNum, previousValue, caching) {
          var iterationIndex = caching.lastIndex;
          var keyPropS;
          var keyPropE;
          var isHold;
          var j2;
          var k2;
          var jLen;
          var kLen;
          var perc;
          var vertexValue;
          var kf = this.keyframes;
          if (frameNum < kf[0].t - this.offsetTime) {
            keyPropS = kf[0].s[0];
            isHold = true;
            iterationIndex = 0;
          } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
            keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
            isHold = true;
          } else {
            var i4 = iterationIndex;
            var len = kf.length - 1;
            var flag = true;
            var keyData;
            var nextKeyData;
            var keyframeMetadata;
            while (flag) {
              keyData = kf[i4];
              nextKeyData = kf[i4 + 1];
              if (nextKeyData.t - this.offsetTime > frameNum) {
                break;
              }
              if (i4 < len - 1) {
                i4 += 1;
              } else {
                flag = false;
              }
            }
            keyframeMetadata = this.keyframesMetadata[i4] || {};
            isHold = keyData.h === 1;
            iterationIndex = i4;
            if (!isHold) {
              if (frameNum >= nextKeyData.t - this.offsetTime) {
                perc = 1;
              } else if (frameNum < keyData.t - this.offsetTime) {
                perc = 0;
              } else {
                var fnc;
                if (keyframeMetadata.__fnct) {
                  fnc = keyframeMetadata.__fnct;
                } else {
                  fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                  keyframeMetadata.__fnct = fnc;
                }
                perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
              }
              keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
            }
            keyPropS = keyData.s[0];
          }
          jLen = previousValue._length;
          kLen = keyPropS.i[0].length;
          caching.lastIndex = iterationIndex;
          for (j2 = 0; j2 < jLen; j2 += 1) {
            for (k2 = 0; k2 < kLen; k2 += 1) {
              vertexValue = isHold ? keyPropS.i[j2][k2] : keyPropS.i[j2][k2] + (keyPropE.i[j2][k2] - keyPropS.i[j2][k2]) * perc;
              previousValue.i[j2][k2] = vertexValue;
              vertexValue = isHold ? keyPropS.o[j2][k2] : keyPropS.o[j2][k2] + (keyPropE.o[j2][k2] - keyPropS.o[j2][k2]) * perc;
              previousValue.o[j2][k2] = vertexValue;
              vertexValue = isHold ? keyPropS.v[j2][k2] : keyPropS.v[j2][k2] + (keyPropE.v[j2][k2] - keyPropS.v[j2][k2]) * perc;
              previousValue.v[j2][k2] = vertexValue;
            }
          }
        }
        function interpolateShapeCurrentTime() {
          var frameNum = this.comp.renderedFrame - this.offsetTime;
          var initTime = this.keyframes[0].t - this.offsetTime;
          var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
          var lastFrame = this._caching.lastFrame;
          if (!(lastFrame !== initFrame2 && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
            this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
            this.interpolateShape(frameNum, this.pv, this._caching);
          }
          this._caching.lastFrame = frameNum;
          return this.pv;
        }
        function resetShape() {
          this.paths = this.localShapeCollection;
        }
        function shapesEqual(shape1, shape2) {
          if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
            return false;
          }
          var i4;
          var len = shape1._length;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (shape1.v[i4][0] !== shape2.v[i4][0] || shape1.v[i4][1] !== shape2.v[i4][1] || shape1.o[i4][0] !== shape2.o[i4][0] || shape1.o[i4][1] !== shape2.o[i4][1] || shape1.i[i4][0] !== shape2.i[i4][0] || shape1.i[i4][1] !== shape2.i[i4][1]) {
              return false;
            }
          }
          return true;
        }
        function setVValue2(newPath) {
          if (!shapesEqual(this.v, newPath)) {
            this.v = shapePool.clone(newPath);
            this.localShapeCollection.releaseShapes();
            this.localShapeCollection.addShape(this.v);
            this._mdf = true;
            this.paths = this.localShapeCollection;
          }
        }
        function processEffectsSequence2() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          if (!this.effectsSequence.length) {
            this._mdf = false;
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = true;
          this._mdf = false;
          var finalValue;
          if (this.kf) {
            finalValue = this.pv;
          } else if (this.data.ks) {
            finalValue = this.data.ks.k;
          } else {
            finalValue = this.data.pt.k;
          }
          var i4;
          var len = this.effectsSequence.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            finalValue = this.effectsSequence[i4](finalValue);
          }
          this.setVValue(finalValue);
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        }
        function ShapeProperty(elem2, data2, type) {
          this.propType = "shape";
          this.comp = elem2.comp;
          this.container = elem2;
          this.elem = elem2;
          this.data = data2;
          this.k = false;
          this.kf = false;
          this._mdf = false;
          var pathData = type === 3 ? data2.pt.k : data2.ks.k;
          this.v = shapePool.clone(pathData);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.reset = resetShape;
          this.effectsSequence = [];
        }
        function addEffect2(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.container.addDynamicProperty(this);
        }
        ShapeProperty.prototype.interpolateShape = interpolateShape;
        ShapeProperty.prototype.getValue = processEffectsSequence2;
        ShapeProperty.prototype.setVValue = setVValue2;
        ShapeProperty.prototype.addEffect = addEffect2;
        function KeyframedShapeProperty(elem2, data2, type) {
          this.propType = "shape";
          this.comp = elem2.comp;
          this.elem = elem2;
          this.container = elem2;
          this.offsetTime = elem2.data.st;
          this.keyframes = type === 3 ? data2.pt.k : data2.ks.k;
          this.keyframesMetadata = [];
          this.k = true;
          this.kf = true;
          var len = this.keyframes[0].s[0].i.length;
          this.v = shapePool.newElement();
          this.v.setPathData(this.keyframes[0].s[0].c, len);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.lastFrame = initFrame2;
          this.reset = resetShape;
          this._caching = {
            lastFrame: initFrame2,
            lastIndex: 0
          };
          this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
        }
        KeyframedShapeProperty.prototype.getValue = processEffectsSequence2;
        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
        KeyframedShapeProperty.prototype.setVValue = setVValue2;
        KeyframedShapeProperty.prototype.addEffect = addEffect2;
        var EllShapeProperty = function() {
          var cPoint = roundCorner;
          function EllShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 4);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.localShapeCollection.addShape(this.v);
            this.d = data2.d;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.frameId = -1;
            this.initDynamicPropertyContainer(elem2);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertEllToPath();
            }
          }
          EllShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertEllToPath();
              }
            },
            convertEllToPath: function convertEllToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var s0 = this.s.v[0] / 2;
              var s1 = this.s.v[1] / 2;
              var _cw = this.d !== 3;
              var _v = this.v;
              _v.v[0][0] = p0;
              _v.v[0][1] = p1 - s1;
              _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.v[1][1] = p1;
              _v.v[2][0] = p0;
              _v.v[2][1] = p1 + s1;
              _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.v[3][1] = p1;
              _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.i[0][1] = p1 - s1;
              _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.i[1][1] = p1 - s1 * cPoint;
              _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.i[2][1] = p1 + s1;
              _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.i[3][1] = p1 + s1 * cPoint;
              _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.o[0][1] = p1 - s1;
              _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.o[1][1] = p1 + s1 * cPoint;
              _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.o[2][1] = p1 + s1;
              _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.o[3][1] = p1 - s1 * cPoint;
            }
          };
          extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
          return EllShapePropertyFactory;
        }();
        var StarShapeProperty = function() {
          function StarShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 0);
            this.elem = elem2;
            this.comp = elem2.comp;
            this.data = data2;
            this.frameId = -1;
            this.d = data2.d;
            this.initDynamicPropertyContainer(elem2);
            if (data2.sy === 1) {
              this.ir = PropertyFactory.getProp(elem2, data2.ir, 0, 0, this);
              this.is = PropertyFactory.getProp(elem2, data2.is, 0, 0.01, this);
              this.convertToPath = this.convertStarToPath;
            } else {
              this.convertToPath = this.convertPolygonToPath;
            }
            this.pt = PropertyFactory.getProp(elem2, data2.pt, 0, 0, this);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.r = PropertyFactory.getProp(elem2, data2.r, 0, degToRads, this);
            this.or = PropertyFactory.getProp(elem2, data2.or, 0, 0, this);
            this.os = PropertyFactory.getProp(elem2, data2.os, 0, 0.01, this);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertToPath();
            }
          }
          StarShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertToPath();
              }
            },
            convertStarToPath: function convertStarToPath() {
              var numPts = Math.floor(this.pt.v) * 2;
              var angle = Math.PI * 2 / numPts;
              var longFlag = true;
              var longRad = this.or.v;
              var shortRad = this.ir.v;
              var longRound = this.os.v;
              var shortRound = this.is.v;
              var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
              var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
              var i4;
              var rad;
              var roundness;
              var perimSegment;
              var currentAng = -Math.PI / 2;
              currentAng += this.r.v;
              var dir = this.data.d === 3 ? -1 : 1;
              this.v._length = 0;
              for (i4 = 0; i4 < numPts; i4 += 1) {
                rad = longFlag ? longRad : shortRad;
                roundness = longFlag ? longRound : shortRound;
                perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                var x2 = rad * Math.cos(currentAng);
                var y2 = rad * Math.sin(currentAng);
                var ox = x2 === 0 && y2 === 0 ? 0 : y2 / Math.sqrt(x2 * x2 + y2 * y2);
                var oy = x2 === 0 && y2 === 0 ? 0 : -x2 / Math.sqrt(x2 * x2 + y2 * y2);
                x2 += +this.p.v[0];
                y2 += +this.p.v[1];
                this.v.setTripleAt(x2, y2, x2 - ox * perimSegment * roundness * dir, y2 - oy * perimSegment * roundness * dir, x2 + ox * perimSegment * roundness * dir, y2 + oy * perimSegment * roundness * dir, i4, true);
                longFlag = !longFlag;
                currentAng += angle * dir;
              }
            },
            convertPolygonToPath: function convertPolygonToPath() {
              var numPts = Math.floor(this.pt.v);
              var angle = Math.PI * 2 / numPts;
              var rad = this.or.v;
              var roundness = this.os.v;
              var perimSegment = 2 * Math.PI * rad / (numPts * 4);
              var i4;
              var currentAng = -Math.PI * 0.5;
              var dir = this.data.d === 3 ? -1 : 1;
              currentAng += this.r.v;
              this.v._length = 0;
              for (i4 = 0; i4 < numPts; i4 += 1) {
                var x2 = rad * Math.cos(currentAng);
                var y2 = rad * Math.sin(currentAng);
                var ox = x2 === 0 && y2 === 0 ? 0 : y2 / Math.sqrt(x2 * x2 + y2 * y2);
                var oy = x2 === 0 && y2 === 0 ? 0 : -x2 / Math.sqrt(x2 * x2 + y2 * y2);
                x2 += +this.p.v[0];
                y2 += +this.p.v[1];
                this.v.setTripleAt(x2, y2, x2 - ox * perimSegment * roundness * dir, y2 - oy * perimSegment * roundness * dir, x2 + ox * perimSegment * roundness * dir, y2 + oy * perimSegment * roundness * dir, i4, true);
                currentAng += angle * dir;
              }
              this.paths.length = 0;
              this.paths[0] = this.v;
            }
          };
          extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
          return StarShapePropertyFactory;
        }();
        var RectShapeProperty = function() {
          function RectShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.c = true;
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.frameId = -1;
            this.d = data2.d;
            this.initDynamicPropertyContainer(elem2);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
            this.r = PropertyFactory.getProp(elem2, data2.r, 0, 0, this);
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertRectToPath();
            }
          }
          RectShapePropertyFactory.prototype = {
            convertRectToPath: function convertRectToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var v0 = this.s.v[0] / 2;
              var v1 = this.s.v[1] / 2;
              var round = bmMin(v0, v1, this.r.v);
              var cPoint = round * (1 - roundCorner);
              this.v._length = 0;
              if (this.d === 2 || this.d === 1) {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                }
              } else {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                }
              }
            },
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertRectToPath();
              }
            },
            reset: resetShape
          };
          extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
          return RectShapePropertyFactory;
        }();
        function getShapeProp(elem2, data2, type) {
          var prop;
          if (type === 3 || type === 4) {
            var dataProp = type === 3 ? data2.pt : data2.ks;
            var keys = dataProp.k;
            if (keys.length) {
              prop = new KeyframedShapeProperty(elem2, data2, type);
            } else {
              prop = new ShapeProperty(elem2, data2, type);
            }
          } else if (type === 5) {
            prop = new RectShapeProperty(elem2, data2);
          } else if (type === 6) {
            prop = new EllShapeProperty(elem2, data2);
          } else if (type === 7) {
            prop = new StarShapeProperty(elem2, data2);
          }
          if (prop.k) {
            elem2.addDynamicProperty(prop);
          }
          return prop;
        }
        function getConstructorFunction() {
          return ShapeProperty;
        }
        function getKeyframedConstructorFunction() {
          return KeyframedShapeProperty;
        }
        var ob2 = {};
        ob2.getShapeProp = getShapeProp;
        ob2.getConstructorFunction = getConstructorFunction;
        ob2.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
        return ob2;
      }();
      var Matrix = function() {
        var _cos = Math.cos;
        var _sin = Math.sin;
        var _tan = Math.tan;
        var _rnd = Math.round;
        function reset() {
          this.props[0] = 1;
          this.props[1] = 0;
          this.props[2] = 0;
          this.props[3] = 0;
          this.props[4] = 0;
          this.props[5] = 1;
          this.props[6] = 0;
          this.props[7] = 0;
          this.props[8] = 0;
          this.props[9] = 0;
          this.props[10] = 1;
          this.props[11] = 0;
          this.props[12] = 0;
          this.props[13] = 0;
          this.props[14] = 0;
          this.props[15] = 1;
          return this;
        }
        function rotate(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function rotateX(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
        }
        function rotateY(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
        }
        function rotateZ(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function shear(sx, sy) {
          return this._t(1, sy, sx, 1, 0, 0);
        }
        function skew(ax, ay) {
          return this.shear(_tan(ax), _tan(ay));
        }
        function skewFromAxis(ax, angle) {
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function scale2(sx, sy, sz) {
          if (!sz && sz !== 0) {
            sz = 1;
          }
          if (sx === 1 && sy === 1 && sz === 1) {
            return this;
          }
          return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
        }
        function setTransform(a3, b2, c2, d2, e5, f3, g2, h2, i4, j2, k2, l3, m3, n3, o4, p2) {
          this.props[0] = a3;
          this.props[1] = b2;
          this.props[2] = c2;
          this.props[3] = d2;
          this.props[4] = e5;
          this.props[5] = f3;
          this.props[6] = g2;
          this.props[7] = h2;
          this.props[8] = i4;
          this.props[9] = j2;
          this.props[10] = k2;
          this.props[11] = l3;
          this.props[12] = m3;
          this.props[13] = n3;
          this.props[14] = o4;
          this.props[15] = p2;
          return this;
        }
        function translate(tx, ty, tz) {
          tz = tz || 0;
          if (tx !== 0 || ty !== 0 || tz !== 0) {
            return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
          }
          return this;
        }
        function transform2(a22, b2, c2, d2, e22, f22, g2, h2, i22, j2, k2, l22, m22, n22, o22, p2) {
          var _p = this.props;
          if (a22 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e22 === 0 && f22 === 1 && g2 === 0 && h2 === 0 && i22 === 0 && j2 === 0 && k2 === 1 && l22 === 0) {
            _p[12] = _p[12] * a22 + _p[15] * m22;
            _p[13] = _p[13] * f22 + _p[15] * n22;
            _p[14] = _p[14] * k2 + _p[15] * o22;
            _p[15] *= p2;
            this._identityCalculated = false;
            return this;
          }
          var a1 = _p[0];
          var b1 = _p[1];
          var c1 = _p[2];
          var d1 = _p[3];
          var e1 = _p[4];
          var f1 = _p[5];
          var g1 = _p[6];
          var h1 = _p[7];
          var i1 = _p[8];
          var j1 = _p[9];
          var k1 = _p[10];
          var l1 = _p[11];
          var m1 = _p[12];
          var n1 = _p[13];
          var o1 = _p[14];
          var p1 = _p[15];
          _p[0] = a1 * a22 + b1 * e22 + c1 * i22 + d1 * m22;
          _p[1] = a1 * b2 + b1 * f22 + c1 * j2 + d1 * n22;
          _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o22;
          _p[3] = a1 * d2 + b1 * h2 + c1 * l22 + d1 * p2;
          _p[4] = e1 * a22 + f1 * e22 + g1 * i22 + h1 * m22;
          _p[5] = e1 * b2 + f1 * f22 + g1 * j2 + h1 * n22;
          _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o22;
          _p[7] = e1 * d2 + f1 * h2 + g1 * l22 + h1 * p2;
          _p[8] = i1 * a22 + j1 * e22 + k1 * i22 + l1 * m22;
          _p[9] = i1 * b2 + j1 * f22 + k1 * j2 + l1 * n22;
          _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o22;
          _p[11] = i1 * d2 + j1 * h2 + k1 * l22 + l1 * p2;
          _p[12] = m1 * a22 + n1 * e22 + o1 * i22 + p1 * m22;
          _p[13] = m1 * b2 + n1 * f22 + o1 * j2 + p1 * n22;
          _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o22;
          _p[15] = m1 * d2 + n1 * h2 + o1 * l22 + p1 * p2;
          this._identityCalculated = false;
          return this;
        }
        function multiply(matrix) {
          var matrixProps = matrix.props;
          return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
        }
        function isIdentity() {
          if (!this._identityCalculated) {
            this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
            this._identityCalculated = true;
          }
          return this._identity;
        }
        function equals(matr) {
          var i4 = 0;
          while (i4 < 16) {
            if (matr.props[i4] !== this.props[i4]) {
              return false;
            }
            i4 += 1;
          }
          return true;
        }
        function clone(matr) {
          var i4;
          for (i4 = 0; i4 < 16; i4 += 1) {
            matr.props[i4] = this.props[i4];
          }
          return matr;
        }
        function cloneFromProps(props) {
          var i4;
          for (i4 = 0; i4 < 16; i4 += 1) {
            this.props[i4] = props[i4];
          }
        }
        function applyToPoint(x2, y2, z2) {
          return {
            x: x2 * this.props[0] + y2 * this.props[4] + z2 * this.props[8] + this.props[12],
            y: x2 * this.props[1] + y2 * this.props[5] + z2 * this.props[9] + this.props[13],
            z: x2 * this.props[2] + y2 * this.props[6] + z2 * this.props[10] + this.props[14]
          };
        }
        function applyToX(x2, y2, z2) {
          return x2 * this.props[0] + y2 * this.props[4] + z2 * this.props[8] + this.props[12];
        }
        function applyToY(x2, y2, z2) {
          return x2 * this.props[1] + y2 * this.props[5] + z2 * this.props[9] + this.props[13];
        }
        function applyToZ(x2, y2, z2) {
          return x2 * this.props[2] + y2 * this.props[6] + z2 * this.props[10] + this.props[14];
        }
        function getInverseMatrix() {
          var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
          var a3 = this.props[5] / determinant;
          var b2 = -this.props[1] / determinant;
          var c2 = -this.props[4] / determinant;
          var d2 = this.props[0] / determinant;
          var e5 = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
          var f3 = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
          var inverseMatrix = new Matrix();
          inverseMatrix.props[0] = a3;
          inverseMatrix.props[1] = b2;
          inverseMatrix.props[4] = c2;
          inverseMatrix.props[5] = d2;
          inverseMatrix.props[12] = e5;
          inverseMatrix.props[13] = f3;
          return inverseMatrix;
        }
        function inversePoint(pt) {
          var inverseMatrix = this.getInverseMatrix();
          return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
        }
        function inversePoints(pts) {
          var i4;
          var len = pts.length;
          var retPts = [];
          for (i4 = 0; i4 < len; i4 += 1) {
            retPts[i4] = inversePoint(pts[i4]);
          }
          return retPts;
        }
        function applyToTriplePoints(pt1, pt2, pt3) {
          var arr = createTypedArray("float32", 6);
          if (this.isIdentity()) {
            arr[0] = pt1[0];
            arr[1] = pt1[1];
            arr[2] = pt2[0];
            arr[3] = pt2[1];
            arr[4] = pt3[0];
            arr[5] = pt3[1];
          } else {
            var p0 = this.props[0];
            var p1 = this.props[1];
            var p4 = this.props[4];
            var p5 = this.props[5];
            var p12 = this.props[12];
            var p13 = this.props[13];
            arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
            arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
            arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
            arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
            arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
            arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
          }
          return arr;
        }
        function applyToPointArray(x2, y2, z2) {
          var arr;
          if (this.isIdentity()) {
            arr = [x2, y2, z2];
          } else {
            arr = [x2 * this.props[0] + y2 * this.props[4] + z2 * this.props[8] + this.props[12], x2 * this.props[1] + y2 * this.props[5] + z2 * this.props[9] + this.props[13], x2 * this.props[2] + y2 * this.props[6] + z2 * this.props[10] + this.props[14]];
          }
          return arr;
        }
        function applyToPointStringified(x2, y2) {
          if (this.isIdentity()) {
            return x2 + "," + y2;
          }
          var _p = this.props;
          return Math.round((x2 * _p[0] + y2 * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x2 * _p[1] + y2 * _p[5] + _p[13]) * 100) / 100;
        }
        function toCSS() {
          var i4 = 0;
          var props = this.props;
          var cssValue = "matrix3d(";
          var v2 = 1e4;
          while (i4 < 16) {
            cssValue += _rnd(props[i4] * v2) / v2;
            cssValue += i4 === 15 ? ")" : ",";
            i4 += 1;
          }
          return cssValue;
        }
        function roundMatrixProperty(val2) {
          var v2 = 1e4;
          if (val2 < 1e-6 && val2 > 0 || val2 > -1e-6 && val2 < 0) {
            return _rnd(val2 * v2) / v2;
          }
          return val2;
        }
        function to2dCSS() {
          var props = this.props;
          var _a3 = roundMatrixProperty(props[0]);
          var _b = roundMatrixProperty(props[1]);
          var _c = roundMatrixProperty(props[4]);
          var _d = roundMatrixProperty(props[5]);
          var _e = roundMatrixProperty(props[12]);
          var _f = roundMatrixProperty(props[13]);
          return "matrix(" + _a3 + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
        }
        return function() {
          this.reset = reset;
          this.rotate = rotate;
          this.rotateX = rotateX;
          this.rotateY = rotateY;
          this.rotateZ = rotateZ;
          this.skew = skew;
          this.skewFromAxis = skewFromAxis;
          this.shear = shear;
          this.scale = scale2;
          this.setTransform = setTransform;
          this.translate = translate;
          this.transform = transform2;
          this.multiply = multiply;
          this.applyToPoint = applyToPoint;
          this.applyToX = applyToX;
          this.applyToY = applyToY;
          this.applyToZ = applyToZ;
          this.applyToPointArray = applyToPointArray;
          this.applyToTriplePoints = applyToTriplePoints;
          this.applyToPointStringified = applyToPointStringified;
          this.toCSS = toCSS;
          this.to2dCSS = to2dCSS;
          this.clone = clone;
          this.cloneFromProps = cloneFromProps;
          this.equals = equals;
          this.inversePoints = inversePoints;
          this.inversePoint = inversePoint;
          this.getInverseMatrix = getInverseMatrix;
          this._t = this.transform;
          this.isIdentity = isIdentity;
          this._identity = true;
          this._identityCalculated = false;
          this.props = createTypedArray("float32", 16);
          this.reset();
        };
      }();
      function _typeof$3(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$3 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$3 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$3(obj);
      }
      var lottie = {};
      var standalone = "__[STANDALONE]__";
      var animationData = "__[ANIMATIONDATA]__";
      var renderer = "";
      function setLocation(href) {
        setLocationHref(href);
      }
      function searchAnimations() {
        if (standalone === true) {
          animationManager.searchAnimations(animationData, standalone, renderer);
        } else {
          animationManager.searchAnimations();
        }
      }
      function setSubframeRendering(flag) {
        setSubframeEnabled(flag);
      }
      function setPrefix(prefix) {
        setIdPrefix(prefix);
      }
      function loadAnimation(params) {
        if (standalone === true) {
          params.animationData = JSON.parse(animationData);
        }
        return animationManager.loadAnimation(params);
      }
      function setQuality(value2) {
        if (typeof value2 === "string") {
          switch (value2) {
            case "high":
              setDefaultCurveSegments(200);
              break;
            default:
            case "medium":
              setDefaultCurveSegments(50);
              break;
            case "low":
              setDefaultCurveSegments(10);
              break;
          }
        } else if (!isNaN(value2) && value2 > 1) {
          setDefaultCurveSegments(value2);
        }
        if (getDefaultCurveSegments() >= 50) {
          roundValues(false);
        } else {
          roundValues(true);
        }
      }
      function inBrowser() {
        return typeof navigator !== "undefined";
      }
      function installPlugin(type, plugin) {
        if (type === "expressions") {
          setExpressionsPlugin(plugin);
        }
      }
      function getFactory(name2) {
        switch (name2) {
          case "propertyFactory":
            return PropertyFactory;
          case "shapePropertyFactory":
            return ShapePropertyFactory;
          case "matrix":
            return Matrix;
          default:
            return null;
        }
      }
      lottie.play = animationManager.play;
      lottie.pause = animationManager.pause;
      lottie.setLocationHref = setLocation;
      lottie.togglePause = animationManager.togglePause;
      lottie.setSpeed = animationManager.setSpeed;
      lottie.setDirection = animationManager.setDirection;
      lottie.stop = animationManager.stop;
      lottie.searchAnimations = searchAnimations;
      lottie.registerAnimation = animationManager.registerAnimation;
      lottie.loadAnimation = loadAnimation;
      lottie.setSubframeRendering = setSubframeRendering;
      lottie.resize = animationManager.resize;
      lottie.goToAndStop = animationManager.goToAndStop;
      lottie.destroy = animationManager.destroy;
      lottie.setQuality = setQuality;
      lottie.inBrowser = inBrowser;
      lottie.installPlugin = installPlugin;
      lottie.freeze = animationManager.freeze;
      lottie.unfreeze = animationManager.unfreeze;
      lottie.setVolume = animationManager.setVolume;
      lottie.mute = animationManager.mute;
      lottie.unmute = animationManager.unmute;
      lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
      lottie.useWebWorker = setWebWorker;
      lottie.setIDPrefix = setPrefix;
      lottie.__getFactory = getFactory;
      lottie.version = "5.12.2";
      function checkReady() {
        if (document.readyState === "complete") {
          clearInterval(readyStateCheckInterval);
          searchAnimations();
        }
      }
      function getQueryVariable(variable) {
        var vars = queryString.split("&");
        for (var i4 = 0; i4 < vars.length; i4 += 1) {
          var pair = vars[i4].split("=");
          if (decodeURIComponent(pair[0]) == variable) {
            return decodeURIComponent(pair[1]);
          }
        }
        return null;
      }
      var queryString = "";
      if (standalone) {
        var scripts = document.getElementsByTagName("script");
        var index = scripts.length - 1;
        var myScript = scripts[index] || {
          src: ""
        };
        queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "";
        renderer = getQueryVariable("renderer");
      }
      var readyStateCheckInterval = setInterval(checkReady, 100);
      try {
        if (!((typeof exports === "undefined" ? "undefined" : _typeof$3(exports)) === "object" && typeof module !== "undefined") && !(typeof define === "function" && define.amd)) {
          window.bodymovin = lottie;
        }
      } catch (err) {
      }
      var ShapeModifiers = function() {
        var ob2 = {};
        var modifiers = {};
        ob2.registerModifier = registerModifier;
        ob2.getModifier = getModifier;
        function registerModifier(nm, factory) {
          if (!modifiers[nm]) {
            modifiers[nm] = factory;
          }
        }
        function getModifier(nm, elem2, data2) {
          return new modifiers[nm](elem2, data2);
        }
        return ob2;
      }();
      function ShapeModifier() {
      }
      ShapeModifier.prototype.initModifierProperties = function() {
      };
      ShapeModifier.prototype.addShapeToModifier = function() {
      };
      ShapeModifier.prototype.addShape = function(data2) {
        if (!this.closed) {
          data2.sh.container.addDynamicProperty(data2.sh);
          var shapeData = {
            shape: data2.sh,
            data: data2,
            localShapeCollection: shapeCollectionPool.newShapeCollection()
          };
          this.shapes.push(shapeData);
          this.addShapeToModifier(shapeData);
          if (this._isAnimated) {
            data2.setAsAnimated();
          }
        }
      };
      ShapeModifier.prototype.init = function(elem2, data2) {
        this.shapes = [];
        this.elem = elem2;
        this.initDynamicPropertyContainer(elem2);
        this.initModifierProperties(elem2, data2);
        this.frameId = initialDefaultFrame;
        this.closed = false;
        this.k = false;
        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };
      ShapeModifier.prototype.processKeys = function() {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
      };
      extendPrototype([DynamicPropertyContainer], ShapeModifier);
      function TrimModifier() {
      }
      extendPrototype([ShapeModifier], TrimModifier);
      TrimModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.s = PropertyFactory.getProp(elem2, data2.s, 0, 0.01, this);
        this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0.01, this);
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0, this);
        this.sValue = 0;
        this.eValue = 0;
        this.getValue = this.processKeys;
        this.m = data2.m;
        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
      };
      TrimModifier.prototype.addShapeToModifier = function(shapeData) {
        shapeData.pathsData = [];
      };
      TrimModifier.prototype.calculateShapeEdges = function(s2, e5, shapeLength, addedLength, totalModifierLength) {
        var segments = [];
        if (e5 <= 1) {
          segments.push({
            s: s2,
            e: e5
          });
        } else if (s2 >= 1) {
          segments.push({
            s: s2 - 1,
            e: e5 - 1
          });
        } else {
          segments.push({
            s: s2,
            e: 1
          });
          segments.push({
            s: 0,
            e: e5 - 1
          });
        }
        var shapeSegments = [];
        var i4;
        var len = segments.length;
        var segmentOb;
        for (i4 = 0; i4 < len; i4 += 1) {
          segmentOb = segments[i4];
          if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
            var shapeS;
            var shapeE;
            if (segmentOb.s * totalModifierLength <= addedLength) {
              shapeS = 0;
            } else {
              shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
            }
            if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
              shapeE = 1;
            } else {
              shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
            }
            shapeSegments.push([shapeS, shapeE]);
          }
        }
        if (!shapeSegments.length) {
          shapeSegments.push([0, 0]);
        }
        return shapeSegments;
      };
      TrimModifier.prototype.releasePathsData = function(pathsData) {
        var i4;
        var len = pathsData.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          segmentsLengthPool.release(pathsData[i4]);
        }
        pathsData.length = 0;
        return pathsData;
      };
      TrimModifier.prototype.processShapes = function(_isFirstFrame) {
        var s2;
        var e5;
        if (this._mdf || _isFirstFrame) {
          var o4 = this.o.v % 360 / 360;
          if (o4 < 0) {
            o4 += 1;
          }
          if (this.s.v > 1) {
            s2 = 1 + o4;
          } else if (this.s.v < 0) {
            s2 = 0 + o4;
          } else {
            s2 = this.s.v + o4;
          }
          if (this.e.v > 1) {
            e5 = 1 + o4;
          } else if (this.e.v < 0) {
            e5 = 0 + o4;
          } else {
            e5 = this.e.v + o4;
          }
          if (s2 > e5) {
            var _s = s2;
            s2 = e5;
            e5 = _s;
          }
          s2 = Math.round(s2 * 1e4) * 1e-4;
          e5 = Math.round(e5 * 1e4) * 1e-4;
          this.sValue = s2;
          this.eValue = e5;
        } else {
          s2 = this.sValue;
          e5 = this.eValue;
        }
        var shapePaths;
        var i4;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var pathsData;
        var pathData;
        var totalShapeLength;
        var totalModifierLength = 0;
        if (e5 === s2) {
          for (i4 = 0; i4 < len; i4 += 1) {
            this.shapes[i4].localShapeCollection.releaseShapes();
            this.shapes[i4].shape._mdf = true;
            this.shapes[i4].shape.paths = this.shapes[i4].localShapeCollection;
            if (this._mdf) {
              this.shapes[i4].pathsData.length = 0;
            }
          }
        } else if (!(e5 === 1 && s2 === 0 || e5 === 0 && s2 === 1)) {
          var segments = [];
          var shapeData;
          var localShapeCollection;
          for (i4 = 0; i4 < len; i4 += 1) {
            shapeData = this.shapes[i4];
            if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
              shapeData.shape.paths = shapeData.localShapeCollection;
            } else {
              shapePaths = shapeData.shape.paths;
              jLen = shapePaths._length;
              totalShapeLength = 0;
              if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                totalShapeLength = shapeData.totalShapeLength;
              } else {
                pathsData = this.releasePathsData(shapeData.pathsData);
                for (j2 = 0; j2 < jLen; j2 += 1) {
                  pathData = bez.getSegmentsLength(shapePaths.shapes[j2]);
                  pathsData.push(pathData);
                  totalShapeLength += pathData.totalLength;
                }
                shapeData.totalShapeLength = totalShapeLength;
                shapeData.pathsData = pathsData;
              }
              totalModifierLength += totalShapeLength;
              shapeData.shape._mdf = true;
            }
          }
          var shapeS = s2;
          var shapeE = e5;
          var addedLength = 0;
          var edges;
          for (i4 = len - 1; i4 >= 0; i4 -= 1) {
            shapeData = this.shapes[i4];
            if (shapeData.shape._mdf) {
              localShapeCollection = shapeData.localShapeCollection;
              localShapeCollection.releaseShapes();
              if (this.m === 2 && len > 1) {
                edges = this.calculateShapeEdges(s2, e5, shapeData.totalShapeLength, addedLength, totalModifierLength);
                addedLength += shapeData.totalShapeLength;
              } else {
                edges = [[shapeS, shapeE]];
              }
              jLen = edges.length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                shapeS = edges[j2][0];
                shapeE = edges[j2][1];
                segments.length = 0;
                if (shapeE <= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength * shapeE
                  });
                } else if (shapeS >= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * (shapeS - 1),
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                } else {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength
                  });
                  segments.push({
                    s: 0,
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                }
                var newShapesData = this.addShapes(shapeData, segments[0]);
                if (segments[0].s !== segments[0].e) {
                  if (segments.length > 1) {
                    var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                    if (lastShapeInCollection.c) {
                      var lastShape = newShapesData.pop();
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                    } else {
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1]);
                    }
                  }
                  this.addPaths(newShapesData, localShapeCollection);
                }
              }
              shapeData.shape.paths = localShapeCollection;
            }
          }
        } else if (this._mdf) {
          for (i4 = 0; i4 < len; i4 += 1) {
            this.shapes[i4].pathsData.length = 0;
            this.shapes[i4].shape._mdf = true;
          }
        }
      };
      TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
        var i4;
        var len = newPaths.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          localShapeCollection.addShape(newPaths[i4]);
        }
      };
      TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
        shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
        shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
        if (newShape) {
          shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
        }
        shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
      };
      TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
        shapePath.setXYAt(points[1], points[5], "o", pos);
        shapePath.setXYAt(points[2], points[6], "i", pos + 1);
        if (newShape) {
          shapePath.setXYAt(points[0], points[4], "v", pos);
        }
        shapePath.setXYAt(points[3], points[7], "v", pos + 1);
      };
      TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
        var pathsData = shapeData.pathsData;
        var shapePaths = shapeData.shape.paths.shapes;
        var i4;
        var len = shapeData.shape.paths._length;
        var j2;
        var jLen;
        var addedLength = 0;
        var currentLengthData;
        var segmentCount;
        var lengths;
        var segment;
        var shapes = [];
        var initPos;
        var newShape = true;
        if (!shapePath) {
          shapePath = shapePool.newElement();
          segmentCount = 0;
          initPos = 0;
        } else {
          segmentCount = shapePath._length;
          initPos = shapePath._length;
        }
        shapes.push(shapePath);
        for (i4 = 0; i4 < len; i4 += 1) {
          lengths = pathsData[i4].lengths;
          shapePath.c = shapePaths[i4].c;
          jLen = shapePaths[i4].c ? lengths.length : lengths.length + 1;
          for (j2 = 1; j2 < jLen; j2 += 1) {
            currentLengthData = lengths[j2 - 1];
            if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
              addedLength += currentLengthData.addedLength;
              shapePath.c = false;
            } else if (addedLength > shapeSegment.e) {
              shapePath.c = false;
              break;
            } else {
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                this.addSegment(shapePaths[i4].v[j2 - 1], shapePaths[i4].o[j2 - 1], shapePaths[i4].i[j2], shapePaths[i4].v[j2], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i4].v[j2 - 1], shapePaths[i4].v[j2], shapePaths[i4].o[j2 - 1], shapePaths[i4].i[j2], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j2 - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                newShape = false;
                shapePath.c = false;
              }
              addedLength += currentLengthData.addedLength;
              segmentCount += 1;
            }
          }
          if (shapePaths[i4].c && lengths.length) {
            currentLengthData = lengths[j2 - 1];
            if (addedLength <= shapeSegment.e) {
              var segmentLength = lengths[j2 - 1].addedLength;
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                this.addSegment(shapePaths[i4].v[j2 - 1], shapePaths[i4].o[j2 - 1], shapePaths[i4].i[0], shapePaths[i4].v[0], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i4].v[j2 - 1], shapePaths[i4].v[0], shapePaths[i4].o[j2 - 1], shapePaths[i4].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j2 - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                newShape = false;
                shapePath.c = false;
              }
            } else {
              shapePath.c = false;
            }
            addedLength += currentLengthData.addedLength;
            segmentCount += 1;
          }
          if (shapePath._length) {
            shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
          }
          if (addedLength > shapeSegment.e) {
            break;
          }
          if (i4 < len - 1) {
            shapePath = shapePool.newElement();
            newShape = true;
            shapes.push(shapePath);
            segmentCount = 0;
          }
        }
        return shapes;
      };
      function PuckerAndBloatModifier() {
      }
      extendPrototype([ShapeModifier], PuckerAndBloatModifier);
      PuckerAndBloatModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
        this._isAnimated = !!this.amount.effectsSequence.length;
      };
      PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
        var percent = amount / 100;
        var centerPoint = [0, 0];
        var pathLength = path._length;
        var i4 = 0;
        for (i4 = 0; i4 < pathLength; i4 += 1) {
          centerPoint[0] += path.v[i4][0];
          centerPoint[1] += path.v[i4][1];
        }
        centerPoint[0] /= pathLength;
        centerPoint[1] /= pathLength;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for (i4 = 0; i4 < pathLength; i4 += 1) {
          vX = path.v[i4][0] + (centerPoint[0] - path.v[i4][0]) * percent;
          vY = path.v[i4][1] + (centerPoint[1] - path.v[i4][1]) * percent;
          oX = path.o[i4][0] + (centerPoint[0] - path.o[i4][0]) * -percent;
          oY = path.o[i4][1] + (centerPoint[1] - path.o[i4][1]) * -percent;
          iX = path.i[i4][0] + (centerPoint[0] - path.i[i4][0]) * -percent;
          iY = path.i[i4][1] + (centerPoint[1] - path.i[i4][1]) * -percent;
          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i4);
        }
        return clonedPath;
      };
      PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i4;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var amount = this.amount.v;
        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i4 = 0; i4 < len; i4 += 1) {
            shapeData = this.shapes[i4];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j2], amount));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      var TransformPropertyFactory = function() {
        var defaultVector = [0, 0];
        function applyToMatrix(mat) {
          var _mdf = this._mdf;
          this.iterateDynamicProperties();
          this._mdf = this._mdf || _mdf;
          if (this.a) {
            mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          }
          if (this.s) {
            mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          }
          if (this.sk) {
            mat.skewFromAxis(-this.sk.v, this.sa.v);
          }
          if (this.r) {
            mat.rotate(-this.r.v);
          } else {
            mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          }
          if (this.data.p.s) {
            if (this.data.p.z) {
              mat.translate(this.px.v, this.py.v, -this.pz.v);
            } else {
              mat.translate(this.px.v, this.py.v, 0);
            }
          } else {
            mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
        }
        function processKeys(forceRender) {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          if (this._isDirty) {
            this.precalculateMatrix();
            this._isDirty = false;
          }
          this.iterateDynamicProperties();
          if (this._mdf || forceRender) {
            var frameRate;
            this.v.cloneFromProps(this.pre.props);
            if (this.appliedTransformations < 1) {
              this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }
            if (this.appliedTransformations < 2) {
              this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }
            if (this.sk && this.appliedTransformations < 3) {
              this.v.skewFromAxis(-this.sk.v, this.sa.v);
            }
            if (this.r && this.appliedTransformations < 4) {
              this.v.rotate(-this.r.v);
            } else if (!this.r && this.appliedTransformations < 4) {
              this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }
            if (this.autoOriented) {
              var v1;
              var v2;
              frameRate = this.elem.globalData.frameRate;
              if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                  v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                  v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                  v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                  v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                } else {
                  v1 = this.p.pv;
                  v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                }
              } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                v1 = [];
                v2 = [];
                var px = this.px;
                var py = this.py;
                if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                  v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                  v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                  v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                  v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                  v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                  v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                  v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                  v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                } else {
                  v1 = [px.pv, py.pv];
                  v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                  v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                }
              } else {
                v2 = defaultVector;
                v1 = v2;
              }
              this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
            }
            if (this.data.p && this.data.p.s) {
              if (this.data.p.z) {
                this.v.translate(this.px.v, this.py.v, -this.pz.v);
              } else {
                this.v.translate(this.px.v, this.py.v, 0);
              }
            } else {
              this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
          }
          this.frameId = this.elem.globalData.frameId;
        }
        function precalculateMatrix() {
          this.appliedTransformations = 0;
          this.pre.reset();
          if (!this.a.effectsSequence.length) {
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            this.appliedTransformations = 1;
          } else {
            return;
          }
          if (!this.s.effectsSequence.length) {
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            this.appliedTransformations = 2;
          } else {
            return;
          }
          if (this.sk) {
            if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
              this.pre.skewFromAxis(-this.sk.v, this.sa.v);
              this.appliedTransformations = 3;
            } else {
              return;
            }
          }
          if (this.r) {
            if (!this.r.effectsSequence.length) {
              this.pre.rotate(-this.r.v);
              this.appliedTransformations = 4;
            }
          } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
            this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            this.appliedTransformations = 4;
          }
        }
        function autoOrient() {
        }
        function addDynamicProperty(prop) {
          this._addDynamicProperty(prop);
          this.elem.addDynamicProperty(prop);
          this._isDirty = true;
        }
        function TransformProperty(elem2, data2, container) {
          this.elem = elem2;
          this.frameId = -1;
          this.propType = "transform";
          this.data = data2;
          this.v = new Matrix();
          this.pre = new Matrix();
          this.appliedTransformations = 0;
          this.initDynamicPropertyContainer(container || elem2);
          if (data2.p && data2.p.s) {
            this.px = PropertyFactory.getProp(elem2, data2.p.x, 0, 0, this);
            this.py = PropertyFactory.getProp(elem2, data2.p.y, 0, 0, this);
            if (data2.p.z) {
              this.pz = PropertyFactory.getProp(elem2, data2.p.z, 0, 0, this);
            }
          } else {
            this.p = PropertyFactory.getProp(elem2, data2.p || {
              k: [0, 0, 0]
            }, 1, 0, this);
          }
          if (data2.rx) {
            this.rx = PropertyFactory.getProp(elem2, data2.rx, 0, degToRads, this);
            this.ry = PropertyFactory.getProp(elem2, data2.ry, 0, degToRads, this);
            this.rz = PropertyFactory.getProp(elem2, data2.rz, 0, degToRads, this);
            if (data2.or.k[0].ti) {
              var i4;
              var len = data2.or.k.length;
              for (i4 = 0; i4 < len; i4 += 1) {
                data2.or.k[i4].to = null;
                data2.or.k[i4].ti = null;
              }
            }
            this.or = PropertyFactory.getProp(elem2, data2.or, 1, degToRads, this);
            this.or.sh = true;
          } else {
            this.r = PropertyFactory.getProp(elem2, data2.r || {
              k: 0
            }, 0, degToRads, this);
          }
          if (data2.sk) {
            this.sk = PropertyFactory.getProp(elem2, data2.sk, 0, degToRads, this);
            this.sa = PropertyFactory.getProp(elem2, data2.sa, 0, degToRads, this);
          }
          this.a = PropertyFactory.getProp(elem2, data2.a || {
            k: [0, 0, 0]
          }, 1, 0, this);
          this.s = PropertyFactory.getProp(elem2, data2.s || {
            k: [100, 100, 100]
          }, 1, 0.01, this);
          if (data2.o) {
            this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, elem2);
          } else {
            this.o = {
              _mdf: false,
              v: 1
            };
          }
          this._isDirty = true;
          if (!this.dynamicProperties.length) {
            this.getValue(true);
          }
        }
        TransformProperty.prototype = {
          applyToMatrix,
          getValue: processKeys,
          precalculateMatrix,
          autoOrient
        };
        extendPrototype([DynamicPropertyContainer], TransformProperty);
        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
        function getTransformProperty(elem2, data2, container) {
          return new TransformProperty(elem2, data2, container);
        }
        return {
          getTransformProperty
        };
      }();
      function RepeaterModifier() {
      }
      extendPrototype([ShapeModifier], RepeaterModifier);
      RepeaterModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.c = PropertyFactory.getProp(elem2, data2.c, 0, null, this);
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, null, this);
        this.tr = TransformPropertyFactory.getTransformProperty(elem2, data2.tr, this);
        this.so = PropertyFactory.getProp(elem2, data2.tr.so, 0, 0.01, this);
        this.eo = PropertyFactory.getProp(elem2, data2.tr.eo, 0, 0.01, this);
        this.data = data2;
        if (!this.dynamicProperties.length) {
          this.getValue(true);
        }
        this._isAnimated = !!this.dynamicProperties.length;
        this.pMatrix = new Matrix();
        this.rMatrix = new Matrix();
        this.sMatrix = new Matrix();
        this.tMatrix = new Matrix();
        this.matrix = new Matrix();
      };
      RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform2, perc, inv) {
        var dir = inv ? -1 : 1;
        var scaleX = transform2.s.v[0] + (1 - transform2.s.v[0]) * (1 - perc);
        var scaleY = transform2.s.v[1] + (1 - transform2.s.v[1]) * (1 - perc);
        pMatrix.translate(transform2.p.v[0] * dir * perc, transform2.p.v[1] * dir * perc, transform2.p.v[2]);
        rMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
        rMatrix.rotate(-transform2.r.v * dir * perc);
        rMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
        sMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
        sMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
      };
      RepeaterModifier.prototype.init = function(elem2, arr, pos, elemsData) {
        this.elem = elem2;
        this.arr = arr;
        this.pos = pos;
        this.elemsData = elemsData;
        this._currentCopies = 0;
        this._elements = [];
        this._groups = [];
        this.frameId = -1;
        this.initDynamicPropertyContainer(elem2);
        this.initModifierProperties(elem2, arr[pos]);
        while (pos > 0) {
          pos -= 1;
          this._elements.unshift(arr[pos]);
        }
        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };
      RepeaterModifier.prototype.resetElements = function(elements) {
        var i4;
        var len = elements.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          elements[i4]._processed = false;
          if (elements[i4].ty === "gr") {
            this.resetElements(elements[i4].it);
          }
        }
      };
      RepeaterModifier.prototype.cloneElements = function(elements) {
        var newElements = JSON.parse(JSON.stringify(elements));
        this.resetElements(newElements);
        return newElements;
      };
      RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
        var i4;
        var len = elements.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          elements[i4]._render = renderFlag;
          if (elements[i4].ty === "gr") {
            this.changeGroupRender(elements[i4].it, renderFlag);
          }
        }
      };
      RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
        var items;
        var itemsTransform;
        var i4;
        var dir;
        var cont;
        var hasReloaded = false;
        if (this._mdf || _isFirstFrame) {
          var copies = Math.ceil(this.c.v);
          if (this._groups.length < copies) {
            while (this._groups.length < copies) {
              var group = {
                it: this.cloneElements(this._elements),
                ty: "gr"
              };
              group.it.push({
                a: {
                  a: 0,
                  ix: 1,
                  k: [0, 0]
                },
                nm: "Transform",
                o: {
                  a: 0,
                  ix: 7,
                  k: 100
                },
                p: {
                  a: 0,
                  ix: 2,
                  k: [0, 0]
                },
                r: {
                  a: 1,
                  ix: 6,
                  k: [{
                    s: 0,
                    e: 0,
                    t: 0
                  }, {
                    s: 0,
                    e: 0,
                    t: 1
                  }]
                },
                s: {
                  a: 0,
                  ix: 3,
                  k: [100, 100]
                },
                sa: {
                  a: 0,
                  ix: 5,
                  k: 0
                },
                sk: {
                  a: 0,
                  ix: 4,
                  k: 0
                },
                ty: "tr"
              });
              this.arr.splice(0, 0, group);
              this._groups.splice(0, 0, group);
              this._currentCopies += 1;
            }
            this.elem.reloadShapes();
            hasReloaded = true;
          }
          cont = 0;
          var renderFlag;
          for (i4 = 0; i4 <= this._groups.length - 1; i4 += 1) {
            renderFlag = cont < copies;
            this._groups[i4]._render = renderFlag;
            this.changeGroupRender(this._groups[i4].it, renderFlag);
            if (!renderFlag) {
              var elems = this.elemsData[i4].it;
              var transformData = elems[elems.length - 1];
              if (transformData.transform.op.v !== 0) {
                transformData.transform.op._mdf = true;
                transformData.transform.op.v = 0;
              } else {
                transformData.transform.op._mdf = false;
              }
            }
            cont += 1;
          }
          this._currentCopies = copies;
          var offset = this.o.v;
          var offsetModulo = offset % 1;
          var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
          var pProps = this.pMatrix.props;
          var rProps = this.rMatrix.props;
          var sProps = this.sMatrix.props;
          this.pMatrix.reset();
          this.rMatrix.reset();
          this.sMatrix.reset();
          this.tMatrix.reset();
          this.matrix.reset();
          var iteration = 0;
          if (offset > 0) {
            while (iteration < roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              iteration += 1;
            }
            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
              iteration += offsetModulo;
            }
          } else if (offset < 0) {
            while (iteration > roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
              iteration -= 1;
            }
            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
              iteration -= offsetModulo;
            }
          }
          i4 = this.data.m === 1 ? 0 : this._currentCopies - 1;
          dir = this.data.m === 1 ? 1 : -1;
          cont = this._currentCopies;
          var j2;
          var jLen;
          while (cont) {
            items = this.elemsData[i4].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            jLen = itemsTransform.length;
            items[items.length - 1].transform.mProps._mdf = true;
            items[items.length - 1].transform.op._mdf = true;
            items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i4 / (this._currentCopies - 1));
            if (iteration !== 0) {
              if (i4 !== 0 && dir === 1 || i4 !== this._currentCopies - 1 && dir === -1) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              }
              this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
              this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
              this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
              for (j2 = 0; j2 < jLen; j2 += 1) {
                itemsTransform[j2] = this.matrix.props[j2];
              }
              this.matrix.reset();
            } else {
              this.matrix.reset();
              for (j2 = 0; j2 < jLen; j2 += 1) {
                itemsTransform[j2] = this.matrix.props[j2];
              }
            }
            iteration += 1;
            cont -= 1;
            i4 += dir;
          }
        } else {
          cont = this._currentCopies;
          i4 = 0;
          dir = 1;
          while (cont) {
            items = this.elemsData[i4].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            items[items.length - 1].transform.mProps._mdf = false;
            items[items.length - 1].transform.op._mdf = false;
            cont -= 1;
            i4 += dir;
          }
        }
        return hasReloaded;
      };
      RepeaterModifier.prototype.addShape = function() {
      };
      function RoundCornersModifier() {
      }
      extendPrototype([ShapeModifier], RoundCornersModifier);
      RoundCornersModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.rd = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
        this._isAnimated = !!this.rd.effectsSequence.length;
      };
      RoundCornersModifier.prototype.processPath = function(path, round) {
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var i4;
        var len = path._length;
        var currentV;
        var currentI;
        var currentO;
        var closerV;
        var distance;
        var newPosPerc;
        var index2 = 0;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for (i4 = 0; i4 < len; i4 += 1) {
          currentV = path.v[i4];
          currentO = path.o[i4];
          currentI = path.i[i4];
          if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
            if ((i4 === 0 || i4 === len - 1) && !path.c) {
              clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index2);
              index2 += 1;
            } else {
              if (i4 === 0) {
                closerV = path.v[len - 1];
              } else {
                closerV = path.v[i4 - 1];
              }
              distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
              iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = iX;
              iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
              vY = iY;
              oX = vX - (vX - currentV[0]) * roundCorner;
              oY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
              index2 += 1;
              if (i4 === len - 1) {
                closerV = path.v[0];
              } else {
                closerV = path.v[i4 + 1];
              }
              distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
              oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = oX;
              oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
              vY = oY;
              iX = vX - (vX - currentV[0]) * roundCorner;
              iY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
              index2 += 1;
            }
          } else {
            clonedPath.setTripleAt(path.v[i4][0], path.v[i4][1], path.o[i4][0], path.o[i4][1], path.i[i4][0], path.i[i4][1], index2);
            index2 += 1;
          }
        }
        return clonedPath;
      };
      RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i4;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var rd = this.rd.v;
        if (rd !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i4 = 0; i4 < len; i4 += 1) {
            shapeData = this.shapes[i4];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j2], rd));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function floatEqual(a3, b2) {
        return Math.abs(a3 - b2) * 1e5 <= Math.min(Math.abs(a3), Math.abs(b2));
      }
      function floatZero(f3) {
        return Math.abs(f3) <= 1e-5;
      }
      function lerp(p0, p1, amount) {
        return p0 * (1 - amount) + p1 * amount;
      }
      function lerpPoint(p0, p1, amount) {
        return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
      }
      function quadRoots(a3, b2, c2) {
        if (a3 === 0)
          return [];
        var s2 = b2 * b2 - 4 * a3 * c2;
        if (s2 < 0)
          return [];
        var singleRoot = -b2 / (2 * a3);
        if (s2 === 0)
          return [singleRoot];
        var delta = Math.sqrt(s2) / (2 * a3);
        return [singleRoot - delta, singleRoot + delta];
      }
      function polynomialCoefficients(p0, p1, p2, p3) {
        return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
      }
      function singlePoint(p2) {
        return new PolynomialBezier(p2, p2, p2, p2, false);
      }
      function PolynomialBezier(p0, p1, p2, p3, linearize) {
        if (linearize && pointEqual(p0, p1)) {
          p1 = lerpPoint(p0, p3, 1 / 3);
        }
        if (linearize && pointEqual(p2, p3)) {
          p2 = lerpPoint(p0, p3, 2 / 3);
        }
        var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
        var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
        this.a = [coeffx[0], coeffy[0]];
        this.b = [coeffx[1], coeffy[1]];
        this.c = [coeffx[2], coeffy[2]];
        this.d = [coeffx[3], coeffy[3]];
        this.points = [p0, p1, p2, p3];
      }
      PolynomialBezier.prototype.point = function(t5) {
        return [((this.a[0] * t5 + this.b[0]) * t5 + this.c[0]) * t5 + this.d[0], ((this.a[1] * t5 + this.b[1]) * t5 + this.c[1]) * t5 + this.d[1]];
      };
      PolynomialBezier.prototype.derivative = function(t5) {
        return [(3 * t5 * this.a[0] + 2 * this.b[0]) * t5 + this.c[0], (3 * t5 * this.a[1] + 2 * this.b[1]) * t5 + this.c[1]];
      };
      PolynomialBezier.prototype.tangentAngle = function(t5) {
        var p2 = this.derivative(t5);
        return Math.atan2(p2[1], p2[0]);
      };
      PolynomialBezier.prototype.normalAngle = function(t5) {
        var p2 = this.derivative(t5);
        return Math.atan2(p2[0], p2[1]);
      };
      PolynomialBezier.prototype.inflectionPoints = function() {
        var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
        if (floatZero(denom))
          return [];
        var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
        var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
        if (square < 0)
          return [];
        var root = Math.sqrt(square);
        if (floatZero(root)) {
          if (root > 0 && root < 1)
            return [tcusp];
          return [];
        }
        return [tcusp - root, tcusp + root].filter(function(r3) {
          return r3 > 0 && r3 < 1;
        });
      };
      PolynomialBezier.prototype.split = function(t5) {
        if (t5 <= 0)
          return [singlePoint(this.points[0]), this];
        if (t5 >= 1)
          return [this, singlePoint(this.points[this.points.length - 1])];
        var p10 = lerpPoint(this.points[0], this.points[1], t5);
        var p11 = lerpPoint(this.points[1], this.points[2], t5);
        var p12 = lerpPoint(this.points[2], this.points[3], t5);
        var p20 = lerpPoint(p10, p11, t5);
        var p21 = lerpPoint(p11, p12, t5);
        var p3 = lerpPoint(p20, p21, t5);
        return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
      };
      function extrema(bez2, comp2) {
        var min = bez2.points[0][comp2];
        var max = bez2.points[bez2.points.length - 1][comp2];
        if (min > max) {
          var e5 = max;
          max = min;
          min = e5;
        }
        var f3 = quadRoots(3 * bez2.a[comp2], 2 * bez2.b[comp2], bez2.c[comp2]);
        for (var i4 = 0; i4 < f3.length; i4 += 1) {
          if (f3[i4] > 0 && f3[i4] < 1) {
            var val2 = bez2.point(f3[i4])[comp2];
            if (val2 < min)
              min = val2;
            else if (val2 > max)
              max = val2;
          }
        }
        return {
          min,
          max
        };
      }
      PolynomialBezier.prototype.bounds = function() {
        return {
          x: extrema(this, 0),
          y: extrema(this, 1)
        };
      };
      PolynomialBezier.prototype.boundingBox = function() {
        var bounds = this.bounds();
        return {
          left: bounds.x.min,
          right: bounds.x.max,
          top: bounds.y.min,
          bottom: bounds.y.max,
          width: bounds.x.max - bounds.x.min,
          height: bounds.y.max - bounds.y.min,
          cx: (bounds.x.max + bounds.x.min) / 2,
          cy: (bounds.y.max + bounds.y.min) / 2
        };
      };
      function intersectData(bez2, t1, t22) {
        var box = bez2.boundingBox();
        return {
          cx: box.cx,
          cy: box.cy,
          width: box.width,
          height: box.height,
          bez: bez2,
          t: (t1 + t22) / 2,
          t1,
          t2: t22
        };
      }
      function splitData(data2) {
        var split = data2.bez.split(0.5);
        return [intersectData(split[0], data2.t1, data2.t), intersectData(split[1], data2.t, data2.t2)];
      }
      function boxIntersect(b1, b2) {
        return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
      }
      function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
        if (!boxIntersect(d1, d2))
          return;
        if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
          intersections.push([d1.t, d2.t]);
          return;
        }
        var d1s = splitData(d1);
        var d2s = splitData(d2);
        intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
      }
      PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
        if (tolerance === void 0)
          tolerance = 2;
        if (maxRecursion === void 0)
          maxRecursion = 7;
        var intersections = [];
        intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
        return intersections;
      };
      PolynomialBezier.shapeSegment = function(shapePath, index2) {
        var nextIndex = (index2 + 1) % shapePath.length();
        return new PolynomialBezier(shapePath.v[index2], shapePath.o[index2], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
      };
      PolynomialBezier.shapeSegmentInverted = function(shapePath, index2) {
        var nextIndex = (index2 + 1) % shapePath.length();
        return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index2], shapePath.v[index2], true);
      };
      function crossProduct(a3, b2) {
        return [a3[1] * b2[2] - a3[2] * b2[1], a3[2] * b2[0] - a3[0] * b2[2], a3[0] * b2[1] - a3[1] * b2[0]];
      }
      function lineIntersection(start1, end1, start2, end2) {
        var v1 = [start1[0], start1[1], 1];
        var v2 = [end1[0], end1[1], 1];
        var v3 = [start2[0], start2[1], 1];
        var v42 = [end2[0], end2[1], 1];
        var r3 = crossProduct(crossProduct(v1, v2), crossProduct(v3, v42));
        if (floatZero(r3[2]))
          return null;
        return [r3[0] / r3[2], r3[1] / r3[2]];
      }
      function polarOffset(p2, angle, length2) {
        return [p2[0] + Math.cos(angle) * length2, p2[1] - Math.sin(angle) * length2];
      }
      function pointDistance(p1, p2) {
        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
      }
      function pointEqual(p1, p2) {
        return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
      }
      function ZigZagModifier() {
      }
      extendPrototype([ShapeModifier], ZigZagModifier);
      ZigZagModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amplitude = PropertyFactory.getProp(elem2, data2.s, 0, null, this);
        this.frequency = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
        this.pointsType = PropertyFactory.getProp(elem2, data2.pt, 0, null, this);
        this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
      };
      function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
        var angO = angle - Math.PI / 2;
        var angI = angle + Math.PI / 2;
        var px = point[0] + Math.cos(angle) * direction * amplitude;
        var py = point[1] - Math.sin(angle) * direction * amplitude;
        outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
      }
      function getPerpendicularVector(pt1, pt2) {
        var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
        var rot = -Math.PI * 0.5;
        var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
        return rotatedVector;
      }
      function getProjectingAngle(path, cur) {
        var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
        var nextIndex = (cur + 1) % path.length();
        var prevPoint = path.v[prevIndex];
        var nextPoint = path.v[nextIndex];
        var pVector = getPerpendicularVector(prevPoint, nextPoint);
        return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
      }
      function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
        var angle = getProjectingAngle(path, cur);
        var point = path.v[cur % path._length];
        var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
        var nextPoint = path.v[(cur + 1) % path._length];
        var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
        var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
        setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);
      }
      function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
        for (var i4 = 0; i4 < frequency; i4 += 1) {
          var t5 = (i4 + 1) / (frequency + 1);
          var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
          var angle = segment.normalAngle(t5);
          var point = segment.point(t5);
          setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);
          direction = -direction;
        }
        return direction;
      }
      ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {
        var count = path._length;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        if (!path.c) {
          count -= 1;
        }
        if (count === 0)
          return clonedPath;
        var direction = -1;
        var segment = PolynomialBezier.shapeSegment(path, 0);
        zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
        for (var i4 = 0; i4 < count; i4 += 1) {
          direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
          if (i4 === count - 1 && !path.c) {
            segment = null;
          } else {
            segment = PolynomialBezier.shapeSegment(path, (i4 + 1) % count);
          }
          zigZagCorner(clonedPath, path, i4 + 1, amplitude, frequency, pointType, direction);
        }
        return clonedPath;
      };
      ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i4;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var amplitude = this.amplitude.v;
        var frequency = Math.max(0, Math.round(this.frequency.v));
        var pointType = this.pointsType.v;
        if (amplitude !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i4 = 0; i4 < len; i4 += 1) {
            shapeData = this.shapes[i4];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j2], amplitude, frequency, pointType));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function linearOffset(p1, p2, amount) {
        var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
        return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
      }
      function offsetSegment(segment, amount) {
        var p0;
        var p1a;
        var p1b;
        var p2b;
        var p2a;
        var p3;
        var e5;
        e5 = linearOffset(segment.points[0], segment.points[1], amount);
        p0 = e5[0];
        p1a = e5[1];
        e5 = linearOffset(segment.points[1], segment.points[2], amount);
        p1b = e5[0];
        p2b = e5[1];
        e5 = linearOffset(segment.points[2], segment.points[3], amount);
        p2a = e5[0];
        p3 = e5[1];
        var p1 = lineIntersection(p0, p1a, p1b, p2b);
        if (p1 === null)
          p1 = p1a;
        var p2 = lineIntersection(p2a, p3, p1b, p2b);
        if (p2 === null)
          p2 = p2a;
        return new PolynomialBezier(p0, p1, p2, p3);
      }
      function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
        var p0 = seg1.points[3];
        var p1 = seg2.points[0];
        if (lineJoin === 3)
          return p0;
        if (pointEqual(p0, p1))
          return p0;
        if (lineJoin === 2) {
          var angleOut = -seg1.tangentAngle(1);
          var angleIn = -seg2.tangentAngle(0) + Math.PI;
          var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
          var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
          var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
          outputBezier.setXYAt(tan[0], tan[1], "o", outputBezier.length() - 1);
          tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
          outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
          return p1;
        }
        var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
        var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
        var intersection = lineIntersection(t0, p0, p1, t1);
        if (intersection && pointDistance(intersection, p0) < miterLimit) {
          outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
          return intersection;
        }
        return p0;
      }
      function getIntersection(a3, b2) {
        var intersect = a3.intersections(b2);
        if (intersect.length && floatEqual(intersect[0][0], 1))
          intersect.shift();
        if (intersect.length)
          return intersect[0];
        return null;
      }
      function pruneSegmentIntersection(a3, b2) {
        var outa = a3.slice();
        var outb = b2.slice();
        var intersect = getIntersection(a3[a3.length - 1], b2[0]);
        if (intersect) {
          outa[a3.length - 1] = a3[a3.length - 1].split(intersect[0])[0];
          outb[0] = b2[0].split(intersect[1])[1];
        }
        if (a3.length > 1 && b2.length > 1) {
          intersect = getIntersection(a3[0], b2[b2.length - 1]);
          if (intersect) {
            return [[a3[0].split(intersect[0])[0]], [b2[b2.length - 1].split(intersect[1])[1]]];
          }
        }
        return [outa, outb];
      }
      function pruneIntersections(segments) {
        var e5;
        for (var i4 = 1; i4 < segments.length; i4 += 1) {
          e5 = pruneSegmentIntersection(segments[i4 - 1], segments[i4]);
          segments[i4 - 1] = e5[0];
          segments[i4] = e5[1];
        }
        if (segments.length > 1) {
          e5 = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
          segments[segments.length - 1] = e5[0];
          segments[0] = e5[1];
        }
        return segments;
      }
      function offsetSegmentSplit(segment, amount) {
        var flex = segment.inflectionPoints();
        var left;
        var right;
        var split;
        var mid;
        if (flex.length === 0) {
          return [offsetSegment(segment, amount)];
        }
        if (flex.length === 1 || floatEqual(flex[1], 1)) {
          split = segment.split(flex[0]);
          left = split[0];
          right = split[1];
          return [offsetSegment(left, amount), offsetSegment(right, amount)];
        }
        split = segment.split(flex[0]);
        left = split[0];
        var t5 = (flex[1] - flex[0]) / (1 - flex[0]);
        split = split[1].split(t5);
        mid = split[0];
        right = split[1];
        return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
      }
      function OffsetPathModifier() {
      }
      extendPrototype([ShapeModifier], OffsetPathModifier);
      OffsetPathModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
        this.miterLimit = PropertyFactory.getProp(elem2, data2.ml, 0, null, this);
        this.lineJoin = data2.lj;
        this._isAnimated = this.amount.effectsSequence.length !== 0;
      };
      OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
        var outputBezier = shapePool.newElement();
        outputBezier.c = inputBezier.c;
        var count = inputBezier.length();
        if (!inputBezier.c) {
          count -= 1;
        }
        var i4;
        var j2;
        var segment;
        var multiSegments = [];
        for (i4 = 0; i4 < count; i4 += 1) {
          segment = PolynomialBezier.shapeSegment(inputBezier, i4);
          multiSegments.push(offsetSegmentSplit(segment, amount));
        }
        if (!inputBezier.c) {
          for (i4 = count - 1; i4 >= 0; i4 -= 1) {
            segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i4);
            multiSegments.push(offsetSegmentSplit(segment, amount));
          }
        }
        multiSegments = pruneIntersections(multiSegments);
        var lastPoint = null;
        var lastSeg = null;
        for (i4 = 0; i4 < multiSegments.length; i4 += 1) {
          var multiSegment = multiSegments[i4];
          if (lastSeg)
            lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
          lastSeg = multiSegment[multiSegment.length - 1];
          for (j2 = 0; j2 < multiSegment.length; j2 += 1) {
            segment = multiSegment[j2];
            if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
              outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1);
            } else {
              outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
            }
            outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
            lastPoint = segment.points[3];
          }
        }
        if (multiSegments.length)
          joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
        return outputBezier;
      };
      OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i4;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var amount = this.amount.v;
        var miterLimit = this.miterLimit.v;
        var lineJoin = this.lineJoin;
        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i4 = 0; i4 < len; i4 += 1) {
            shapeData = this.shapes[i4];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j2], amount, lineJoin, miterLimit));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function getFontProperties(fontData) {
        var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
        var fWeight = "normal";
        var fStyle = "normal";
        var len = styles.length;
        var styleName;
        for (var i4 = 0; i4 < len; i4 += 1) {
          styleName = styles[i4].toLowerCase();
          switch (styleName) {
            case "italic":
              fStyle = "italic";
              break;
            case "bold":
              fWeight = "700";
              break;
            case "black":
              fWeight = "900";
              break;
            case "medium":
              fWeight = "500";
              break;
            case "regular":
            case "normal":
              fWeight = "400";
              break;
            case "light":
            case "thin":
              fWeight = "200";
              break;
            default:
              break;
          }
        }
        return {
          style: fStyle,
          weight: fontData.fWeight || fWeight
        };
      }
      var FontManager = function() {
        var maxWaitingTime = 5e3;
        var emptyChar = {
          w: 0,
          size: 0,
          shapes: [],
          data: {
            shapes: []
          }
        };
        var combinedCharacters = [];
        combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
        var BLACK_FLAG_CODE_POINT = 127988;
        var CANCEL_TAG_CODE_POINT = 917631;
        var A_TAG_CODE_POINT = 917601;
        var Z_TAG_CODE_POINT = 917626;
        var VARIATION_SELECTOR_16_CODE_POINT = 65039;
        var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
        var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
        var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
        var surrogateModifiers = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
        function trimFontOptions(font) {
          var familyArray = font.split(",");
          var i4;
          var len = familyArray.length;
          var enabledFamilies = [];
          for (i4 = 0; i4 < len; i4 += 1) {
            if (familyArray[i4] !== "sans-serif" && familyArray[i4] !== "monospace") {
              enabledFamilies.push(familyArray[i4]);
            }
          }
          return enabledFamilies.join(",");
        }
        function setUpNode(font, family) {
          var parentNode = createTag("span");
          parentNode.setAttribute("aria-hidden", true);
          parentNode.style.fontFamily = family;
          var node = createTag("span");
          node.innerText = "giItT1WQy@!-/#";
          parentNode.style.position = "absolute";
          parentNode.style.left = "-10000px";
          parentNode.style.top = "-10000px";
          parentNode.style.fontSize = "300px";
          parentNode.style.fontVariant = "normal";
          parentNode.style.fontStyle = "normal";
          parentNode.style.fontWeight = "normal";
          parentNode.style.letterSpacing = "0";
          parentNode.appendChild(node);
          document.body.appendChild(parentNode);
          var width2 = node.offsetWidth;
          node.style.fontFamily = trimFontOptions(font) + ", " + family;
          return {
            node,
            w: width2,
            parent: parentNode
          };
        }
        function checkLoadedFonts() {
          var i4;
          var len = this.fonts.length;
          var node;
          var w2;
          var loadedCount = len;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (this.fonts[i4].loaded) {
              loadedCount -= 1;
            } else if (this.fonts[i4].fOrigin === "n" || this.fonts[i4].origin === 0) {
              this.fonts[i4].loaded = true;
            } else {
              node = this.fonts[i4].monoCase.node;
              w2 = this.fonts[i4].monoCase.w;
              if (node.offsetWidth !== w2) {
                loadedCount -= 1;
                this.fonts[i4].loaded = true;
              } else {
                node = this.fonts[i4].sansCase.node;
                w2 = this.fonts[i4].sansCase.w;
                if (node.offsetWidth !== w2) {
                  loadedCount -= 1;
                  this.fonts[i4].loaded = true;
                }
              }
              if (this.fonts[i4].loaded) {
                this.fonts[i4].sansCase.parent.parentNode.removeChild(this.fonts[i4].sansCase.parent);
                this.fonts[i4].monoCase.parent.parentNode.removeChild(this.fonts[i4].monoCase.parent);
              }
            }
          }
          if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
            setTimeout(this.checkLoadedFontsBinded, 20);
          } else {
            setTimeout(this.setIsLoadedBinded, 10);
          }
        }
        function createHelper(fontData, def) {
          var engine = document.body && def ? "svg" : "canvas";
          var helper;
          var fontProps = getFontProperties(fontData);
          if (engine === "svg") {
            var tHelper = createNS("text");
            tHelper.style.fontSize = "100px";
            tHelper.setAttribute("font-family", fontData.fFamily);
            tHelper.setAttribute("font-style", fontProps.style);
            tHelper.setAttribute("font-weight", fontProps.weight);
            tHelper.textContent = "1";
            if (fontData.fClass) {
              tHelper.style.fontFamily = "inherit";
              tHelper.setAttribute("class", fontData.fClass);
            } else {
              tHelper.style.fontFamily = fontData.fFamily;
            }
            def.appendChild(tHelper);
            helper = tHelper;
          } else {
            var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
            tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
            helper = tCanvasHelper;
          }
          function measure(text2) {
            if (engine === "svg") {
              helper.textContent = text2;
              return helper.getComputedTextLength();
            }
            return helper.measureText(text2).width;
          }
          return {
            measureText: measure
          };
        }
        function addFonts(fontData, defs) {
          if (!fontData) {
            this.isLoaded = true;
            return;
          }
          if (this.chars) {
            this.isLoaded = true;
            this.fonts = fontData.list;
            return;
          }
          if (!document.body) {
            this.isLoaded = true;
            fontData.list.forEach(function(data2) {
              data2.helper = createHelper(data2);
              data2.cache = {};
            });
            this.fonts = fontData.list;
            return;
          }
          var fontArr = fontData.list;
          var i4;
          var len = fontArr.length;
          var _pendingFonts = len;
          for (i4 = 0; i4 < len; i4 += 1) {
            var shouldLoadFont = true;
            var loadedSelector;
            var j2;
            fontArr[i4].loaded = false;
            fontArr[i4].monoCase = setUpNode(fontArr[i4].fFamily, "monospace");
            fontArr[i4].sansCase = setUpNode(fontArr[i4].fFamily, "sans-serif");
            if (!fontArr[i4].fPath) {
              fontArr[i4].loaded = true;
              _pendingFonts -= 1;
            } else if (fontArr[i4].fOrigin === "p" || fontArr[i4].origin === 3) {
              loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i4].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i4].fFamily + '"]');
              if (loadedSelector.length > 0) {
                shouldLoadFont = false;
              }
              if (shouldLoadFont) {
                var s2 = createTag("style");
                s2.setAttribute("f-forigin", fontArr[i4].fOrigin);
                s2.setAttribute("f-origin", fontArr[i4].origin);
                s2.setAttribute("f-family", fontArr[i4].fFamily);
                s2.type = "text/css";
                s2.innerText = "@font-face {font-family: " + fontArr[i4].fFamily + "; font-style: normal; src: url('" + fontArr[i4].fPath + "');}";
                defs.appendChild(s2);
              }
            } else if (fontArr[i4].fOrigin === "g" || fontArr[i4].origin === 1) {
              loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
              for (j2 = 0; j2 < loadedSelector.length; j2 += 1) {
                if (loadedSelector[j2].href.indexOf(fontArr[i4].fPath) !== -1) {
                  shouldLoadFont = false;
                }
              }
              if (shouldLoadFont) {
                var l3 = createTag("link");
                l3.setAttribute("f-forigin", fontArr[i4].fOrigin);
                l3.setAttribute("f-origin", fontArr[i4].origin);
                l3.type = "text/css";
                l3.rel = "stylesheet";
                l3.href = fontArr[i4].fPath;
                document.body.appendChild(l3);
              }
            } else if (fontArr[i4].fOrigin === "t" || fontArr[i4].origin === 2) {
              loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
              for (j2 = 0; j2 < loadedSelector.length; j2 += 1) {
                if (fontArr[i4].fPath === loadedSelector[j2].src) {
                  shouldLoadFont = false;
                }
              }
              if (shouldLoadFont) {
                var sc = createTag("link");
                sc.setAttribute("f-forigin", fontArr[i4].fOrigin);
                sc.setAttribute("f-origin", fontArr[i4].origin);
                sc.setAttribute("rel", "stylesheet");
                sc.setAttribute("href", fontArr[i4].fPath);
                defs.appendChild(sc);
              }
            }
            fontArr[i4].helper = createHelper(fontArr[i4], defs);
            fontArr[i4].cache = {};
            this.fonts.push(fontArr[i4]);
          }
          if (_pendingFonts === 0) {
            this.isLoaded = true;
          } else {
            setTimeout(this.checkLoadedFonts.bind(this), 100);
          }
        }
        function addChars(chars) {
          if (!chars) {
            return;
          }
          if (!this.chars) {
            this.chars = [];
          }
          var i4;
          var len = chars.length;
          var j2;
          var jLen = this.chars.length;
          var found;
          for (i4 = 0; i4 < len; i4 += 1) {
            j2 = 0;
            found = false;
            while (j2 < jLen) {
              if (this.chars[j2].style === chars[i4].style && this.chars[j2].fFamily === chars[i4].fFamily && this.chars[j2].ch === chars[i4].ch) {
                found = true;
              }
              j2 += 1;
            }
            if (!found) {
              this.chars.push(chars[i4]);
              jLen += 1;
            }
          }
        }
        function getCharData(_char, style, font) {
          var i4 = 0;
          var len = this.chars.length;
          while (i4 < len) {
            if (this.chars[i4].ch === _char && this.chars[i4].style === style && this.chars[i4].fFamily === font) {
              return this.chars[i4];
            }
            i4 += 1;
          }
          if ((typeof _char === "string" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn && !this._warned) {
            this._warned = true;
            console.warn("Missing character from exported characters list: ", _char, style, font);
          }
          return emptyChar;
        }
        function measureText(_char2, fontName, size) {
          var fontData = this.getFontByName(fontName);
          var index2 = _char2;
          if (!fontData.cache[index2]) {
            var tHelper = fontData.helper;
            if (_char2 === " ") {
              var doubleSize = tHelper.measureText("|" + _char2 + "|");
              var singleSize = tHelper.measureText("||");
              fontData.cache[index2] = (doubleSize - singleSize) / 100;
            } else {
              fontData.cache[index2] = tHelper.measureText(_char2) / 100;
            }
          }
          return fontData.cache[index2] * size;
        }
        function getFontByName(name2) {
          var i4 = 0;
          var len = this.fonts.length;
          while (i4 < len) {
            if (this.fonts[i4].fName === name2) {
              return this.fonts[i4];
            }
            i4 += 1;
          }
          return this.fonts[0];
        }
        function getCodePoint(string) {
          var codePoint = 0;
          var first = string.charCodeAt(0);
          if (first >= 55296 && first <= 56319) {
            var second = string.charCodeAt(1);
            if (second >= 56320 && second <= 57343) {
              codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            }
          }
          return codePoint;
        }
        function isModifier(firstCharCode, secondCharCode) {
          var sum2 = firstCharCode.toString(16) + secondCharCode.toString(16);
          return surrogateModifiers.indexOf(sum2) !== -1;
        }
        function isZeroWidthJoiner(charCode) {
          return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
        }
        function isVariationSelector(charCode) {
          return charCode === VARIATION_SELECTOR_16_CODE_POINT;
        }
        function isRegionalCode(string) {
          var codePoint = getCodePoint(string);
          if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
            return true;
          }
          return false;
        }
        function isFlagEmoji(string) {
          return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
        }
        function isCombinedCharacter(_char3) {
          return combinedCharacters.indexOf(_char3) !== -1;
        }
        function isRegionalFlag(text2, index2) {
          var codePoint = getCodePoint(text2.substr(index2, 2));
          if (codePoint !== BLACK_FLAG_CODE_POINT) {
            return false;
          }
          var count = 0;
          index2 += 2;
          while (count < 5) {
            codePoint = getCodePoint(text2.substr(index2, 2));
            if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
              return false;
            }
            count += 1;
            index2 += 2;
          }
          return getCodePoint(text2.substr(index2, 2)) === CANCEL_TAG_CODE_POINT;
        }
        function setIsLoaded() {
          this.isLoaded = true;
        }
        var Font = function Font2() {
          this.fonts = [];
          this.chars = null;
          this.typekitLoaded = 0;
          this.isLoaded = false;
          this._warned = false;
          this.initTime = Date.now();
          this.setIsLoadedBinded = this.setIsLoaded.bind(this);
          this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
        };
        Font.isModifier = isModifier;
        Font.isZeroWidthJoiner = isZeroWidthJoiner;
        Font.isFlagEmoji = isFlagEmoji;
        Font.isRegionalCode = isRegionalCode;
        Font.isCombinedCharacter = isCombinedCharacter;
        Font.isRegionalFlag = isRegionalFlag;
        Font.isVariationSelector = isVariationSelector;
        Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
        var fontPrototype = {
          addChars,
          addFonts,
          getCharData,
          getFontByName,
          measureText,
          checkLoadedFonts,
          setIsLoaded
        };
        Font.prototype = fontPrototype;
        return Font;
      }();
      function SlotManager(animationData2) {
        this.animationData = animationData2;
      }
      SlotManager.prototype.getProp = function(data2) {
        if (this.animationData.slots && this.animationData.slots[data2.sid]) {
          return Object.assign(data2, this.animationData.slots[data2.sid].p);
        }
        return data2;
      };
      function slotFactory(animationData2) {
        return new SlotManager(animationData2);
      }
      function RenderableElement() {
      }
      RenderableElement.prototype = {
        initRenderable: function initRenderable() {
          this.isInRange = false;
          this.hidden = false;
          this.isTransparent = false;
          this.renderableComponents = [];
        },
        addRenderableComponent: function addRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) === -1) {
            this.renderableComponents.push(component);
          }
        },
        removeRenderableComponent: function removeRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) !== -1) {
            this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
          }
        },
        prepareRenderableFrame: function prepareRenderableFrame(num) {
          this.checkLayerLimits(num);
        },
        checkTransparency: function checkTransparency() {
          if (this.finalTransform.mProp.o.v <= 0) {
            if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
              this.isTransparent = true;
              this.hide();
            }
          } else if (this.isTransparent) {
            this.isTransparent = false;
            this.show();
          }
        },
        /**
           * @function
           * Initializes frame related properties.
           *
           * @param {number} num
           * current frame number in Layer's time
           *
           */
        checkLayerLimits: function checkLayerLimits(num) {
          if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
            if (this.isInRange !== true) {
              this.globalData._mdf = true;
              this._mdf = true;
              this.isInRange = true;
              this.show();
            }
          } else if (this.isInRange !== false) {
            this.globalData._mdf = true;
            this.isInRange = false;
            this.hide();
          }
        },
        renderRenderable: function renderRenderable() {
          var i4;
          var len = this.renderableComponents.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            this.renderableComponents[i4].renderFrame(this._isFirstFrame);
          }
        },
        sourceRectAtTime: function sourceRectAtTime2() {
          return {
            top: 0,
            left: 0,
            width: 100,
            height: 100
          };
        },
        getLayerSize: function getLayerSize() {
          if (this.data.ty === 5) {
            return {
              w: this.data.textData.width,
              h: this.data.textData.height
            };
          }
          return {
            w: this.data.width,
            h: this.data.height
          };
        }
      };
      var getBlendMode = function() {
        var blendModeEnums = {
          0: "source-over",
          1: "multiply",
          2: "screen",
          3: "overlay",
          4: "darken",
          5: "lighten",
          6: "color-dodge",
          7: "color-burn",
          8: "hard-light",
          9: "soft-light",
          10: "difference",
          11: "exclusion",
          12: "hue",
          13: "saturation",
          14: "color",
          15: "luminosity"
        };
        return function(mode) {
          return blendModeEnums[mode] || "";
        };
      }();
      function SliderEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function AngleEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function ColorEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
      }
      function PointEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
      }
      function LayerIndexEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function MaskIndexEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function CheckboxEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function NoValueEffect() {
        this.p = {};
      }
      function EffectsManager(data2, element) {
        var effects = data2.ef || [];
        this.effectElements = [];
        var i4;
        var len = effects.length;
        var effectItem;
        for (i4 = 0; i4 < len; i4 += 1) {
          effectItem = new GroupEffect(effects[i4], element);
          this.effectElements.push(effectItem);
        }
      }
      function GroupEffect(data2, element) {
        this.init(data2, element);
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect);
      GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
      GroupEffect.prototype.init = function(data2, element) {
        this.data = data2;
        this.effectElements = [];
        this.initDynamicPropertyContainer(element);
        var i4;
        var len = this.data.ef.length;
        var eff;
        var effects = this.data.ef;
        for (i4 = 0; i4 < len; i4 += 1) {
          eff = null;
          switch (effects[i4].ty) {
            case 0:
              eff = new SliderEffect(effects[i4], element, this);
              break;
            case 1:
              eff = new AngleEffect(effects[i4], element, this);
              break;
            case 2:
              eff = new ColorEffect(effects[i4], element, this);
              break;
            case 3:
              eff = new PointEffect(effects[i4], element, this);
              break;
            case 4:
            case 7:
              eff = new CheckboxEffect(effects[i4], element, this);
              break;
            case 10:
              eff = new LayerIndexEffect(effects[i4], element, this);
              break;
            case 11:
              eff = new MaskIndexEffect(effects[i4], element, this);
              break;
            case 5:
              eff = new EffectsManager(effects[i4], element, this);
              break;
            default:
              eff = new NoValueEffect(effects[i4], element, this);
              break;
          }
          if (eff) {
            this.effectElements.push(eff);
          }
        }
      };
      function BaseElement() {
      }
      BaseElement.prototype = {
        checkMasks: function checkMasks() {
          if (!this.data.hasMask) {
            return false;
          }
          var i4 = 0;
          var len = this.data.masksProperties.length;
          while (i4 < len) {
            if (this.data.masksProperties[i4].mode !== "n" && this.data.masksProperties[i4].cl !== false) {
              return true;
            }
            i4 += 1;
          }
          return false;
        },
        initExpressions: function initExpressions() {
          var expressionsInterfaces2 = getExpressionInterfaces();
          if (!expressionsInterfaces2) {
            return;
          }
          var LayerExpressionInterface2 = expressionsInterfaces2("layer");
          var EffectsExpressionInterface2 = expressionsInterfaces2("effects");
          var ShapeExpressionInterface2 = expressionsInterfaces2("shape");
          var TextExpressionInterface2 = expressionsInterfaces2("text");
          var CompExpressionInterface2 = expressionsInterfaces2("comp");
          this.layerInterface = LayerExpressionInterface2(this);
          if (this.data.hasMask && this.maskManager) {
            this.layerInterface.registerMaskInterface(this.maskManager);
          }
          var effectsInterface = EffectsExpressionInterface2.createEffectsInterface(this, this.layerInterface);
          this.layerInterface.registerEffectsInterface(effectsInterface);
          if (this.data.ty === 0 || this.data.xt) {
            this.compInterface = CompExpressionInterface2(this);
          } else if (this.data.ty === 4) {
            this.layerInterface.shapeInterface = ShapeExpressionInterface2(this.shapesData, this.itemsData, this.layerInterface);
            this.layerInterface.content = this.layerInterface.shapeInterface;
          } else if (this.data.ty === 5) {
            this.layerInterface.textInterface = TextExpressionInterface2(this);
            this.layerInterface.text = this.layerInterface.textInterface;
          }
        },
        setBlendMode: function setBlendMode() {
          var blendModeValue = getBlendMode(this.data.bm);
          var elem2 = this.baseElement || this.layerElement;
          elem2.style["mix-blend-mode"] = blendModeValue;
        },
        initBaseData: function initBaseData(data2, globalData2, comp2) {
          this.globalData = globalData2;
          this.comp = comp2;
          this.data = data2;
          this.layerId = createElementID();
          if (!this.data.sr) {
            this.data.sr = 1;
          }
          this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
        },
        getType: function getType() {
          return this.type;
        },
        sourceRectAtTime: function sourceRectAtTime2() {
        }
      };
      function FrameElement() {
      }
      FrameElement.prototype = {
        /**
           * @function
           * Initializes frame related properties.
           *
           */
        initFrame: function initFrame2() {
          this._isFirstFrame = false;
          this.dynamicProperties = [];
          this._mdf = false;
        },
        /**
           * @function
           * Calculates all dynamic values
           *
           * @param {number} num
           * current frame number in Layer's time
           * @param {boolean} isVisible
           * if layers is currently in range
           *
           */
        prepareProperties: function prepareProperties(num, isVisible) {
          var i4;
          var len = this.dynamicProperties.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (isVisible || this._isParent && this.dynamicProperties[i4].propType === "transform") {
              this.dynamicProperties[i4].getValue();
              if (this.dynamicProperties[i4]._mdf) {
                this.globalData._mdf = true;
                this._mdf = true;
              }
            }
          }
        },
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
          }
        }
      };
      function FootageElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData2.getAssetData(data2.refId);
        this.footageData = globalData2.imageLoader.getAsset(this.assetData);
        this.initBaseData(data2, globalData2, comp2);
      }
      FootageElement.prototype.prepareFrame = function() {
      };
      extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
      FootageElement.prototype.getBaseElement = function() {
        return null;
      };
      FootageElement.prototype.renderFrame = function() {
      };
      FootageElement.prototype.destroy = function() {
      };
      FootageElement.prototype.initExpressions = function() {
        var expressionsInterfaces2 = getExpressionInterfaces();
        if (!expressionsInterfaces2) {
          return;
        }
        var FootageInterface2 = expressionsInterfaces2("footage");
        this.layerInterface = FootageInterface2(this);
      };
      FootageElement.prototype.getFootageData = function() {
        return this.footageData;
      };
      function AudioElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData2.getAssetData(data2.refId);
        this.initBaseData(data2, globalData2, comp2);
        this._isPlaying = false;
        this._canPlay = false;
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.audio = this.globalData.audioController.createAudio(assetPath);
        this._currentTime = 0;
        this.globalData.audioController.addAudio(this);
        this._volumeMultiplier = 1;
        this._volume = 1;
        this._previousVolume = null;
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
        this.lv = PropertyFactory.getProp(this, data2.au && data2.au.lv ? data2.au.lv : {
          k: [100]
        }, 1, 0.01, this);
      }
      AudioElement.prototype.prepareFrame = function(num) {
        this.prepareRenderableFrame(num, true);
        this.prepareProperties(num, true);
        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          this._currentTime = timeRemapped;
        } else {
          this._currentTime = num / this.data.sr;
        }
        this._volume = this.lv.v[0];
        var totalVolume = this._volume * this._volumeMultiplier;
        if (this._previousVolume !== totalVolume) {
          this._previousVolume = totalVolume;
          this.audio.volume(totalVolume);
        }
      };
      extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
      AudioElement.prototype.renderFrame = function() {
        if (this.isInRange && this._canPlay) {
          if (!this._isPlaying) {
            this.audio.play();
            this.audio.seek(this._currentTime / this.globalData.frameRate);
            this._isPlaying = true;
          } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
            this.audio.seek(this._currentTime / this.globalData.frameRate);
          }
        }
      };
      AudioElement.prototype.show = function() {
      };
      AudioElement.prototype.hide = function() {
        this.audio.pause();
        this._isPlaying = false;
      };
      AudioElement.prototype.pause = function() {
        this.audio.pause();
        this._isPlaying = false;
        this._canPlay = false;
      };
      AudioElement.prototype.resume = function() {
        this._canPlay = true;
      };
      AudioElement.prototype.setRate = function(rateValue) {
        this.audio.rate(rateValue);
      };
      AudioElement.prototype.volume = function(volumeValue) {
        this._volumeMultiplier = volumeValue;
        this._previousVolume = volumeValue * this._volume;
        this.audio.volume(this._previousVolume);
      };
      AudioElement.prototype.getBaseElement = function() {
        return null;
      };
      AudioElement.prototype.destroy = function() {
      };
      AudioElement.prototype.sourceRectAtTime = function() {
      };
      AudioElement.prototype.initExpressions = function() {
      };
      function BaseRenderer() {
      }
      BaseRenderer.prototype.checkLayers = function(num) {
        var i4;
        var len = this.layers.length;
        var data2;
        this.completeLayers = true;
        for (i4 = len - 1; i4 >= 0; i4 -= 1) {
          if (!this.elements[i4]) {
            data2 = this.layers[i4];
            if (data2.ip - data2.st <= num - this.layers[i4].st && data2.op - data2.st > num - this.layers[i4].st) {
              this.buildItem(i4);
            }
          }
          this.completeLayers = this.elements[i4] ? this.completeLayers : false;
        }
        this.checkPendingElements();
      };
      BaseRenderer.prototype.createItem = function(layer) {
        switch (layer.ty) {
          case 2:
            return this.createImage(layer);
          case 0:
            return this.createComp(layer);
          case 1:
            return this.createSolid(layer);
          case 3:
            return this.createNull(layer);
          case 4:
            return this.createShape(layer);
          case 5:
            return this.createText(layer);
          case 6:
            return this.createAudio(layer);
          case 13:
            return this.createCamera(layer);
          case 15:
            return this.createFootage(layer);
          default:
            return this.createNull(layer);
        }
      };
      BaseRenderer.prototype.createCamera = function() {
        throw new Error("You're using a 3d camera. Try the html renderer.");
      };
      BaseRenderer.prototype.createAudio = function(data2) {
        return new AudioElement(data2, this.globalData, this);
      };
      BaseRenderer.prototype.createFootage = function(data2) {
        return new FootageElement(data2, this.globalData, this);
      };
      BaseRenderer.prototype.buildAllItems = function() {
        var i4;
        var len = this.layers.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.buildItem(i4);
        }
        this.checkPendingElements();
      };
      BaseRenderer.prototype.includeLayers = function(newLayers) {
        this.completeLayers = false;
        var i4;
        var len = newLayers.length;
        var j2;
        var jLen = this.layers.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          j2 = 0;
          while (j2 < jLen) {
            if (this.layers[j2].id === newLayers[i4].id) {
              this.layers[j2] = newLayers[i4];
              break;
            }
            j2 += 1;
          }
        }
      };
      BaseRenderer.prototype.setProjectInterface = function(pInterface) {
        this.globalData.projectInterface = pInterface;
      };
      BaseRenderer.prototype.initItems = function() {
        if (!this.globalData.progressiveLoad) {
          this.buildAllItems();
        }
      };
      BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
        var elements = this.elements;
        var layers = this.layers;
        var i4 = 0;
        var len = layers.length;
        while (i4 < len) {
          if (layers[i4].ind == parentName) {
            if (!elements[i4] || elements[i4] === true) {
              this.buildItem(i4);
              this.addPendingElement(element);
            } else {
              hierarchy.push(elements[i4]);
              elements[i4].setAsParent();
              if (layers[i4].parent !== void 0) {
                this.buildElementParenting(element, layers[i4].parent, hierarchy);
              } else {
                element.setHierarchy(hierarchy);
              }
            }
          }
          i4 += 1;
        }
      };
      BaseRenderer.prototype.addPendingElement = function(element) {
        this.pendingElements.push(element);
      };
      BaseRenderer.prototype.searchExtraCompositions = function(assets) {
        var i4;
        var len = assets.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (assets[i4].xt) {
            var comp2 = this.createComp(assets[i4]);
            comp2.initExpressions();
            this.globalData.projectInterface.registerComposition(comp2);
          }
        }
      };
      BaseRenderer.prototype.getElementById = function(ind) {
        var i4;
        var len = this.elements.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.elements[i4].data.ind === ind) {
            return this.elements[i4];
          }
        }
        return null;
      };
      BaseRenderer.prototype.getElementByPath = function(path) {
        var pathValue = path.shift();
        var element;
        if (typeof pathValue === "number") {
          element = this.elements[pathValue];
        } else {
          var i4;
          var len = this.elements.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (this.elements[i4].data.nm === pathValue) {
              element = this.elements[i4];
              break;
            }
          }
        }
        if (path.length === 0) {
          return element;
        }
        return element.getElementByPath(path);
      };
      BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
        this.globalData.fontManager = new FontManager();
        this.globalData.slotManager = slotFactory(animData);
        this.globalData.fontManager.addChars(animData.chars);
        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
        this.globalData.imageLoader = this.animationItem.imagePreloader;
        this.globalData.audioController = this.animationItem.audioController;
        this.globalData.frameId = 0;
        this.globalData.frameRate = animData.fr;
        this.globalData.nm = animData.nm;
        this.globalData.compSize = {
          w: animData.w,
          h: animData.h
        };
      };
      var effectTypes = {
        TRANSFORM_EFFECT: "transformEFfect"
      };
      function TransformElement() {
      }
      TransformElement.prototype = {
        initTransform: function initTransform() {
          var mat = new Matrix();
          this.finalTransform = {
            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
              o: 0
            },
            _matMdf: false,
            _localMatMdf: false,
            _opMdf: false,
            mat,
            localMat: mat,
            localOpacity: 1
          };
          if (this.data.ao) {
            this.finalTransform.mProp.autoOriented = true;
          }
          if (this.data.ty !== 11) {
          }
        },
        renderTransform: function renderTransform() {
          this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
          this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
          if (this.hierarchy) {
            var mat;
            var finalMat = this.finalTransform.mat;
            var i4 = 0;
            var len = this.hierarchy.length;
            if (!this.finalTransform._matMdf) {
              while (i4 < len) {
                if (this.hierarchy[i4].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = true;
                  break;
                }
                i4 += 1;
              }
            }
            if (this.finalTransform._matMdf) {
              mat = this.finalTransform.mProp.v.props;
              finalMat.cloneFromProps(mat);
              for (i4 = 0; i4 < len; i4 += 1) {
                finalMat.multiply(this.hierarchy[i4].finalTransform.mProp.v);
              }
            }
          }
          if (this.finalTransform._matMdf) {
            this.finalTransform._localMatMdf = this.finalTransform._matMdf;
          }
          if (this.finalTransform._opMdf) {
            this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
          }
        },
        renderLocalTransform: function renderLocalTransform() {
          if (this.localTransforms) {
            var i4 = 0;
            var len = this.localTransforms.length;
            this.finalTransform._localMatMdf = this.finalTransform._matMdf;
            if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
              while (i4 < len) {
                if (this.localTransforms[i4]._mdf) {
                  this.finalTransform._localMatMdf = true;
                }
                if (this.localTransforms[i4]._opMdf && !this.finalTransform._opMdf) {
                  this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                  this.finalTransform._opMdf = true;
                }
                i4 += 1;
              }
            }
            if (this.finalTransform._localMatMdf) {
              var localMat = this.finalTransform.localMat;
              this.localTransforms[0].matrix.clone(localMat);
              for (i4 = 1; i4 < len; i4 += 1) {
                var lmat = this.localTransforms[i4].matrix;
                localMat.multiply(lmat);
              }
              localMat.multiply(this.finalTransform.mat);
            }
            if (this.finalTransform._opMdf) {
              var localOp = this.finalTransform.localOpacity;
              for (i4 = 0; i4 < len; i4 += 1) {
                localOp *= this.localTransforms[i4].opacity * 0.01;
              }
              this.finalTransform.localOpacity = localOp;
            }
          }
        },
        searchEffectTransforms: function searchEffectTransforms() {
          if (this.renderableEffectsManager) {
            var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
            if (transformEffects.length) {
              this.localTransforms = [];
              this.finalTransform.localMat = new Matrix();
              var i4 = 0;
              var len = transformEffects.length;
              for (i4 = 0; i4 < len; i4 += 1) {
                this.localTransforms.push(transformEffects[i4]);
              }
            }
          }
        },
        globalToLocal: function globalToLocal(pt) {
          var transforms = [];
          transforms.push(this.finalTransform);
          var flag = true;
          var comp2 = this.comp;
          while (flag) {
            if (comp2.finalTransform) {
              if (comp2.data.hasMask) {
                transforms.splice(0, 0, comp2.finalTransform);
              }
              comp2 = comp2.comp;
            } else {
              flag = false;
            }
          }
          var i4;
          var len = transforms.length;
          var ptNew;
          for (i4 = 0; i4 < len; i4 += 1) {
            ptNew = transforms[i4].mat.applyToPointArray(0, 0, 0);
            pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
          }
          return pt;
        },
        mHelper: new Matrix()
      };
      function MaskElement(data2, element, globalData2) {
        this.data = data2;
        this.element = element;
        this.globalData = globalData2;
        this.storedData = [];
        this.masksProperties = this.data.masksProperties || [];
        this.maskElement = null;
        var defs = this.globalData.defs;
        var i4;
        var len = this.masksProperties ? this.masksProperties.length : 0;
        this.viewData = createSizedArray(len);
        this.solidPath = "";
        var path;
        var properties = this.masksProperties;
        var count = 0;
        var currentMasks = [];
        var j2;
        var jLen;
        var layerId = createElementID();
        var rect;
        var expansor;
        var feMorph;
        var x2;
        var maskType = "clipPath";
        var maskRef = "clip-path";
        for (i4 = 0; i4 < len; i4 += 1) {
          if (properties[i4].mode !== "a" && properties[i4].mode !== "n" || properties[i4].inv || properties[i4].o.k !== 100 || properties[i4].o.x) {
            maskType = "mask";
            maskRef = "mask";
          }
          if ((properties[i4].mode === "s" || properties[i4].mode === "i") && count === 0) {
            rect = createNS("rect");
            rect.setAttribute("fill", "#ffffff");
            rect.setAttribute("width", this.element.comp.data.w || 0);
            rect.setAttribute("height", this.element.comp.data.h || 0);
            currentMasks.push(rect);
          } else {
            rect = null;
          }
          path = createNS("path");
          if (properties[i4].mode === "n") {
            this.viewData[i4] = {
              op: PropertyFactory.getProp(this.element, properties[i4].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i4], 3),
              elem: path,
              lastPath: ""
            };
            defs.appendChild(path);
          } else {
            count += 1;
            path.setAttribute("fill", properties[i4].mode === "s" ? "#000000" : "#ffffff");
            path.setAttribute("clip-rule", "nonzero");
            var filterID;
            if (properties[i4].x.k !== 0) {
              maskType = "mask";
              maskRef = "mask";
              x2 = PropertyFactory.getProp(this.element, properties[i4].x, 0, null, this.element);
              filterID = createElementID();
              expansor = createNS("filter");
              expansor.setAttribute("id", filterID);
              feMorph = createNS("feMorphology");
              feMorph.setAttribute("operator", "erode");
              feMorph.setAttribute("in", "SourceGraphic");
              feMorph.setAttribute("radius", "0");
              expansor.appendChild(feMorph);
              defs.appendChild(expansor);
              path.setAttribute("stroke", properties[i4].mode === "s" ? "#000000" : "#ffffff");
            } else {
              feMorph = null;
              x2 = null;
            }
            this.storedData[i4] = {
              elem: path,
              x: x2,
              expan: feMorph,
              lastPath: "",
              lastOperator: "",
              filterId: filterID,
              lastRadius: 0
            };
            if (properties[i4].mode === "i") {
              jLen = currentMasks.length;
              var g2 = createNS("g");
              for (j2 = 0; j2 < jLen; j2 += 1) {
                g2.appendChild(currentMasks[j2]);
              }
              var mask2 = createNS("mask");
              mask2.setAttribute("mask-type", "alpha");
              mask2.setAttribute("id", layerId + "_" + count);
              mask2.appendChild(path);
              defs.appendChild(mask2);
              g2.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")");
              currentMasks.length = 0;
              currentMasks.push(g2);
            } else {
              currentMasks.push(path);
            }
            if (properties[i4].inv && !this.solidPath) {
              this.solidPath = this.createLayerSolidPath();
            }
            this.viewData[i4] = {
              elem: path,
              lastPath: "",
              op: PropertyFactory.getProp(this.element, properties[i4].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i4], 3),
              invRect: rect
            };
            if (!this.viewData[i4].prop.k) {
              this.drawPath(properties[i4], this.viewData[i4].prop.v, this.viewData[i4]);
            }
          }
        }
        this.maskElement = createNS(maskType);
        len = currentMasks.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.maskElement.appendChild(currentMasks[i4]);
        }
        if (count > 0) {
          this.maskElement.setAttribute("id", layerId);
          this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
          defs.appendChild(this.maskElement);
        }
        if (this.viewData.length) {
          this.element.addRenderableComponent(this);
        }
      }
      MaskElement.prototype.getMaskProperty = function(pos) {
        return this.viewData[pos].prop;
      };
      MaskElement.prototype.renderFrame = function(isFirstFrame) {
        var finalMat = this.element.finalTransform.mat;
        var i4;
        var len = this.masksProperties.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.viewData[i4].prop._mdf || isFirstFrame) {
            this.drawPath(this.masksProperties[i4], this.viewData[i4].prop.v, this.viewData[i4]);
          }
          if (this.viewData[i4].op._mdf || isFirstFrame) {
            this.viewData[i4].elem.setAttribute("fill-opacity", this.viewData[i4].op.v);
          }
          if (this.masksProperties[i4].mode !== "n") {
            if (this.viewData[i4].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
              this.viewData[i4].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
            }
            if (this.storedData[i4].x && (this.storedData[i4].x._mdf || isFirstFrame)) {
              var feMorph = this.storedData[i4].expan;
              if (this.storedData[i4].x.v < 0) {
                if (this.storedData[i4].lastOperator !== "erode") {
                  this.storedData[i4].lastOperator = "erode";
                  this.storedData[i4].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i4].filterId + ")");
                }
                feMorph.setAttribute("radius", -this.storedData[i4].x.v);
              } else {
                if (this.storedData[i4].lastOperator !== "dilate") {
                  this.storedData[i4].lastOperator = "dilate";
                  this.storedData[i4].elem.setAttribute("filter", null);
                }
                this.storedData[i4].elem.setAttribute("stroke-width", this.storedData[i4].x.v * 2);
              }
            }
          }
        }
      };
      MaskElement.prototype.getMaskelement = function() {
        return this.maskElement;
      };
      MaskElement.prototype.createLayerSolidPath = function() {
        var path = "M0,0 ";
        path += " h" + this.globalData.compSize.w;
        path += " v" + this.globalData.compSize.h;
        path += " h-" + this.globalData.compSize.w;
        path += " v-" + this.globalData.compSize.h + " ";
        return path;
      };
      MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
        var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        var i4;
        var len;
        len = pathNodes._length;
        for (i4 = 1; i4 < len; i4 += 1) {
          pathString += " C" + pathNodes.o[i4 - 1][0] + "," + pathNodes.o[i4 - 1][1] + " " + pathNodes.i[i4][0] + "," + pathNodes.i[i4][1] + " " + pathNodes.v[i4][0] + "," + pathNodes.v[i4][1];
        }
        if (pathNodes.c && len > 1) {
          pathString += " C" + pathNodes.o[i4 - 1][0] + "," + pathNodes.o[i4 - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        }
        if (viewData.lastPath !== pathString) {
          var pathShapeValue = "";
          if (viewData.elem) {
            if (pathNodes.c) {
              pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
            }
            viewData.elem.setAttribute("d", pathShapeValue);
          }
          viewData.lastPath = pathString;
        }
      };
      MaskElement.prototype.destroy = function() {
        this.element = null;
        this.globalData = null;
        this.maskElement = null;
        this.data = null;
        this.masksProperties = null;
      };
      var filtersFactory = function() {
        var ob2 = {};
        ob2.createFilter = createFilter;
        ob2.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
        function createFilter(filId, skipCoordinates) {
          var fil = createNS("filter");
          fil.setAttribute("id", filId);
          if (skipCoordinates !== true) {
            fil.setAttribute("filterUnits", "objectBoundingBox");
            fil.setAttribute("x", "0%");
            fil.setAttribute("y", "0%");
            fil.setAttribute("width", "100%");
            fil.setAttribute("height", "100%");
          }
          return fil;
        }
        function createAlphaToLuminanceFilter() {
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
          return feColorMatrix;
        }
        return ob2;
      }();
      var featureSupport = function() {
        var ob2 = {
          maskType: true,
          svgLumaHidden: true,
          offscreenCanvas: typeof OffscreenCanvas !== "undefined"
        };
        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
          ob2.maskType = false;
        }
        if (/firefox/i.test(navigator.userAgent)) {
          ob2.svgLumaHidden = false;
        }
        return ob2;
      }();
      var registeredEffects$1 = {};
      var idPrefix = "filter_result_";
      function SVGEffects(elem2) {
        var i4;
        var source = "SourceGraphic";
        var len = elem2.data.ef ? elem2.data.ef.length : 0;
        var filId = createElementID();
        var fil = filtersFactory.createFilter(filId, true);
        var count = 0;
        this.filters = [];
        var filterManager;
        for (i4 = 0; i4 < len; i4 += 1) {
          filterManager = null;
          var type = elem2.data.ef[i4].ty;
          if (registeredEffects$1[type]) {
            var Effect = registeredEffects$1[type].effect;
            filterManager = new Effect(fil, elem2.effectsManager.effectElements[i4], elem2, idPrefix + count, source);
            source = idPrefix + count;
            if (registeredEffects$1[type].countsAsEffect) {
              count += 1;
            }
          }
          if (filterManager) {
            this.filters.push(filterManager);
          }
        }
        if (count) {
          elem2.globalData.defs.appendChild(fil);
          elem2.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
        }
        if (this.filters.length) {
          elem2.addRenderableComponent(this);
        }
      }
      SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i4;
        var len = this.filters.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.filters[i4].renderFrame(_isFirstFrame);
        }
      };
      SVGEffects.prototype.getEffects = function(type) {
        var i4;
        var len = this.filters.length;
        var effects = [];
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.filters[i4].type === type) {
            effects.push(this.filters[i4]);
          }
        }
        return effects;
      };
      function registerEffect$1(id, effect2, countsAsEffect) {
        registeredEffects$1[id] = {
          effect: effect2,
          countsAsEffect
        };
      }
      function SVGBaseElement() {
      }
      SVGBaseElement.prototype = {
        initRendererElement: function initRendererElement() {
          this.layerElement = createNS("g");
        },
        createContainerElements: function createContainerElements() {
          this.matteElement = createNS("g");
          this.transformedElement = this.layerElement;
          this.maskedElement = this.layerElement;
          this._sizeChanged = false;
          var layerElementParent = null;
          if (this.data.td) {
            this.matteMasks = {};
            var gg = createNS("g");
            gg.setAttribute("id", this.layerId);
            gg.appendChild(this.layerElement);
            layerElementParent = gg;
            this.globalData.defs.appendChild(gg);
          } else if (this.data.tt) {
            this.matteElement.appendChild(this.layerElement);
            layerElementParent = this.matteElement;
            this.baseElement = this.matteElement;
          } else {
            this.baseElement = this.layerElement;
          }
          if (this.data.ln) {
            this.layerElement.setAttribute("id", this.data.ln);
          }
          if (this.data.cl) {
            this.layerElement.setAttribute("class", this.data.cl);
          }
          if (this.data.ty === 0 && !this.data.hd) {
            var cp = createNS("clipPath");
            var pt = createNS("path");
            pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
            var clipId = createElementID();
            cp.setAttribute("id", clipId);
            cp.appendChild(pt);
            this.globalData.defs.appendChild(cp);
            if (this.checkMasks()) {
              var cpGroup = createNS("g");
              cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
              cpGroup.appendChild(this.layerElement);
              this.transformedElement = cpGroup;
              if (layerElementParent) {
                layerElementParent.appendChild(this.transformedElement);
              } else {
                this.baseElement = this.transformedElement;
              }
            } else {
              this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
            }
          }
          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          if (this.finalTransform._localMatMdf) {
            this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS());
          }
          if (this.finalTransform._opMdf) {
            this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
          }
        },
        destroyBaseElement: function destroyBaseElement() {
          this.layerElement = null;
          this.matteElement = null;
          this.maskManager.destroy();
        },
        getBaseElement: function getBaseElement() {
          if (this.data.hd) {
            return null;
          }
          return this.baseElement;
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
          this.renderableEffectsManager = new SVGEffects(this);
          this.searchEffectTransforms();
        },
        getMatte: function getMatte(matteType) {
          if (!this.matteMasks) {
            this.matteMasks = {};
          }
          if (!this.matteMasks[matteType]) {
            var id = this.layerId + "_" + matteType;
            var filId;
            var fil;
            var useElement;
            var gg;
            if (matteType === 1 || matteType === 3) {
              var masker = createNS("mask");
              masker.setAttribute("id", id);
              masker.setAttribute("mask-type", matteType === 3 ? "luminance" : "alpha");
              useElement = createNS("use");
              useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
              masker.appendChild(useElement);
              this.globalData.defs.appendChild(masker);
              if (!featureSupport.maskType && matteType === 1) {
                masker.setAttribute("mask-type", "luminance");
                filId = createElementID();
                fil = filtersFactory.createFilter(filId);
                this.globalData.defs.appendChild(fil);
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS("g");
                gg.appendChild(useElement);
                masker.appendChild(gg);
                gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
              }
            } else if (matteType === 2) {
              var maskGroup = createNS("mask");
              maskGroup.setAttribute("id", id);
              maskGroup.setAttribute("mask-type", "alpha");
              var maskGrouper = createNS("g");
              maskGroup.appendChild(maskGrouper);
              filId = createElementID();
              fil = filtersFactory.createFilter(filId);
              var feCTr = createNS("feComponentTransfer");
              feCTr.setAttribute("in", "SourceGraphic");
              fil.appendChild(feCTr);
              var feFunc = createNS("feFuncA");
              feFunc.setAttribute("type", "table");
              feFunc.setAttribute("tableValues", "1.0 0.0");
              feCTr.appendChild(feFunc);
              this.globalData.defs.appendChild(fil);
              var alphaRect = createNS("rect");
              alphaRect.setAttribute("width", this.comp.data.w);
              alphaRect.setAttribute("height", this.comp.data.h);
              alphaRect.setAttribute("x", "0");
              alphaRect.setAttribute("y", "0");
              alphaRect.setAttribute("fill", "#ffffff");
              alphaRect.setAttribute("opacity", "0");
              maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
              maskGrouper.appendChild(alphaRect);
              useElement = createNS("use");
              useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
              maskGrouper.appendChild(useElement);
              if (!featureSupport.maskType) {
                maskGroup.setAttribute("mask-type", "luminance");
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS("g");
                maskGrouper.appendChild(alphaRect);
                gg.appendChild(this.layerElement);
                maskGrouper.appendChild(gg);
              }
              this.globalData.defs.appendChild(maskGroup);
            }
            this.matteMasks[matteType] = id;
          }
          return this.matteMasks[matteType];
        },
        setMatte: function setMatte(id) {
          if (!this.matteElement) {
            return;
          }
          this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
        }
      };
      function HierarchyElement() {
      }
      HierarchyElement.prototype = {
        /**
           * @function
           * Initializes hierarchy properties
           *
           */
        initHierarchy: function initHierarchy() {
          this.hierarchy = [];
          this._isParent = false;
          this.checkParenting();
        },
        /**
           * @function
           * Sets layer's hierarchy.
           * @param {array} hierarch
           * layer's parent list
           *
           */
        setHierarchy: function setHierarchy(hierarchy) {
          this.hierarchy = hierarchy;
        },
        /**
           * @function
           * Sets layer as parent.
           *
           */
        setAsParent: function setAsParent() {
          this._isParent = true;
        },
        /**
           * @function
           * Searches layer's parenting chain
           *
           */
        checkParenting: function checkParenting() {
          if (this.data.parent !== void 0) {
            this.comp.buildElementParenting(this, this.data.parent, []);
          }
        }
      };
      function RenderableDOMElement() {
      }
      (function() {
        var _prototype = {
          initElement: function initElement(data2, globalData2, comp2) {
            this.initFrame();
            this.initBaseData(data2, globalData2, comp2);
            this.initTransform(data2, globalData2, comp2);
            this.initHierarchy();
            this.initRenderable();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();
            this.createContent();
            this.hide();
          },
          hide: function hide() {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var elem2 = this.baseElement || this.layerElement;
              elem2.style.display = "none";
              this.hidden = true;
            }
          },
          show: function show() {
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var elem2 = this.baseElement || this.layerElement;
                elem2.style.display = "block";
              }
              this.hidden = false;
              this._isFirstFrame = true;
            }
          },
          renderFrame: function renderFrame() {
            if (this.data.hd || this.hidden) {
              return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderLocalTransform();
            this.renderElement();
            this.renderInnerContent();
            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          renderInnerContent: function renderInnerContent() {
          },
          prepareFrame: function prepareFrame(num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
            this.checkTransparency();
          },
          destroy: function destroy() {
            this.innerElem = null;
            this.destroyBaseElement();
          }
        };
        extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
      })();
      function IImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        if (this.assetData && this.assetData.sid) {
          this.assetData = globalData2.slotManager.getProp(this.assetData);
        }
        this.initElement(data2, globalData2, comp2);
        this.sourceRect = {
          top: 0,
          left: 0,
          width: this.assetData.w,
          height: this.assetData.h
        };
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
      IImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.innerElem = createNS("image");
        this.innerElem.setAttribute("width", this.assetData.w + "px");
        this.innerElem.setAttribute("height", this.assetData.h + "px");
        this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
        this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
        this.layerElement.appendChild(this.innerElem);
      };
      IImageElement.prototype.sourceRectAtTime = function() {
        return this.sourceRect;
      };
      function ProcessedElement(element, position2) {
        this.elem = element;
        this.pos = position2;
      }
      function IShapeElement() {
      }
      IShapeElement.prototype = {
        addShapeToModifiers: function addShapeToModifiers(data2) {
          var i4;
          var len = this.shapeModifiers.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            this.shapeModifiers[i4].addShape(data2);
          }
        },
        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data2) {
          var i4 = 0;
          var len = this.shapeModifiers.length;
          while (i4 < len) {
            if (this.shapeModifiers[i4].isAnimatedWithShape(data2)) {
              return true;
            }
          }
          return false;
        },
        renderModifiers: function renderModifiers() {
          if (!this.shapeModifiers.length) {
            return;
          }
          var i4;
          var len = this.shapes.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            this.shapes[i4].sh.reset();
          }
          len = this.shapeModifiers.length;
          var shouldBreakProcess;
          for (i4 = len - 1; i4 >= 0; i4 -= 1) {
            shouldBreakProcess = this.shapeModifiers[i4].processShapes(this._isFirstFrame);
            if (shouldBreakProcess) {
              break;
            }
          }
        },
        searchProcessedElement: function searchProcessedElement(elem2) {
          var elements = this.processedElements;
          var i4 = 0;
          var len = elements.length;
          while (i4 < len) {
            if (elements[i4].elem === elem2) {
              return elements[i4].pos;
            }
            i4 += 1;
          }
          return 0;
        },
        addProcessedElement: function addProcessedElement(elem2, pos) {
          var elements = this.processedElements;
          var i4 = elements.length;
          while (i4) {
            i4 -= 1;
            if (elements[i4].elem === elem2) {
              elements[i4].pos = pos;
              return;
            }
          }
          elements.push(new ProcessedElement(elem2, pos));
        },
        prepareFrame: function prepareFrame(num) {
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
        }
      };
      var lineCapEnum = {
        1: "butt",
        2: "round",
        3: "square"
      };
      var lineJoinEnum = {
        1: "miter",
        2: "round",
        3: "bevel"
      };
      function SVGShapeData(transformers, level, shape) {
        this.caches = [];
        this.styles = [];
        this.transformers = transformers;
        this.lStr = "";
        this.sh = shape;
        this.lvl = level;
        this._isAnimated = !!shape.k;
        var i4 = 0;
        var len = transformers.length;
        while (i4 < len) {
          if (transformers[i4].mProps.dynamicProperties.length) {
            this._isAnimated = true;
            break;
          }
          i4 += 1;
        }
      }
      SVGShapeData.prototype.setAsAnimated = function() {
        this._isAnimated = true;
      };
      function SVGStyleData(data2, level) {
        this.data = data2;
        this.type = data2.ty;
        this.d = "";
        this.lvl = level;
        this._mdf = false;
        this.closed = data2.hd === true;
        this.pElem = createNS("path");
        this.msElem = null;
      }
      SVGStyleData.prototype.reset = function() {
        this.d = "";
        this._mdf = false;
      };
      function DashProperty(elem2, data2, renderer2, container) {
        this.elem = elem2;
        this.frameId = -1;
        this.dataProps = createSizedArray(data2.length);
        this.renderer = renderer2;
        this.k = false;
        this.dashStr = "";
        this.dashArray = createTypedArray("float32", data2.length ? data2.length - 1 : 0);
        this.dashoffset = createTypedArray("float32", 1);
        this.initDynamicPropertyContainer(container);
        var i4;
        var len = data2.length || 0;
        var prop;
        for (i4 = 0; i4 < len; i4 += 1) {
          prop = PropertyFactory.getProp(elem2, data2[i4].v, 0, 0, this);
          this.k = prop.k || this.k;
          this.dataProps[i4] = {
            n: data2[i4].n,
            p: prop
          };
        }
        if (!this.k) {
          this.getValue(true);
        }
        this._isAnimated = this.k;
      }
      DashProperty.prototype.getValue = function(forceRender) {
        if (this.elem.globalData.frameId === this.frameId && !forceRender) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || forceRender;
        if (this._mdf) {
          var i4 = 0;
          var len = this.dataProps.length;
          if (this.renderer === "svg") {
            this.dashStr = "";
          }
          for (i4 = 0; i4 < len; i4 += 1) {
            if (this.dataProps[i4].n !== "o") {
              if (this.renderer === "svg") {
                this.dashStr += " " + this.dataProps[i4].p.v;
              } else {
                this.dashArray[i4] = this.dataProps[i4].p.v;
              }
            } else {
              this.dashoffset[0] = this.dataProps[i4].p.v;
            }
          }
        }
      };
      extendPrototype([DynamicPropertyContainer], DashProperty);
      function SVGStrokeStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
        this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
        this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
        this.style = styleOb;
        this._isAnimated = !!this._isAnimated;
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
      function SVGFillStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
        this.style = styleOb;
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
      function SVGNoStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.style = styleOb;
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
      function GradientProperty(elem2, data2, container) {
        this.data = data2;
        this.c = createTypedArray("uint8c", data2.p * 4);
        var cLength = data2.k.k[0].s ? data2.k.k[0].s.length - data2.p * 4 : data2.k.k.length - data2.p * 4;
        this.o = createTypedArray("float32", cLength);
        this._cmdf = false;
        this._omdf = false;
        this._collapsable = this.checkCollapsable();
        this._hasOpacity = cLength;
        this.initDynamicPropertyContainer(container);
        this.prop = PropertyFactory.getProp(elem2, data2.k, 1, null, this);
        this.k = this.prop.k;
        this.getValue(true);
      }
      GradientProperty.prototype.comparePoints = function(values, points) {
        var i4 = 0;
        var len = this.o.length / 2;
        var diff;
        while (i4 < len) {
          diff = Math.abs(values[i4 * 4] - values[points * 4 + i4 * 2]);
          if (diff > 0.01) {
            return false;
          }
          i4 += 1;
        }
        return true;
      };
      GradientProperty.prototype.checkCollapsable = function() {
        if (this.o.length / 2 !== this.c.length / 4) {
          return false;
        }
        if (this.data.k.k[0].s) {
          var i4 = 0;
          var len = this.data.k.k.length;
          while (i4 < len) {
            if (!this.comparePoints(this.data.k.k[i4].s, this.data.p)) {
              return false;
            }
            i4 += 1;
          }
        } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
          return false;
        }
        return true;
      };
      GradientProperty.prototype.getValue = function(forceRender) {
        this.prop.getValue();
        this._mdf = false;
        this._cmdf = false;
        this._omdf = false;
        if (this.prop._mdf || forceRender) {
          var i4;
          var len = this.data.p * 4;
          var mult;
          var val2;
          for (i4 = 0; i4 < len; i4 += 1) {
            mult = i4 % 4 === 0 ? 100 : 255;
            val2 = Math.round(this.prop.v[i4] * mult);
            if (this.c[i4] !== val2) {
              this.c[i4] = val2;
              this._cmdf = !forceRender;
            }
          }
          if (this.o.length) {
            len = this.prop.v.length;
            for (i4 = this.data.p * 4; i4 < len; i4 += 1) {
              mult = i4 % 2 === 0 ? 100 : 1;
              val2 = i4 % 2 === 0 ? Math.round(this.prop.v[i4] * 100) : this.prop.v[i4];
              if (this.o[i4 - this.data.p * 4] !== val2) {
                this.o[i4 - this.data.p * 4] = val2;
                this._omdf = !forceRender;
              }
            }
          }
          this._mdf = !forceRender;
        }
      };
      extendPrototype([DynamicPropertyContainer], GradientProperty);
      function SVGGradientFillStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.initGradientData(elem2, data2, styleOb);
      }
      SVGGradientFillStyleData.prototype.initGradientData = function(elem2, data2, styleOb) {
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.s = PropertyFactory.getProp(elem2, data2.s, 1, null, this);
        this.e = PropertyFactory.getProp(elem2, data2.e, 1, null, this);
        this.h = PropertyFactory.getProp(elem2, data2.h || {
          k: 0
        }, 0, 0.01, this);
        this.a = PropertyFactory.getProp(elem2, data2.a || {
          k: 0
        }, 0, degToRads, this);
        this.g = new GradientProperty(elem2, data2.g, this);
        this.style = styleOb;
        this.stops = [];
        this.setGradientData(styleOb.pElem, data2);
        this.setGradientOpacity(data2, styleOb);
        this._isAnimated = !!this._isAnimated;
      };
      SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data2) {
        var gradientId = createElementID();
        var gfill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
        gfill.setAttribute("id", gradientId);
        gfill.setAttribute("spreadMethod", "pad");
        gfill.setAttribute("gradientUnits", "userSpaceOnUse");
        var stops = [];
        var stop;
        var j2;
        var jLen;
        jLen = data2.g.p * 4;
        for (j2 = 0; j2 < jLen; j2 += 4) {
          stop = createNS("stop");
          gfill.appendChild(stop);
          stops.push(stop);
        }
        pathElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
        this.gf = gfill;
        this.cst = stops;
      };
      SVGGradientFillStyleData.prototype.setGradientOpacity = function(data2, styleOb) {
        if (this.g._hasOpacity && !this.g._collapsable) {
          var stop;
          var j2;
          var jLen;
          var mask2 = createNS("mask");
          var maskElement = createNS("path");
          mask2.appendChild(maskElement);
          var opacityId = createElementID();
          var maskId = createElementID();
          mask2.setAttribute("id", maskId);
          var opFill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
          opFill.setAttribute("id", opacityId);
          opFill.setAttribute("spreadMethod", "pad");
          opFill.setAttribute("gradientUnits", "userSpaceOnUse");
          jLen = data2.g.k.k[0].s ? data2.g.k.k[0].s.length : data2.g.k.k.length;
          var stops = this.stops;
          for (j2 = data2.g.p * 4; j2 < jLen; j2 += 2) {
            stop = createNS("stop");
            stop.setAttribute("stop-color", "rgb(255,255,255)");
            opFill.appendChild(stop);
            stops.push(stop);
          }
          maskElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
          if (data2.ty === "gs") {
            maskElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
            maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
            if (data2.lj === 1) {
              maskElement.setAttribute("stroke-miterlimit", data2.ml);
            }
          }
          this.of = opFill;
          this.ms = mask2;
          this.ost = stops;
          this.maskId = maskId;
          styleOb.msElem = maskElement;
        }
      };
      extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
      function SVGGradientStrokeStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
        this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
        this.initGradientData(elem2, data2, styleOb);
        this._isAnimated = !!this._isAnimated;
      }
      extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
      function ShapeGroupData() {
        this.it = [];
        this.prevViewData = [];
        this.gr = createNS("g");
      }
      function SVGTransformData(mProps, op, container) {
        this.transform = {
          mProps,
          op,
          container
        };
        this.elements = [];
        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
      }
      var buildShapeString = function buildShapeString2(pathNodes, length2, closed, mat) {
        if (length2 === 0) {
          return "";
        }
        var _o = pathNodes.o;
        var _i = pathNodes.i;
        var _v = pathNodes.v;
        var i4;
        var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
        for (i4 = 1; i4 < length2; i4 += 1) {
          shapeString += " C" + mat.applyToPointStringified(_o[i4 - 1][0], _o[i4 - 1][1]) + " " + mat.applyToPointStringified(_i[i4][0], _i[i4][1]) + " " + mat.applyToPointStringified(_v[i4][0], _v[i4][1]);
        }
        if (closed && length2) {
          shapeString += " C" + mat.applyToPointStringified(_o[i4 - 1][0], _o[i4 - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
          shapeString += "z";
        }
        return shapeString;
      };
      var SVGElementsRenderer = function() {
        var _identityMatrix = new Matrix();
        var _matrixHelper = new Matrix();
        var ob2 = {
          createRenderFunction
        };
        function createRenderFunction(data2) {
          switch (data2.ty) {
            case "fl":
              return renderFill;
            case "gf":
              return renderGradient;
            case "gs":
              return renderGradientStroke;
            case "st":
              return renderStroke;
            case "sh":
            case "el":
            case "rc":
            case "sr":
              return renderPath;
            case "tr":
              return renderContentTransform;
            case "no":
              return renderNoop;
            default:
              return null;
          }
        }
        function renderContentTransform(styleData, itemData, isFirstFrame) {
          if (isFirstFrame || itemData.transform.op._mdf) {
            itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
          }
          if (isFirstFrame || itemData.transform.mProps._mdf) {
            itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
          }
        }
        function renderNoop() {
        }
        function renderPath(styleData, itemData, isFirstFrame) {
          var j2;
          var jLen;
          var pathStringTransformed;
          var redraw;
          var pathNodes;
          var l3;
          var lLen = itemData.styles.length;
          var lvl = itemData.lvl;
          var paths;
          var mat;
          var iterations;
          var k2;
          for (l3 = 0; l3 < lLen; l3 += 1) {
            redraw = itemData.sh._mdf || isFirstFrame;
            if (itemData.styles[l3].lvl < lvl) {
              mat = _matrixHelper.reset();
              iterations = lvl - itemData.styles[l3].lvl;
              k2 = itemData.transformers.length - 1;
              while (!redraw && iterations > 0) {
                redraw = itemData.transformers[k2].mProps._mdf || redraw;
                iterations -= 1;
                k2 -= 1;
              }
              if (redraw) {
                iterations = lvl - itemData.styles[l3].lvl;
                k2 = itemData.transformers.length - 1;
                while (iterations > 0) {
                  mat.multiply(itemData.transformers[k2].mProps.v);
                  iterations -= 1;
                  k2 -= 1;
                }
              }
            } else {
              mat = _identityMatrix;
            }
            paths = itemData.sh.paths;
            jLen = paths._length;
            if (redraw) {
              pathStringTransformed = "";
              for (j2 = 0; j2 < jLen; j2 += 1) {
                pathNodes = paths.shapes[j2];
                if (pathNodes && pathNodes._length) {
                  pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                }
              }
              itemData.caches[l3] = pathStringTransformed;
            } else {
              pathStringTransformed = itemData.caches[l3];
            }
            itemData.styles[l3].d += styleData.hd === true ? "" : pathStringTransformed;
            itemData.styles[l3]._mdf = redraw || itemData.styles[l3]._mdf;
          }
        }
        function renderFill(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          if (itemData.c._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
          }
          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
          }
        }
        function renderGradientStroke(styleData, itemData, isFirstFrame) {
          renderGradient(styleData, itemData, isFirstFrame);
          renderStroke(styleData, itemData, isFirstFrame);
        }
        function renderGradient(styleData, itemData, isFirstFrame) {
          var gfill = itemData.gf;
          var hasOpacity = itemData.g._hasOpacity;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;
          if (itemData.o._mdf || isFirstFrame) {
            var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
            itemData.style.pElem.setAttribute(attr, itemData.o.v);
          }
          if (itemData.s._mdf || isFirstFrame) {
            var attr1 = styleData.t === 1 ? "x1" : "cx";
            var attr2 = attr1 === "x1" ? "y1" : "cy";
            gfill.setAttribute(attr1, pt1[0]);
            gfill.setAttribute(attr2, pt1[1]);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute(attr1, pt1[0]);
              itemData.of.setAttribute(attr2, pt1[1]);
            }
          }
          var stops;
          var i4;
          var len;
          var stop;
          if (itemData.g._cmdf || isFirstFrame) {
            stops = itemData.cst;
            var cValues = itemData.g.c;
            len = stops.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              stop = stops[i4];
              stop.setAttribute("offset", cValues[i4 * 4] + "%");
              stop.setAttribute("stop-color", "rgb(" + cValues[i4 * 4 + 1] + "," + cValues[i4 * 4 + 2] + "," + cValues[i4 * 4 + 3] + ")");
            }
          }
          if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
            var oValues = itemData.g.o;
            if (itemData.g._collapsable) {
              stops = itemData.cst;
            } else {
              stops = itemData.ost;
            }
            len = stops.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              stop = stops[i4];
              if (!itemData.g._collapsable) {
                stop.setAttribute("offset", oValues[i4 * 2] + "%");
              }
              stop.setAttribute("stop-opacity", oValues[i4 * 2 + 1]);
            }
          }
          if (styleData.t === 1) {
            if (itemData.e._mdf || isFirstFrame) {
              gfill.setAttribute("x2", pt2[0]);
              gfill.setAttribute("y2", pt2[1]);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("x2", pt2[0]);
                itemData.of.setAttribute("y2", pt2[1]);
              }
            }
          } else {
            var rad;
            if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
              rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              gfill.setAttribute("r", rad);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("r", rad);
              }
            }
            if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
              if (!rad) {
                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              }
              var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
              var percent = itemData.h.v;
              if (percent >= 1) {
                percent = 0.99;
              } else if (percent <= -1) {
                percent = -0.99;
              }
              var dist = rad * percent;
              var x2 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
              var y2 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
              gfill.setAttribute("fx", x2);
              gfill.setAttribute("fy", y2);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("fx", x2);
                itemData.of.setAttribute("fy", y2);
              }
            }
          }
        }
        function renderStroke(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          var d2 = itemData.d;
          if (d2 && (d2._mdf || isFirstFrame) && d2.dashStr) {
            styleElem.pElem.setAttribute("stroke-dasharray", d2.dashStr);
            styleElem.pElem.setAttribute("stroke-dashoffset", d2.dashoffset[0]);
          }
          if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
            styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
          }
          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
          }
          if (itemData.w._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
            if (styleElem.msElem) {
              styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
            }
          }
        }
        return ob2;
      }();
      function SVGShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.shapeModifiers = [];
        this.itemsData = [];
        this.processedElements = [];
        this.animatedContents = [];
        this.initElement(data2, globalData2, comp2);
        this.prevViewData = [];
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
      SVGShapeElement.prototype.initSecondaryElement = function() {
      };
      SVGShapeElement.prototype.identityMatrix = new Matrix();
      SVGShapeElement.prototype.buildExpressionInterface = function() {
      };
      SVGShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
      };
      SVGShapeElement.prototype.filterUniqueShapes = function() {
        var i4;
        var len = this.shapes.length;
        var shape;
        var j2;
        var jLen = this.stylesList.length;
        var style;
        var tempShapes = [];
        var areAnimated = false;
        for (j2 = 0; j2 < jLen; j2 += 1) {
          style = this.stylesList[j2];
          areAnimated = false;
          tempShapes.length = 0;
          for (i4 = 0; i4 < len; i4 += 1) {
            shape = this.shapes[i4];
            if (shape.styles.indexOf(style) !== -1) {
              tempShapes.push(shape);
              areAnimated = shape._isAnimated || areAnimated;
            }
          }
          if (tempShapes.length > 1 && areAnimated) {
            this.setShapesAsAnimated(tempShapes);
          }
        }
      };
      SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
        var i4;
        var len = shapes.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          shapes[i4].setAsAnimated();
        }
      };
      SVGShapeElement.prototype.createStyleElement = function(data2, level) {
        var elementData;
        var styleOb = new SVGStyleData(data2, level);
        var pathElement = styleOb.pElem;
        if (data2.ty === "st") {
          elementData = new SVGStrokeStyleData(this, data2, styleOb);
        } else if (data2.ty === "fl") {
          elementData = new SVGFillStyleData(this, data2, styleOb);
        } else if (data2.ty === "gf" || data2.ty === "gs") {
          var GradientConstructor = data2.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
          elementData = new GradientConstructor(this, data2, styleOb);
          this.globalData.defs.appendChild(elementData.gf);
          if (elementData.maskId) {
            this.globalData.defs.appendChild(elementData.ms);
            this.globalData.defs.appendChild(elementData.of);
            pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
          }
        } else if (data2.ty === "no") {
          elementData = new SVGNoStyleData(this, data2, styleOb);
        }
        if (data2.ty === "st" || data2.ty === "gs") {
          pathElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
          pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
          pathElement.setAttribute("fill-opacity", "0");
          if (data2.lj === 1) {
            pathElement.setAttribute("stroke-miterlimit", data2.ml);
          }
        }
        if (data2.r === 2) {
          pathElement.setAttribute("fill-rule", "evenodd");
        }
        if (data2.ln) {
          pathElement.setAttribute("id", data2.ln);
        }
        if (data2.cl) {
          pathElement.setAttribute("class", data2.cl);
        }
        if (data2.bm) {
          pathElement.style["mix-blend-mode"] = getBlendMode(data2.bm);
        }
        this.stylesList.push(styleOb);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.createGroupElement = function(data2) {
        var elementData = new ShapeGroupData();
        if (data2.ln) {
          elementData.gr.setAttribute("id", data2.ln);
        }
        if (data2.cl) {
          elementData.gr.setAttribute("class", data2.cl);
        }
        if (data2.bm) {
          elementData.gr.style["mix-blend-mode"] = getBlendMode(data2.bm);
        }
        return elementData;
      };
      SVGShapeElement.prototype.createTransformElement = function(data2, container) {
        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data2, this);
        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.createShapeElement = function(data2, ownTransformers, level) {
        var ty = 4;
        if (data2.ty === "rc") {
          ty = 5;
        } else if (data2.ty === "el") {
          ty = 6;
        } else if (data2.ty === "sr") {
          ty = 7;
        }
        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data2, ty, this);
        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.addToAnimatedContents = function(data2, element) {
        var i4 = 0;
        var len = this.animatedContents.length;
        while (i4 < len) {
          if (this.animatedContents[i4].element === element) {
            return;
          }
          i4 += 1;
        }
        this.animatedContents.push({
          fn: SVGElementsRenderer.createRenderFunction(data2),
          element,
          data: data2
        });
      };
      SVGShapeElement.prototype.setElementStyles = function(elementData) {
        var arr = elementData.styles;
        var j2;
        var jLen = this.stylesList.length;
        for (j2 = 0; j2 < jLen; j2 += 1) {
          if (!this.stylesList[j2].closed) {
            arr.push(this.stylesList[j2]);
          }
        }
      };
      SVGShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i4;
        var len = this.itemsData.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.prevViewData[i4] = this.itemsData[i4];
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
        len = this.dynamicProperties.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.dynamicProperties[i4].getValue();
        }
        this.renderModifiers();
      };
      SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {
        var ownTransformers = [].concat(transformers);
        var i4;
        var len = arr.length - 1;
        var j2;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var currentTransform;
        var modifier;
        var processedPos;
        for (i4 = len; i4 >= 0; i4 -= 1) {
          processedPos = this.searchProcessedElement(arr[i4]);
          if (!processedPos) {
            arr[i4]._render = render;
          } else {
            itemsData[i4] = prevViewData[processedPos - 1];
          }
          if (arr[i4].ty === "fl" || arr[i4].ty === "st" || arr[i4].ty === "gf" || arr[i4].ty === "gs" || arr[i4].ty === "no") {
            if (!processedPos) {
              itemsData[i4] = this.createStyleElement(arr[i4], level);
            } else {
              itemsData[i4].style.closed = false;
            }
            if (arr[i4]._render) {
              if (itemsData[i4].style.pElem.parentNode !== container) {
                container.appendChild(itemsData[i4].style.pElem);
              }
            }
            ownStyles.push(itemsData[i4].style);
          } else if (arr[i4].ty === "gr") {
            if (!processedPos) {
              itemsData[i4] = this.createGroupElement(arr[i4]);
            } else {
              jLen = itemsData[i4].it.length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                itemsData[i4].prevViewData[j2] = itemsData[i4].it[j2];
              }
            }
            this.searchShapes(arr[i4].it, itemsData[i4].it, itemsData[i4].prevViewData, itemsData[i4].gr, level + 1, ownTransformers, render);
            if (arr[i4]._render) {
              if (itemsData[i4].gr.parentNode !== container) {
                container.appendChild(itemsData[i4].gr);
              }
            }
          } else if (arr[i4].ty === "tr") {
            if (!processedPos) {
              itemsData[i4] = this.createTransformElement(arr[i4], container);
            }
            currentTransform = itemsData[i4].transform;
            ownTransformers.push(currentTransform);
          } else if (arr[i4].ty === "sh" || arr[i4].ty === "rc" || arr[i4].ty === "el" || arr[i4].ty === "sr") {
            if (!processedPos) {
              itemsData[i4] = this.createShapeElement(arr[i4], ownTransformers, level);
            }
            this.setElementStyles(itemsData[i4]);
          } else if (arr[i4].ty === "tm" || arr[i4].ty === "rd" || arr[i4].ty === "ms" || arr[i4].ty === "pb" || arr[i4].ty === "zz" || arr[i4].ty === "op") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i4].ty);
              modifier.init(this, arr[i4]);
              itemsData[i4] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i4];
              modifier.closed = false;
            }
            ownModifiers.push(modifier);
          } else if (arr[i4].ty === "rp") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i4].ty);
              itemsData[i4] = modifier;
              modifier.init(this, arr, i4, itemsData);
              this.shapeModifiers.push(modifier);
              render = false;
            } else {
              modifier = itemsData[i4];
              modifier.closed = true;
            }
            ownModifiers.push(modifier);
          }
          this.addProcessedElement(arr[i4], i4 + 1);
        }
        len = ownStyles.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          ownStyles[i4].closed = true;
        }
        len = ownModifiers.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          ownModifiers[i4].closed = true;
        }
      };
      SVGShapeElement.prototype.renderInnerContent = function() {
        this.renderModifiers();
        var i4;
        var len = this.stylesList.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.stylesList[i4].reset();
        }
        this.renderShape();
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.stylesList[i4]._mdf || this._isFirstFrame) {
            if (this.stylesList[i4].msElem) {
              this.stylesList[i4].msElem.setAttribute("d", this.stylesList[i4].d);
              this.stylesList[i4].d = "M0 0" + this.stylesList[i4].d;
            }
            this.stylesList[i4].pElem.setAttribute("d", this.stylesList[i4].d || "M0 0");
          }
        }
      };
      SVGShapeElement.prototype.renderShape = function() {
        var i4;
        var len = this.animatedContents.length;
        var animatedContent;
        for (i4 = 0; i4 < len; i4 += 1) {
          animatedContent = this.animatedContents[i4];
          if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
            animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
          }
        }
      };
      SVGShapeElement.prototype.destroy = function() {
        this.destroyBaseElement();
        this.shapesData = null;
        this.itemsData = null;
      };
      function LetterProps(o4, sw, sc, fc, m3, p2) {
        this.o = o4;
        this.sw = sw;
        this.sc = sc;
        this.fc = fc;
        this.m = m3;
        this.p = p2;
        this._mdf = {
          o: true,
          sw: !!sw,
          sc: !!sc,
          fc: !!fc,
          m: true,
          p: true
        };
      }
      LetterProps.prototype.update = function(o4, sw, sc, fc, m3, p2) {
        this._mdf.o = false;
        this._mdf.sw = false;
        this._mdf.sc = false;
        this._mdf.fc = false;
        this._mdf.m = false;
        this._mdf.p = false;
        var updated = false;
        if (this.o !== o4) {
          this.o = o4;
          this._mdf.o = true;
          updated = true;
        }
        if (this.sw !== sw) {
          this.sw = sw;
          this._mdf.sw = true;
          updated = true;
        }
        if (this.sc !== sc) {
          this.sc = sc;
          this._mdf.sc = true;
          updated = true;
        }
        if (this.fc !== fc) {
          this.fc = fc;
          this._mdf.fc = true;
          updated = true;
        }
        if (this.m !== m3) {
          this.m = m3;
          this._mdf.m = true;
          updated = true;
        }
        if (p2.length && (this.p[0] !== p2[0] || this.p[1] !== p2[1] || this.p[4] !== p2[4] || this.p[5] !== p2[5] || this.p[12] !== p2[12] || this.p[13] !== p2[13])) {
          this.p = p2;
          this._mdf.p = true;
          updated = true;
        }
        return updated;
      };
      function TextProperty(elem2, data2) {
        this._frameId = initialDefaultFrame;
        this.pv = "";
        this.v = "";
        this.kf = false;
        this._isFirstFrame = true;
        this._mdf = false;
        if (data2.d && data2.d.sid) {
          data2.d = elem2.globalData.slotManager.getProp(data2.d);
        }
        this.data = data2;
        this.elem = elem2;
        this.comp = this.elem.comp;
        this.keysIndex = 0;
        this.canResize = false;
        this.minimumFontSize = 1;
        this.effectsSequence = [];
        this.currentData = {
          ascent: 0,
          boxWidth: this.defaultBoxWidth,
          f: "",
          fStyle: "",
          fWeight: "",
          fc: "",
          j: "",
          justifyOffset: "",
          l: [],
          lh: 0,
          lineWidths: [],
          ls: "",
          of: "",
          s: "",
          sc: "",
          sw: 0,
          t: 0,
          tr: 0,
          sz: 0,
          ps: null,
          fillColorAnim: false,
          strokeColorAnim: false,
          strokeWidthAnim: false,
          yOffset: 0,
          finalSize: 0,
          finalText: [],
          finalLineHeight: 0,
          __complete: false
        };
        this.copyData(this.currentData, this.data.d.k[0].s);
        if (!this.searchProperty()) {
          this.completeTextData(this.currentData);
        }
      }
      TextProperty.prototype.defaultBoxWidth = [0, 0];
      TextProperty.prototype.copyData = function(obj, data2) {
        for (var s2 in data2) {
          if (Object.prototype.hasOwnProperty.call(data2, s2)) {
            obj[s2] = data2[s2];
          }
        }
        return obj;
      };
      TextProperty.prototype.setCurrentData = function(data2) {
        if (!data2.__complete) {
          this.completeTextData(data2);
        }
        this.currentData = data2;
        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
        this._mdf = true;
      };
      TextProperty.prototype.searchProperty = function() {
        return this.searchKeyframes();
      };
      TextProperty.prototype.searchKeyframes = function() {
        this.kf = this.data.d.k.length > 1;
        if (this.kf) {
          this.addEffect(this.getKeyframeValue.bind(this));
        }
        return this.kf;
      };
      TextProperty.prototype.addEffect = function(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.getValue = function(_finalValue) {
        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
          return;
        }
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var currentValue = this.currentData;
        var currentIndex = this.keysIndex;
        if (this.lock) {
          this.setCurrentData(this.currentData);
          return;
        }
        this.lock = true;
        this._mdf = false;
        var i4;
        var len = this.effectsSequence.length;
        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (currentIndex !== this.keysIndex) {
            finalValue = this.effectsSequence[i4](finalValue, finalValue.t);
          } else {
            finalValue = this.effectsSequence[i4](this.currentData, finalValue.t);
          }
        }
        if (currentValue !== finalValue) {
          this.setCurrentData(finalValue);
        }
        this.v = this.currentData;
        this.pv = this.v;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      };
      TextProperty.prototype.getKeyframeValue = function() {
        var textKeys = this.data.d.k;
        var frameNum = this.elem.comp.renderedFrame;
        var i4 = 0;
        var len = textKeys.length;
        while (i4 <= len - 1) {
          if (i4 === len - 1 || textKeys[i4 + 1].t > frameNum) {
            break;
          }
          i4 += 1;
        }
        if (this.keysIndex !== i4) {
          this.keysIndex = i4;
        }
        return this.data.d.k[this.keysIndex].s;
      };
      TextProperty.prototype.buildFinalText = function(text2) {
        var charactersArray = [];
        var i4 = 0;
        var len = text2.length;
        var charCode;
        var secondCharCode;
        var shouldCombine = false;
        var shouldCombineNext = false;
        var currentChars = "";
        while (i4 < len) {
          shouldCombine = shouldCombineNext;
          shouldCombineNext = false;
          charCode = text2.charCodeAt(i4);
          currentChars = text2.charAt(i4);
          if (FontManager.isCombinedCharacter(charCode)) {
            shouldCombine = true;
          } else if (charCode >= 55296 && charCode <= 56319) {
            if (FontManager.isRegionalFlag(text2, i4)) {
              currentChars = text2.substr(i4, 14);
            } else {
              secondCharCode = text2.charCodeAt(i4 + 1);
              if (secondCharCode >= 56320 && secondCharCode <= 57343) {
                if (FontManager.isModifier(charCode, secondCharCode)) {
                  currentChars = text2.substr(i4, 2);
                  shouldCombine = true;
                } else if (FontManager.isFlagEmoji(text2.substr(i4, 4))) {
                  currentChars = text2.substr(i4, 4);
                } else {
                  currentChars = text2.substr(i4, 2);
                }
              }
            }
          } else if (charCode > 56319) {
            secondCharCode = text2.charCodeAt(i4 + 1);
            if (FontManager.isVariationSelector(charCode)) {
              shouldCombine = true;
            }
          } else if (FontManager.isZeroWidthJoiner(charCode)) {
            shouldCombine = true;
            shouldCombineNext = true;
          }
          if (shouldCombine) {
            charactersArray[charactersArray.length - 1] += currentChars;
            shouldCombine = false;
          } else {
            charactersArray.push(currentChars);
          }
          i4 += currentChars.length;
        }
        return charactersArray;
      };
      TextProperty.prototype.completeTextData = function(documentData) {
        documentData.__complete = true;
        var fontManager = this.elem.globalData.fontManager;
        var data2 = this.data;
        var letters = [];
        var i4;
        var len;
        var newLineFlag;
        var index2 = 0;
        var val2;
        var anchorGrouping = data2.m.g;
        var currentSize = 0;
        var currentPos = 0;
        var currentLine = 0;
        var lineWidths = [];
        var lineWidth = 0;
        var maxLineWidth = 0;
        var j2;
        var jLen;
        var fontData = fontManager.getFontByName(documentData.f);
        var charData;
        var cLength = 0;
        var fontProps = getFontProperties(fontData);
        documentData.fWeight = fontProps.weight;
        documentData.fStyle = fontProps.style;
        documentData.finalSize = documentData.s;
        documentData.finalText = this.buildFinalText(documentData.t);
        len = documentData.finalText.length;
        documentData.finalLineHeight = documentData.lh;
        var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
        var charCode;
        if (documentData.sz) {
          var flag = true;
          var boxWidth = documentData.sz[0];
          var boxHeight = documentData.sz[1];
          var currentHeight;
          var finalText;
          while (flag) {
            finalText = this.buildFinalText(documentData.t);
            currentHeight = 0;
            lineWidth = 0;
            len = finalText.length;
            trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
            var lastSpaceIndex = -1;
            for (i4 = 0; i4 < len; i4 += 1) {
              charCode = finalText[i4].charCodeAt(0);
              newLineFlag = false;
              if (finalText[i4] === " ") {
                lastSpaceIndex = i4;
              } else if (charCode === 13 || charCode === 3) {
                lineWidth = 0;
                newLineFlag = true;
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
              }
              if (fontManager.chars) {
                charData = fontManager.getCharData(finalText[i4], fontData.fStyle, fontData.fFamily);
                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
              } else {
                cLength = fontManager.measureText(finalText[i4], documentData.f, documentData.finalSize);
              }
              if (lineWidth + cLength > boxWidth && finalText[i4] !== " ") {
                if (lastSpaceIndex === -1) {
                  len += 1;
                } else {
                  i4 = lastSpaceIndex;
                }
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                finalText.splice(i4, lastSpaceIndex === i4 ? 1 : 0, "\r");
                lastSpaceIndex = -1;
                lineWidth = 0;
              } else {
                lineWidth += cLength;
                lineWidth += trackingOffset;
              }
            }
            currentHeight += fontData.ascent * documentData.finalSize / 100;
            if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
              documentData.finalSize -= 1;
              documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
            } else {
              documentData.finalText = finalText;
              len = documentData.finalText.length;
              flag = false;
            }
          }
        }
        lineWidth = -trackingOffset;
        cLength = 0;
        var uncollapsedSpaces = 0;
        var currentChar;
        for (i4 = 0; i4 < len; i4 += 1) {
          newLineFlag = false;
          currentChar = documentData.finalText[i4];
          charCode = currentChar.charCodeAt(0);
          if (charCode === 13 || charCode === 3) {
            uncollapsedSpaces = 0;
            lineWidths.push(lineWidth);
            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
            lineWidth = -2 * trackingOffset;
            val2 = "";
            newLineFlag = true;
            currentLine += 1;
          } else {
            val2 = currentChar;
          }
          if (fontManager.chars) {
            charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
          } else {
            cLength = fontManager.measureText(val2, documentData.f, documentData.finalSize);
          }
          if (currentChar === " ") {
            uncollapsedSpaces += cLength + trackingOffset;
          } else {
            lineWidth += cLength + trackingOffset + uncollapsedSpaces;
            uncollapsedSpaces = 0;
          }
          letters.push({
            l: cLength,
            an: cLength,
            add: currentSize,
            n: newLineFlag,
            anIndexes: [],
            val: val2,
            line: currentLine,
            animatorJustifyOffset: 0
          });
          if (anchorGrouping == 2) {
            currentSize += cLength;
            if (val2 === "" || val2 === " " || i4 === len - 1) {
              if (val2 === "" || val2 === " ") {
                currentSize -= cLength;
              }
              while (currentPos <= i4) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index2;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }
              index2 += 1;
              currentSize = 0;
            }
          } else if (anchorGrouping == 3) {
            currentSize += cLength;
            if (val2 === "" || i4 === len - 1) {
              if (val2 === "") {
                currentSize -= cLength;
              }
              while (currentPos <= i4) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index2;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }
              currentSize = 0;
              index2 += 1;
            }
          } else {
            letters[index2].ind = index2;
            letters[index2].extra = 0;
            index2 += 1;
          }
        }
        documentData.l = letters;
        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
        lineWidths.push(lineWidth);
        if (documentData.sz) {
          documentData.boxWidth = documentData.sz[0];
          documentData.justifyOffset = 0;
        } else {
          documentData.boxWidth = maxLineWidth;
          switch (documentData.j) {
            case 1:
              documentData.justifyOffset = -documentData.boxWidth;
              break;
            case 2:
              documentData.justifyOffset = -documentData.boxWidth / 2;
              break;
            default:
              documentData.justifyOffset = 0;
          }
        }
        documentData.lineWidths = lineWidths;
        var animators = data2.a;
        var animatorData;
        var letterData;
        jLen = animators.length;
        var based;
        var ind;
        var indexes = [];
        for (j2 = 0; j2 < jLen; j2 += 1) {
          animatorData = animators[j2];
          if (animatorData.a.sc) {
            documentData.strokeColorAnim = true;
          }
          if (animatorData.a.sw) {
            documentData.strokeWidthAnim = true;
          }
          if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
            documentData.fillColorAnim = true;
          }
          ind = 0;
          based = animatorData.s.b;
          for (i4 = 0; i4 < len; i4 += 1) {
            letterData = letters[i4];
            letterData.anIndexes[j2] = ind;
            if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i4 == len - 1) || based == 4 && (letterData.n || i4 == len - 1)) {
              if (animatorData.s.rn === 1) {
                indexes.push(ind);
              }
              ind += 1;
            }
          }
          data2.a[j2].s.totalChars = ind;
          var currentInd = -1;
          var newInd;
          if (animatorData.s.rn === 1) {
            for (i4 = 0; i4 < len; i4 += 1) {
              letterData = letters[i4];
              if (currentInd != letterData.anIndexes[j2]) {
                currentInd = letterData.anIndexes[j2];
                newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
              }
              letterData.anIndexes[j2] = newInd;
            }
          }
        }
        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
        documentData.ls = documentData.ls || 0;
        documentData.ascent = fontData.ascent * documentData.finalSize / 100;
      };
      TextProperty.prototype.updateDocumentData = function(newData, index2) {
        index2 = index2 === void 0 ? this.keysIndex : index2;
        var dData = this.copyData({}, this.data.d.k[index2].s);
        dData = this.copyData(dData, newData);
        this.data.d.k[index2].s = dData;
        this.recalculate(index2);
        this.setCurrentData(dData);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.recalculate = function(index2) {
        var dData = this.data.d.k[index2].s;
        dData.__complete = false;
        this.keysIndex = 0;
        this._isFirstFrame = true;
        this.getValue(dData);
      };
      TextProperty.prototype.canResizeFont = function(_canResize) {
        this.canResize = _canResize;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
        this.minimumFontSize = Math.floor(_fontValue) || 1;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };
      var TextSelectorProp = function() {
        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        function TextSelectorPropFactory(elem2, data2) {
          this._currentTextLength = -1;
          this.k = false;
          this.data = data2;
          this.elem = elem2;
          this.comp = elem2.comp;
          this.finalS = 0;
          this.finalE = 0;
          this.initDynamicPropertyContainer(elem2);
          this.s = PropertyFactory.getProp(elem2, data2.s || {
            k: 0
          }, 0, 0, this);
          if ("e" in data2) {
            this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0, this);
          } else {
            this.e = {
              v: 100
            };
          }
          this.o = PropertyFactory.getProp(elem2, data2.o || {
            k: 0
          }, 0, 0, this);
          this.xe = PropertyFactory.getProp(elem2, data2.xe || {
            k: 0
          }, 0, 0, this);
          this.ne = PropertyFactory.getProp(elem2, data2.ne || {
            k: 0
          }, 0, 0, this);
          this.sm = PropertyFactory.getProp(elem2, data2.sm || {
            k: 100
          }, 0, 0, this);
          this.a = PropertyFactory.getProp(elem2, data2.a, 0, 0.01, this);
          if (!this.dynamicProperties.length) {
            this.getValue();
          }
        }
        TextSelectorPropFactory.prototype = {
          getMult: function getMult(ind) {
            if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
              this.getValue();
            }
            var x1 = 0;
            var y1 = 0;
            var x2 = 1;
            var y2 = 1;
            if (this.ne.v > 0) {
              x1 = this.ne.v / 100;
            } else {
              y1 = -this.ne.v / 100;
            }
            if (this.xe.v > 0) {
              x2 = 1 - this.xe.v / 100;
            } else {
              y2 = 1 + this.xe.v / 100;
            }
            var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
            var mult = 0;
            var s2 = this.finalS;
            var e5 = this.finalE;
            var type = this.data.sh;
            if (type === 2) {
              if (e5 === s2) {
                mult = ind >= e5 ? 1 : 0;
              } else {
                mult = max(0, min(0.5 / (e5 - s2) + (ind - s2) / (e5 - s2), 1));
              }
              mult = easer(mult);
            } else if (type === 3) {
              if (e5 === s2) {
                mult = ind >= e5 ? 0 : 1;
              } else {
                mult = 1 - max(0, min(0.5 / (e5 - s2) + (ind - s2) / (e5 - s2), 1));
              }
              mult = easer(mult);
            } else if (type === 4) {
              if (e5 === s2) {
                mult = 0;
              } else {
                mult = max(0, min(0.5 / (e5 - s2) + (ind - s2) / (e5 - s2), 1));
                if (mult < 0.5) {
                  mult *= 2;
                } else {
                  mult = 1 - 2 * (mult - 0.5);
                }
              }
              mult = easer(mult);
            } else if (type === 5) {
              if (e5 === s2) {
                mult = 0;
              } else {
                var tot = e5 - s2;
                ind = min(max(0, ind + 0.5 - s2), e5 - s2);
                var x3 = -tot / 2 + ind;
                var a3 = tot / 2;
                mult = Math.sqrt(1 - x3 * x3 / (a3 * a3));
              }
              mult = easer(mult);
            } else if (type === 6) {
              if (e5 === s2) {
                mult = 0;
              } else {
                ind = min(max(0, ind + 0.5 - s2), e5 - s2);
                mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e5 - s2))) / 2;
              }
              mult = easer(mult);
            } else {
              if (ind >= floor(s2)) {
                if (ind - s2 < 0) {
                  mult = max(0, min(min(e5, 1) - (s2 - ind), 1));
                } else {
                  mult = max(0, min(e5 - ind, 1));
                }
              }
              mult = easer(mult);
            }
            if (this.sm.v !== 100) {
              var smoothness = this.sm.v * 0.01;
              if (smoothness === 0) {
                smoothness = 1e-8;
              }
              var threshold = 0.5 - smoothness * 0.5;
              if (mult < threshold) {
                mult = 0;
              } else {
                mult = (mult - threshold) / smoothness;
                if (mult > 1) {
                  mult = 1;
                }
              }
            }
            return mult * this.a.v;
          },
          getValue: function getValue(newCharsFlag) {
            this.iterateDynamicProperties();
            this._mdf = newCharsFlag || this._mdf;
            this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
            if (newCharsFlag && this.data.r === 2) {
              this.e.v = this._currentTextLength;
            }
            var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
            var o4 = this.o.v / divisor;
            var s2 = this.s.v / divisor + o4;
            var e5 = this.e.v / divisor + o4;
            if (s2 > e5) {
              var _s = s2;
              s2 = e5;
              e5 = _s;
            }
            this.finalS = s2;
            this.finalE = e5;
          }
        };
        extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
        function getTextSelectorProp(elem2, data2, arr) {
          return new TextSelectorPropFactory(elem2, data2, arr);
        }
        return {
          getTextSelectorProp
        };
      }();
      function TextAnimatorDataProperty(elem2, animatorProps, container) {
        var defaultData = {
          propType: false
        };
        var getProp = PropertyFactory.getProp;
        var textAnimatorAnimatables = animatorProps.a;
        this.a = {
          r: textAnimatorAnimatables.r ? getProp(elem2, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
          rx: textAnimatorAnimatables.rx ? getProp(elem2, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
          ry: textAnimatorAnimatables.ry ? getProp(elem2, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
          sk: textAnimatorAnimatables.sk ? getProp(elem2, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
          sa: textAnimatorAnimatables.sa ? getProp(elem2, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
          s: textAnimatorAnimatables.s ? getProp(elem2, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
          a: textAnimatorAnimatables.a ? getProp(elem2, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
          o: textAnimatorAnimatables.o ? getProp(elem2, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
          p: textAnimatorAnimatables.p ? getProp(elem2, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
          sw: textAnimatorAnimatables.sw ? getProp(elem2, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
          sc: textAnimatorAnimatables.sc ? getProp(elem2, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
          fc: textAnimatorAnimatables.fc ? getProp(elem2, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
          fh: textAnimatorAnimatables.fh ? getProp(elem2, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
          fs: textAnimatorAnimatables.fs ? getProp(elem2, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
          fb: textAnimatorAnimatables.fb ? getProp(elem2, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
          t: textAnimatorAnimatables.t ? getProp(elem2, textAnimatorAnimatables.t, 0, 0, container) : defaultData
        };
        this.s = TextSelectorProp.getTextSelectorProp(elem2, animatorProps.s, container);
        this.s.t = animatorProps.s.t;
      }
      function TextAnimatorProperty(textData, renderType, elem2) {
        this._isFirstFrame = true;
        this._hasMaskedPath = false;
        this._frameId = -1;
        this._textData = textData;
        this._renderType = renderType;
        this._elem = elem2;
        this._animatorsData = createSizedArray(this._textData.a.length);
        this._pathData = {};
        this._moreOptions = {
          alignment: {}
        };
        this.renderedLetters = [];
        this.lettersChangedFlag = false;
        this.initDynamicPropertyContainer(elem2);
      }
      TextAnimatorProperty.prototype.searchProperties = function() {
        var i4;
        var len = this._textData.a.length;
        var animatorProps;
        var getProp = PropertyFactory.getProp;
        for (i4 = 0; i4 < len; i4 += 1) {
          animatorProps = this._textData.a[i4];
          this._animatorsData[i4] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
        }
        if (this._textData.p && "m" in this._textData.p) {
          this._pathData = {
            a: getProp(this._elem, this._textData.p.a, 0, 0, this),
            f: getProp(this._elem, this._textData.p.f, 0, 0, this),
            l: getProp(this._elem, this._textData.p.l, 0, 0, this),
            r: getProp(this._elem, this._textData.p.r, 0, 0, this),
            p: getProp(this._elem, this._textData.p.p, 0, 0, this),
            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
          };
          this._hasMaskedPath = true;
        } else {
          this._hasMaskedPath = false;
        }
        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
      };
      TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
        this.lettersChangedFlag = lettersChangedFlag;
        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
          return;
        }
        this._isFirstFrame = false;
        var alignment = this._moreOptions.alignment.v;
        var animators = this._animatorsData;
        var textData = this._textData;
        var matrixHelper = this.mHelper;
        var renderType = this._renderType;
        var renderedLettersCount = this.renderedLetters.length;
        var xPos;
        var yPos;
        var i4;
        var len;
        var letters = documentData.l;
        var pathInfo;
        var currentLength;
        var currentPoint;
        var segmentLength;
        var flag;
        var pointInd;
        var segmentInd;
        var prevPoint;
        var points;
        var segments;
        var partialLength;
        var totalLength;
        var perc;
        var tanAngle;
        var mask2;
        if (this._hasMaskedPath) {
          mask2 = this._pathData.m;
          if (!this._pathData.n || this._pathData._mdf) {
            var paths = mask2.v;
            if (this._pathData.r.v) {
              paths = paths.reverse();
            }
            pathInfo = {
              tLength: 0,
              segments: []
            };
            len = paths._length - 1;
            var bezierData;
            totalLength = 0;
            for (i4 = 0; i4 < len; i4 += 1) {
              bezierData = bez.buildBezierData(paths.v[i4], paths.v[i4 + 1], [paths.o[i4][0] - paths.v[i4][0], paths.o[i4][1] - paths.v[i4][1]], [paths.i[i4 + 1][0] - paths.v[i4 + 1][0], paths.i[i4 + 1][1] - paths.v[i4 + 1][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength += bezierData.segmentLength;
            }
            i4 = len;
            if (mask2.v.c) {
              bezierData = bez.buildBezierData(paths.v[i4], paths.v[0], [paths.o[i4][0] - paths.v[i4][0], paths.o[i4][1] - paths.v[i4][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength += bezierData.segmentLength;
            }
            this._pathData.pi = pathInfo;
          }
          pathInfo = this._pathData.pi;
          currentLength = this._pathData.f.v;
          segmentInd = 0;
          pointInd = 1;
          segmentLength = 0;
          flag = true;
          segments = pathInfo.segments;
          if (currentLength < 0 && mask2.v.c) {
            if (pathInfo.tLength < Math.abs(currentLength)) {
              currentLength = -Math.abs(currentLength) % pathInfo.tLength;
            }
            segmentInd = segments.length - 1;
            points = segments[segmentInd].points;
            pointInd = points.length - 1;
            while (currentLength < 0) {
              currentLength += points[pointInd].partialLength;
              pointInd -= 1;
              if (pointInd < 0) {
                segmentInd -= 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;
              }
            }
          }
          points = segments[segmentInd].points;
          prevPoint = points[pointInd - 1];
          currentPoint = points[pointInd];
          partialLength = currentPoint.partialLength;
        }
        len = letters.length;
        xPos = 0;
        yPos = 0;
        var yOff = documentData.finalSize * 1.2 * 0.714;
        var firstLine = true;
        var animatorProps;
        var animatorSelector;
        var j2;
        var jLen;
        var letterValue;
        jLen = animators.length;
        var mult;
        var ind = -1;
        var offf;
        var xPathPos;
        var yPathPos;
        var initPathPos = currentLength;
        var initSegmentInd = segmentInd;
        var initPointInd = pointInd;
        var currentLine = -1;
        var elemOpacity;
        var sc;
        var sw;
        var fc;
        var k2;
        var letterSw;
        var letterSc;
        var letterFc;
        var letterM = "";
        var letterP = this.defaultPropsArray;
        var letterO;
        if (documentData.j === 2 || documentData.j === 1) {
          var animatorJustifyOffset = 0;
          var animatorFirstCharOffset = 0;
          var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
          var lastIndex = 0;
          var isNewLine = true;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (letters[i4].n) {
              if (animatorJustifyOffset) {
                animatorJustifyOffset += animatorFirstCharOffset;
              }
              while (lastIndex < i4) {
                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                lastIndex += 1;
              }
              animatorJustifyOffset = 0;
              isNewLine = true;
            } else {
              for (j2 = 0; j2 < jLen; j2 += 1) {
                animatorProps = animators[j2].a;
                if (animatorProps.t.propType) {
                  if (isNewLine && documentData.j === 2) {
                    animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                  }
                  animatorSelector = animators[j2].s;
                  mult = animatorSelector.getMult(letters[i4].anIndexes[j2], textData.a[j2].s.totalChars);
                  if (mult.length) {
                    animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                  } else {
                    animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                  }
                }
              }
              isNewLine = false;
            }
          }
          if (animatorJustifyOffset) {
            animatorJustifyOffset += animatorFirstCharOffset;
          }
          while (lastIndex < i4) {
            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
            lastIndex += 1;
          }
        }
        for (i4 = 0; i4 < len; i4 += 1) {
          matrixHelper.reset();
          elemOpacity = 1;
          if (letters[i4].n) {
            xPos = 0;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            currentLength = initPathPos;
            firstLine = false;
            if (this._hasMaskedPath) {
              segmentInd = initSegmentInd;
              pointInd = initPointInd;
              points = segments[segmentInd].points;
              prevPoint = points[pointInd - 1];
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
              segmentLength = 0;
            }
            letterM = "";
            letterFc = "";
            letterSw = "";
            letterO = "";
            letterP = this.defaultPropsArray;
          } else {
            if (this._hasMaskedPath) {
              if (currentLine !== letters[i4].line) {
                switch (documentData.j) {
                  case 1:
                    currentLength += totalLength - documentData.lineWidths[letters[i4].line];
                    break;
                  case 2:
                    currentLength += (totalLength - documentData.lineWidths[letters[i4].line]) / 2;
                    break;
                  default:
                    break;
                }
                currentLine = letters[i4].line;
              }
              if (ind !== letters[i4].ind) {
                if (letters[ind]) {
                  currentLength += letters[ind].extra;
                }
                currentLength += letters[i4].an / 2;
                ind = letters[i4].ind;
              }
              currentLength += alignment[0] * letters[i4].an * 5e-3;
              var animatorOffset = 0;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                animatorProps = animators[j2].a;
                if (animatorProps.p.propType) {
                  animatorSelector = animators[j2].s;
                  mult = animatorSelector.getMult(letters[i4].anIndexes[j2], textData.a[j2].s.totalChars);
                  if (mult.length) {
                    animatorOffset += animatorProps.p.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.p.v[0] * mult;
                  }
                }
                if (animatorProps.a.propType) {
                  animatorSelector = animators[j2].s;
                  mult = animatorSelector.getMult(letters[i4].anIndexes[j2], textData.a[j2].s.totalChars);
                  if (mult.length) {
                    animatorOffset += animatorProps.a.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.a.v[0] * mult;
                  }
                }
              }
              flag = true;
              if (this._pathData.a.v) {
                currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                currentLength += this._pathData.f.v;
              }
              while (flag) {
                if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                  perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                  xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                  yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                  matrixHelper.translate(-alignment[0] * letters[i4].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                  flag = false;
                } else if (points) {
                  segmentLength += currentPoint.partialLength;
                  pointInd += 1;
                  if (pointInd >= points.length) {
                    pointInd = 0;
                    segmentInd += 1;
                    if (!segments[segmentInd]) {
                      if (mask2.v.c) {
                        pointInd = 0;
                        segmentInd = 0;
                        points = segments[segmentInd].points;
                      } else {
                        segmentLength -= currentPoint.partialLength;
                        points = null;
                      }
                    } else {
                      points = segments[segmentInd].points;
                    }
                  }
                  if (points) {
                    prevPoint = currentPoint;
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                  }
                }
              }
              offf = letters[i4].an / 2 - letters[i4].add;
              matrixHelper.translate(-offf, 0, 0);
            } else {
              offf = letters[i4].an / 2 - letters[i4].add;
              matrixHelper.translate(-offf, 0, 0);
              matrixHelper.translate(-alignment[0] * letters[i4].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              if (animatorProps.t.propType) {
                animatorSelector = animators[j2].s;
                mult = animatorSelector.getMult(letters[i4].anIndexes[j2], textData.a[j2].s.totalChars);
                if (xPos !== 0 || documentData.j !== 0) {
                  if (this._hasMaskedPath) {
                    if (mult.length) {
                      currentLength += animatorProps.t.v * mult[0];
                    } else {
                      currentLength += animatorProps.t.v * mult;
                    }
                  } else if (mult.length) {
                    xPos += animatorProps.t.v * mult[0];
                  } else {
                    xPos += animatorProps.t.v * mult;
                  }
                }
              }
            }
            if (documentData.strokeWidthAnim) {
              sw = documentData.sw || 0;
            }
            if (documentData.strokeColorAnim) {
              if (documentData.sc) {
                sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
              } else {
                sc = [0, 0, 0];
              }
            }
            if (documentData.fillColorAnim && documentData.fc) {
              fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              if (animatorProps.a.propType) {
                animatorSelector = animators[j2].s;
                mult = animatorSelector.getMult(letters[i4].anIndexes[j2], textData.a[j2].s.totalChars);
                if (mult.length) {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                }
              }
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              if (animatorProps.s.propType) {
                animatorSelector = animators[j2].s;
                mult = animatorSelector.getMult(letters[i4].anIndexes[j2], textData.a[j2].s.totalChars);
                if (mult.length) {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                } else {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                }
              }
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              animatorSelector = animators[j2].s;
              mult = animatorSelector.getMult(letters[i4].anIndexes[j2], textData.a[j2].s.totalChars);
              if (animatorProps.sk.propType) {
                if (mult.length) {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                } else {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                }
              }
              if (animatorProps.r.propType) {
                if (mult.length) {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                } else {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult);
                }
              }
              if (animatorProps.ry.propType) {
                if (mult.length) {
                  matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                } else {
                  matrixHelper.rotateY(animatorProps.ry.v * mult);
                }
              }
              if (animatorProps.rx.propType) {
                if (mult.length) {
                  matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                } else {
                  matrixHelper.rotateX(animatorProps.rx.v * mult);
                }
              }
              if (animatorProps.o.propType) {
                if (mult.length) {
                  elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                } else {
                  elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                }
              }
              if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                if (mult.length) {
                  sw += animatorProps.sw.v * mult[0];
                } else {
                  sw += animatorProps.sw.v * mult;
                }
              }
              if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                for (k2 = 0; k2 < 3; k2 += 1) {
                  if (mult.length) {
                    sc[k2] += (animatorProps.sc.v[k2] - sc[k2]) * mult[0];
                  } else {
                    sc[k2] += (animatorProps.sc.v[k2] - sc[k2]) * mult;
                  }
                }
              }
              if (documentData.fillColorAnim && documentData.fc) {
                if (animatorProps.fc.propType) {
                  for (k2 = 0; k2 < 3; k2 += 1) {
                    if (mult.length) {
                      fc[k2] += (animatorProps.fc.v[k2] - fc[k2]) * mult[0];
                    } else {
                      fc[k2] += (animatorProps.fc.v[k2] - fc[k2]) * mult;
                    }
                  }
                }
                if (animatorProps.fh.propType) {
                  if (mult.length) {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                  } else {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                  }
                }
                if (animatorProps.fs.propType) {
                  if (mult.length) {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                  } else {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                  }
                }
                if (animatorProps.fb.propType) {
                  if (mult.length) {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                  } else {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                  }
                }
              }
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              if (animatorProps.p.propType) {
                animatorSelector = animators[j2].s;
                mult = animatorSelector.getMult(letters[i4].anIndexes[j2], textData.a[j2].s.totalChars);
                if (this._hasMaskedPath) {
                  if (mult.length) {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                  } else {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                  }
                } else if (mult.length) {
                  matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                }
              }
            }
            if (documentData.strokeWidthAnim) {
              letterSw = sw < 0 ? 0 : sw;
            }
            if (documentData.strokeColorAnim) {
              letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
            }
            if (documentData.fillColorAnim && documentData.fc) {
              letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
            }
            if (this._hasMaskedPath) {
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
              if (this._pathData.p.v) {
                tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                var rot = Math.atan(tanAngle) * 180 / Math.PI;
                if (currentPoint.point[0] < prevPoint.point[0]) {
                  rot += 180;
                }
                matrixHelper.rotate(-rot * Math.PI / 180);
              }
              matrixHelper.translate(xPathPos, yPathPos, 0);
              currentLength -= alignment[0] * letters[i4].an * 5e-3;
              if (letters[i4 + 1] && ind !== letters[i4 + 1].ind) {
                currentLength += letters[i4].an / 2;
                currentLength += documentData.tr * 1e-3 * documentData.finalSize;
              }
            } else {
              matrixHelper.translate(xPos, yPos, 0);
              if (documentData.ps) {
                matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
              }
              switch (documentData.j) {
                case 1:
                  matrixHelper.translate(letters[i4].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i4].line]), 0, 0);
                  break;
                case 2:
                  matrixHelper.translate(letters[i4].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i4].line]) / 2, 0, 0);
                  break;
                default:
                  break;
              }
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(offf, 0, 0);
              matrixHelper.translate(alignment[0] * letters[i4].an * 5e-3, alignment[1] * yOff * 0.01, 0);
              xPos += letters[i4].l + documentData.tr * 1e-3 * documentData.finalSize;
            }
            if (renderType === "html") {
              letterM = matrixHelper.toCSS();
            } else if (renderType === "svg") {
              letterM = matrixHelper.to2dCSS();
            } else {
              letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
            }
            letterO = elemOpacity;
          }
          if (renderedLettersCount <= i4) {
            letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
            this.renderedLetters.push(letterValue);
            renderedLettersCount += 1;
            this.lettersChangedFlag = true;
          } else {
            letterValue = this.renderedLetters[i4];
            this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
          }
        }
      };
      TextAnimatorProperty.prototype.getValue = function() {
        if (this._elem.globalData.frameId === this._frameId) {
          return;
        }
        this._frameId = this._elem.globalData.frameId;
        this.iterateDynamicProperties();
      };
      TextAnimatorProperty.prototype.mHelper = new Matrix();
      TextAnimatorProperty.prototype.defaultPropsArray = [];
      extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
      function ITextElement() {
      }
      ITextElement.prototype.initElement = function(data2, globalData2, comp2) {
        this.lettersChangedFlag = true;
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.textProperty = new TextProperty(this, data2.t, this.dynamicProperties);
        this.textAnimator = new TextAnimatorProperty(data2.t, this.renderType, this);
        this.initTransform(data2, globalData2, comp2);
        this.initHierarchy();
        this.initRenderable();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        this.createContent();
        this.hide();
        this.textAnimator.searchProperties(this.dynamicProperties);
      };
      ITextElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
      };
      ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
        var j2;
        var jLen = shapes.length;
        var pathNodes;
        var shapeStr = "";
        for (j2 = 0; j2 < jLen; j2 += 1) {
          if (shapes[j2].ty === "sh") {
            pathNodes = shapes[j2].ks.k;
            shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
          }
        }
        return shapeStr;
      };
      ITextElement.prototype.updateDocumentData = function(newData, index2) {
        this.textProperty.updateDocumentData(newData, index2);
      };
      ITextElement.prototype.canResizeFont = function(_canResize) {
        this.textProperty.canResizeFont(_canResize);
      };
      ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
        this.textProperty.setMinimumFontSize(_fontSize);
      };
      ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
        if (documentData.ps) {
          matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
        }
        matrixHelper.translate(0, -documentData.ls, 0);
        switch (documentData.j) {
          case 1:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
            break;
          case 2:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
            break;
          default:
            break;
        }
        matrixHelper.translate(xPos, yPos, 0);
      };
      ITextElement.prototype.buildColor = function(colorData) {
        return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
      };
      ITextElement.prototype.emptyProp = new LetterProps();
      ITextElement.prototype.destroy = function() {
      };
      ITextElement.prototype.validateText = function() {
        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
          this.buildNewText();
          this.textProperty._isFirstFrame = false;
          this.textProperty._mdf = false;
        }
      };
      var emptyShapeData = {
        shapes: []
      };
      function SVGTextLottieElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.renderType = "svg";
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
      SVGTextLottieElement.prototype.createContent = function() {
        if (this.data.singleShape && !this.globalData.fontManager.chars) {
          this.textContainer = createNS("text");
        }
      };
      SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
        var i4 = 0;
        var len = textArray.length;
        var textContents = [];
        var currentTextContent = "";
        while (i4 < len) {
          if (textArray[i4] === String.fromCharCode(13) || textArray[i4] === String.fromCharCode(3)) {
            textContents.push(currentTextContent);
            currentTextContent = "";
          } else {
            currentTextContent += textArray[i4];
          }
          i4 += 1;
        }
        textContents.push(currentTextContent);
        return textContents;
      };
      SVGTextLottieElement.prototype.buildShapeData = function(data2, scale2) {
        if (data2.shapes && data2.shapes.length) {
          var shape = data2.shapes[0];
          if (shape.it) {
            var shapeItem = shape.it[shape.it.length - 1];
            if (shapeItem.s) {
              shapeItem.s.k[0] = scale2;
              shapeItem.s.k[1] = scale2;
            }
          }
        }
        return data2;
      };
      SVGTextLottieElement.prototype.buildNewText = function() {
        this.addDynamicProperty(this);
        var i4;
        var len;
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
        if (documentData.fc) {
          this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
        } else {
          this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
        }
        if (documentData.sc) {
          this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
          this.layerElement.setAttribute("stroke-width", documentData.sw);
        }
        this.layerElement.setAttribute("font-size", documentData.finalSize);
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (fontData.fClass) {
          this.layerElement.setAttribute("class", fontData.fClass);
        } else {
          this.layerElement.setAttribute("font-family", fontData.fFamily);
          var fWeight = documentData.fWeight;
          var fStyle = documentData.fStyle;
          this.layerElement.setAttribute("font-style", fStyle);
          this.layerElement.setAttribute("font-weight", fWeight);
        }
        this.layerElement.setAttribute("aria-label", documentData.t);
        var letters = documentData.l || [];
        var usesGlyphs = !!this.globalData.fontManager.chars;
        len = letters.length;
        var tSpan;
        var matrixHelper = this.mHelper;
        var shapeStr = "";
        var singleShape = this.data.singleShape;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
        if (singleShape && !usesGlyphs && !documentData.sz) {
          var tElement = this.textContainer;
          var justify = "start";
          switch (documentData.j) {
            case 1:
              justify = "end";
              break;
            case 2:
              justify = "middle";
              break;
            default:
              justify = "start";
              break;
          }
          tElement.setAttribute("text-anchor", justify);
          tElement.setAttribute("letter-spacing", trackingOffset);
          var textContent = this.buildTextContents(documentData.finalText);
          len = textContent.length;
          yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
          for (i4 = 0; i4 < len; i4 += 1) {
            tSpan = this.textSpans[i4].span || createNS("tspan");
            tSpan.textContent = textContent[i4];
            tSpan.setAttribute("x", 0);
            tSpan.setAttribute("y", yPos);
            tSpan.style.display = "inherit";
            tElement.appendChild(tSpan);
            if (!this.textSpans[i4]) {
              this.textSpans[i4] = {
                span: null,
                glyph: null
              };
            }
            this.textSpans[i4].span = tSpan;
            yPos += documentData.finalLineHeight;
          }
          this.layerElement.appendChild(tElement);
        } else {
          var cachedSpansLength = this.textSpans.length;
          var charData;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (!this.textSpans[i4]) {
              this.textSpans[i4] = {
                span: null,
                childSpan: null,
                glyph: null
              };
            }
            if (!usesGlyphs || !singleShape || i4 === 0) {
              tSpan = cachedSpansLength > i4 ? this.textSpans[i4].span : createNS(usesGlyphs ? "g" : "text");
              if (cachedSpansLength <= i4) {
                tSpan.setAttribute("stroke-linecap", "butt");
                tSpan.setAttribute("stroke-linejoin", "round");
                tSpan.setAttribute("stroke-miterlimit", "4");
                this.textSpans[i4].span = tSpan;
                if (usesGlyphs) {
                  var childSpan = createNS("g");
                  tSpan.appendChild(childSpan);
                  this.textSpans[i4].childSpan = childSpan;
                }
                this.textSpans[i4].span = tSpan;
                this.layerElement.appendChild(tSpan);
              }
              tSpan.style.display = "inherit";
            }
            matrixHelper.reset();
            if (singleShape) {
              if (letters[i4].n) {
                xPos = -trackingOffset;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                firstLine = false;
              }
              this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i4].line, xPos, yPos);
              xPos += letters[i4].l || 0;
              xPos += trackingOffset;
            }
            if (usesGlyphs) {
              charData = this.globalData.fontManager.getCharData(documentData.finalText[i4], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
              var glyphElement;
              if (charData.t === 1) {
                glyphElement = new SVGCompElement(charData.data, this.globalData, this);
              } else {
                var data2 = emptyShapeData;
                if (charData.data && charData.data.shapes) {
                  data2 = this.buildShapeData(charData.data, documentData.finalSize);
                }
                glyphElement = new SVGShapeElement(data2, this.globalData, this);
              }
              if (this.textSpans[i4].glyph) {
                var glyph = this.textSpans[i4].glyph;
                this.textSpans[i4].childSpan.removeChild(glyph.layerElement);
                glyph.destroy();
              }
              this.textSpans[i4].glyph = glyphElement;
              glyphElement._debug = true;
              glyphElement.prepareFrame(0);
              glyphElement.renderFrame();
              this.textSpans[i4].childSpan.appendChild(glyphElement.layerElement);
              if (charData.t === 1) {
                this.textSpans[i4].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
              }
            } else {
              if (singleShape) {
                tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
              }
              tSpan.textContent = letters[i4].val;
              tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            }
          }
          if (singleShape && tSpan) {
            tSpan.setAttribute("d", shapeStr);
          }
        }
        while (i4 < this.textSpans.length) {
          this.textSpans[i4].span.style.display = "none";
          i4 += 1;
        }
        this._sizeChanged = true;
      };
      SVGTextLottieElement.prototype.sourceRectAtTime = function() {
        this.prepareFrame(this.comp.renderedFrame - this.data.st);
        this.renderInnerContent();
        if (this._sizeChanged) {
          this._sizeChanged = false;
          var textBox = this.layerElement.getBBox();
          this.bbox = {
            top: textBox.y,
            left: textBox.x,
            width: textBox.width,
            height: textBox.height
          };
        }
        return this.bbox;
      };
      SVGTextLottieElement.prototype.getValue = function() {
        var i4;
        var len = this.textSpans.length;
        var glyphElement;
        this.renderedFrame = this.comp.renderedFrame;
        for (i4 = 0; i4 < len; i4 += 1) {
          glyphElement = this.textSpans[i4].glyph;
          if (glyphElement) {
            glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
            if (glyphElement._mdf) {
              this._mdf = true;
            }
          }
        }
      };
      SVGTextLottieElement.prototype.renderInnerContent = function() {
        this.validateText();
        if (!this.data.singleShape || this._mdf) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
            this._sizeChanged = true;
            var i4;
            var len;
            var renderedLetters = this.textAnimator.renderedLetters;
            var letters = this.textProperty.currentData.l;
            len = letters.length;
            var renderedLetter;
            var textSpan;
            var glyphElement;
            for (i4 = 0; i4 < len; i4 += 1) {
              if (!letters[i4].n) {
                renderedLetter = renderedLetters[i4];
                textSpan = this.textSpans[i4].span;
                glyphElement = this.textSpans[i4].glyph;
                if (glyphElement) {
                  glyphElement.renderFrame();
                }
                if (renderedLetter._mdf.m) {
                  textSpan.setAttribute("transform", renderedLetter.m);
                }
                if (renderedLetter._mdf.o) {
                  textSpan.setAttribute("opacity", renderedLetter.o);
                }
                if (renderedLetter._mdf.sw) {
                  textSpan.setAttribute("stroke-width", renderedLetter.sw);
                }
                if (renderedLetter._mdf.sc) {
                  textSpan.setAttribute("stroke", renderedLetter.sc);
                }
                if (renderedLetter._mdf.fc) {
                  textSpan.setAttribute("fill", renderedLetter.fc);
                }
              }
            }
          }
        }
      };
      function ISolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([IImageElement], ISolidElement);
      ISolidElement.prototype.createContent = function() {
        var rect = createNS("rect");
        rect.setAttribute("width", this.data.sw);
        rect.setAttribute("height", this.data.sh);
        rect.setAttribute("fill", this.data.sc);
        this.layerElement.appendChild(rect);
      };
      function NullElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initFrame();
        this.initTransform(data2, globalData2, comp2);
        this.initHierarchy();
      }
      NullElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
      };
      NullElement.prototype.renderFrame = function() {
      };
      NullElement.prototype.getBaseElement = function() {
        return null;
      };
      NullElement.prototype.destroy = function() {
      };
      NullElement.prototype.sourceRectAtTime = function() {
      };
      NullElement.prototype.hide = function() {
      };
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
      function SVGRendererBase() {
      }
      extendPrototype([BaseRenderer], SVGRendererBase);
      SVGRendererBase.prototype.createNull = function(data2) {
        return new NullElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createShape = function(data2) {
        return new SVGShapeElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createText = function(data2) {
        return new SVGTextLottieElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createImage = function(data2) {
        return new IImageElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createSolid = function(data2) {
        return new ISolidElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.configAnimation = function(animData) {
        this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        if (this.renderConfig.viewBoxSize) {
          this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
        } else {
          this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
        }
        if (!this.renderConfig.viewBoxOnly) {
          this.svgElement.setAttribute("width", animData.w);
          this.svgElement.setAttribute("height", animData.h);
          this.svgElement.style.width = "100%";
          this.svgElement.style.height = "100%";
          this.svgElement.style.transform = "translate3d(0,0,0)";
          this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
        }
        if (this.renderConfig.width) {
          this.svgElement.setAttribute("width", this.renderConfig.width);
        }
        if (this.renderConfig.height) {
          this.svgElement.setAttribute("height", this.renderConfig.height);
        }
        if (this.renderConfig.className) {
          this.svgElement.setAttribute("class", this.renderConfig.className);
        }
        if (this.renderConfig.id) {
          this.svgElement.setAttribute("id", this.renderConfig.id);
        }
        if (this.renderConfig.focusable !== void 0) {
          this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
        }
        this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
        this.animationItem.wrapper.appendChild(this.svgElement);
        var defs = this.globalData.defs;
        this.setupGlobalData(animData, defs);
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.data = animData;
        var maskElement = createNS("clipPath");
        var rect = createNS("rect");
        rect.setAttribute("width", animData.w);
        rect.setAttribute("height", animData.h);
        rect.setAttribute("x", 0);
        rect.setAttribute("y", 0);
        var maskId = createElementID();
        maskElement.setAttribute("id", maskId);
        maskElement.appendChild(rect);
        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
        defs.appendChild(maskElement);
        this.layers = animData.layers;
        this.elements = createSizedArray(animData.layers.length);
      };
      SVGRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        this.layerElement = null;
        this.globalData.defs = null;
        var i4;
        var len = this.layers ? this.layers.length : 0;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.elements[i4] && this.elements[i4].destroy) {
            this.elements[i4].destroy();
          }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };
      SVGRendererBase.prototype.updateContainerSize = function() {
      };
      SVGRendererBase.prototype.findIndexByInd = function(ind) {
        var i4 = 0;
        var len = this.layers.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.layers[i4].ind === ind) {
            return i4;
          }
        }
        return -1;
      };
      SVGRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }
        elements[pos] = true;
        var element = this.createItem(this.layers[pos]);
        elements[pos] = element;
        if (getExpressionsPlugin()) {
          if (this.layers[pos].ty === 0) {
            this.globalData.projectInterface.registerComposition(element);
          }
          element.initExpressions();
        }
        this.appendElementInPos(element, pos);
        if (this.layers[pos].tt) {
          var elementIndex = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
          if (elementIndex === -1) {
            return;
          }
          if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
            this.buildItem(elementIndex);
            this.addPendingElement(element);
          } else {
            var matteElement = elements[elementIndex];
            var matteMask = matteElement.getMatte(this.layers[pos].tt);
            element.setMatte(matteMask);
          }
        }
      };
      SVGRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
          if (element.data.tt) {
            var i4 = 0;
            var len = this.elements.length;
            while (i4 < len) {
              if (this.elements[i4] === element) {
                var elementIndex = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i4 - 1;
                var matteElement = this.elements[elementIndex];
                var matteMask = matteElement.getMatte(this.layers[i4].tt);
                element.setMatte(matteMask);
                break;
              }
              i4 += 1;
            }
          }
        }
      };
      SVGRendererBase.prototype.renderFrame = function(num) {
        if (this.renderedFrame === num || this.destroyed) {
          return;
        }
        if (num === null) {
          num = this.renderedFrame;
        } else {
          this.renderedFrame = num;
        }
        this.globalData.frameNum = num;
        this.globalData.frameId += 1;
        this.globalData.projectInterface.currentFrame = num;
        this.globalData._mdf = false;
        var i4;
        var len = this.layers.length;
        if (!this.completeLayers) {
          this.checkLayers(num);
        }
        for (i4 = len - 1; i4 >= 0; i4 -= 1) {
          if (this.completeLayers || this.elements[i4]) {
            this.elements[i4].prepareFrame(num - this.layers[i4].st);
          }
        }
        if (this.globalData._mdf) {
          for (i4 = 0; i4 < len; i4 += 1) {
            if (this.completeLayers || this.elements[i4]) {
              this.elements[i4].renderFrame();
            }
          }
        }
      };
      SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newElement = element.getBaseElement();
        if (!newElement) {
          return;
        }
        var i4 = 0;
        var nextElement;
        while (i4 < pos) {
          if (this.elements[i4] && this.elements[i4] !== true && this.elements[i4].getBaseElement()) {
            nextElement = this.elements[i4].getBaseElement();
          }
          i4 += 1;
        }
        if (nextElement) {
          this.layerElement.insertBefore(newElement, nextElement);
        } else {
          this.layerElement.appendChild(newElement);
        }
      };
      SVGRendererBase.prototype.hide = function() {
        this.layerElement.style.display = "none";
      };
      SVGRendererBase.prototype.show = function() {
        this.layerElement.style.display = "block";
      };
      function ICompElement() {
      }
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
      ICompElement.prototype.initElement = function(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initTransform(data2, globalData2, comp2);
        this.initRenderable();
        this.initHierarchy();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        if (this.data.xt || !globalData2.progressiveLoad) {
          this.buildAllItems();
        }
        this.hide();
      };
      ICompElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        if (!this.isInRange && !this.data.xt) {
          return;
        }
        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          if (timeRemapped === this.data.op) {
            timeRemapped = this.data.op - 1;
          }
          this.renderedFrame = timeRemapped;
        } else {
          this.renderedFrame = num / this.data.sr;
        }
        var i4;
        var len = this.elements.length;
        if (!this.completeLayers) {
          this.checkLayers(this.renderedFrame);
        }
        for (i4 = len - 1; i4 >= 0; i4 -= 1) {
          if (this.completeLayers || this.elements[i4]) {
            this.elements[i4].prepareFrame(this.renderedFrame - this.layers[i4].st);
            if (this.elements[i4]._mdf) {
              this._mdf = true;
            }
          }
        }
      };
      ICompElement.prototype.renderInnerContent = function() {
        var i4;
        var len = this.layers.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.completeLayers || this.elements[i4]) {
            this.elements[i4].renderFrame();
          }
        }
      };
      ICompElement.prototype.setElements = function(elems) {
        this.elements = elems;
      };
      ICompElement.prototype.getElements = function() {
        return this.elements;
      };
      ICompElement.prototype.destroyElements = function() {
        var i4;
        var len = this.layers.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.elements[i4]) {
            this.elements[i4].destroy();
          }
        }
      };
      ICompElement.prototype.destroy = function() {
        this.destroyElements();
        this.destroyBaseElement();
      };
      function SVGCompElement(data2, globalData2, comp2) {
        this.layers = data2.layers;
        this.supports3d = true;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
      SVGCompElement.prototype.createComp = function(data2) {
        return new SVGCompElement(data2, this.globalData, this);
      };
      function SVGRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.svgElement = createNS("svg");
        var ariaLabel = "";
        if (config && config.title) {
          var titleElement = createNS("title");
          var titleId = createElementID();
          titleElement.setAttribute("id", titleId);
          titleElement.textContent = config.title;
          this.svgElement.appendChild(titleElement);
          ariaLabel += titleId;
        }
        if (config && config.description) {
          var descElement = createNS("desc");
          var descId = createElementID();
          descElement.setAttribute("id", descId);
          descElement.textContent = config.description;
          this.svgElement.appendChild(descElement);
          ariaLabel += " " + descId;
        }
        if (ariaLabel) {
          this.svgElement.setAttribute("aria-labelledby", ariaLabel);
        }
        var defs = createNS("defs");
        this.svgElement.appendChild(defs);
        var maskElement = createNS("g");
        this.svgElement.appendChild(maskElement);
        this.layerElement = maskElement;
        this.renderConfig = {
          preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          contentVisibility: config && config.contentVisibility || "visible",
          progressiveLoad: config && config.progressiveLoad || false,
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          viewBoxOnly: config && config.viewBoxOnly || false,
          viewBoxSize: config && config.viewBoxSize || false,
          className: config && config.className || "",
          id: config && config.id || "",
          focusable: config && config.focusable,
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "100%",
            height: config && config.filterSize && config.filterSize.height || "100%",
            x: config && config.filterSize && config.filterSize.x || "0%",
            y: config && config.filterSize && config.filterSize.y || "0%"
          },
          width: config && config.width,
          height: config && config.height,
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          defs,
          renderConfig: this.renderConfig
        };
        this.elements = [];
        this.pendingElements = [];
        this.destroyed = false;
        this.rendererType = "svg";
      }
      extendPrototype([SVGRendererBase], SVGRenderer);
      SVGRenderer.prototype.createComp = function(data2) {
        return new SVGCompElement(data2, this.globalData, this);
      };
      function ShapeTransformManager() {
        this.sequences = {};
        this.sequenceList = [];
        this.transform_key_count = 0;
      }
      ShapeTransformManager.prototype = {
        addTransformSequence: function addTransformSequence(transforms) {
          var i4;
          var len = transforms.length;
          var key2 = "_";
          for (i4 = 0; i4 < len; i4 += 1) {
            key2 += transforms[i4].transform.key + "_";
          }
          var sequence = this.sequences[key2];
          if (!sequence) {
            sequence = {
              transforms: [].concat(transforms),
              finalTransform: new Matrix(),
              _mdf: false
            };
            this.sequences[key2] = sequence;
            this.sequenceList.push(sequence);
          }
          return sequence;
        },
        processSequence: function processSequence(sequence, isFirstFrame) {
          var i4 = 0;
          var len = sequence.transforms.length;
          var _mdf = isFirstFrame;
          while (i4 < len && !isFirstFrame) {
            if (sequence.transforms[i4].transform.mProps._mdf) {
              _mdf = true;
              break;
            }
            i4 += 1;
          }
          if (_mdf) {
            sequence.finalTransform.reset();
            for (i4 = len - 1; i4 >= 0; i4 -= 1) {
              sequence.finalTransform.multiply(sequence.transforms[i4].transform.mProps.v);
            }
          }
          sequence._mdf = _mdf;
        },
        processSequences: function processSequences(isFirstFrame) {
          var i4;
          var len = this.sequenceList.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            this.processSequence(this.sequenceList[i4], isFirstFrame);
          }
        },
        getNewKey: function getNewKey() {
          this.transform_key_count += 1;
          return "_" + this.transform_key_count;
        }
      };
      var lumaLoader = function lumaLoader2() {
        var id = "__lottie_element_luma_buffer";
        var lumaBuffer = null;
        var lumaBufferCtx = null;
        var svg = null;
        function createLumaSvgFilter() {
          var _svg = createNS("svg");
          var fil = createNS("filter");
          var matrix = createNS("feColorMatrix");
          fil.setAttribute("id", id);
          matrix.setAttribute("type", "matrix");
          matrix.setAttribute("color-interpolation-filters", "sRGB");
          matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0");
          fil.appendChild(matrix);
          _svg.appendChild(fil);
          _svg.setAttribute("id", id + "_svg");
          if (featureSupport.svgLumaHidden) {
            _svg.style.display = "none";
          }
          return _svg;
        }
        function loadLuma() {
          if (!lumaBuffer) {
            svg = createLumaSvgFilter();
            document.body.appendChild(svg);
            lumaBuffer = createTag("canvas");
            lumaBufferCtx = lumaBuffer.getContext("2d");
            lumaBufferCtx.filter = "url(#" + id + ")";
            lumaBufferCtx.fillStyle = "rgba(0,0,0,0)";
            lumaBufferCtx.fillRect(0, 0, 1, 1);
          }
        }
        function getLuma(canvas) {
          if (!lumaBuffer) {
            loadLuma();
          }
          lumaBuffer.width = canvas.width;
          lumaBuffer.height = canvas.height;
          lumaBufferCtx.filter = "url(#" + id + ")";
          return lumaBuffer;
        }
        return {
          load: loadLuma,
          get: getLuma
        };
      };
      function createCanvas(width2, height2) {
        if (featureSupport.offscreenCanvas) {
          return new OffscreenCanvas(width2, height2);
        }
        var canvas = createTag("canvas");
        canvas.width = width2;
        canvas.height = height2;
        return canvas;
      }
      var assetLoader = function() {
        return {
          loadLumaCanvas: lumaLoader.load,
          getLumaCanvas: lumaLoader.get,
          createCanvas
        };
      }();
      var registeredEffects = {};
      function CVEffects(elem2) {
        var i4;
        var len = elem2.data.ef ? elem2.data.ef.length : 0;
        this.filters = [];
        var filterManager;
        for (i4 = 0; i4 < len; i4 += 1) {
          filterManager = null;
          var type = elem2.data.ef[i4].ty;
          if (registeredEffects[type]) {
            var Effect = registeredEffects[type].effect;
            filterManager = new Effect(elem2.effectsManager.effectElements[i4], elem2);
          }
          if (filterManager) {
            this.filters.push(filterManager);
          }
        }
        if (this.filters.length) {
          elem2.addRenderableComponent(this);
        }
      }
      CVEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i4;
        var len = this.filters.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.filters[i4].renderFrame(_isFirstFrame);
        }
      };
      CVEffects.prototype.getEffects = function(type) {
        var i4;
        var len = this.filters.length;
        var effects = [];
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.filters[i4].type === type) {
            effects.push(this.filters[i4]);
          }
        }
        return effects;
      };
      function registerEffect(id, effect2) {
        registeredEffects[id] = {
          effect: effect2
        };
      }
      function CVMaskElement(data2, element) {
        this.data = data2;
        this.element = element;
        this.masksProperties = this.data.masksProperties || [];
        this.viewData = createSizedArray(this.masksProperties.length);
        var i4;
        var len = this.masksProperties.length;
        var hasMasks = false;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.masksProperties[i4].mode !== "n") {
            hasMasks = true;
          }
          this.viewData[i4] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i4], 3);
        }
        this.hasMasks = hasMasks;
        if (hasMasks) {
          this.element.addRenderableComponent(this);
        }
      }
      CVMaskElement.prototype.renderFrame = function() {
        if (!this.hasMasks) {
          return;
        }
        var transform2 = this.element.finalTransform.mat;
        var ctx = this.element.canvasContext;
        var i4;
        var len = this.masksProperties.length;
        var pt;
        var pts;
        var data2;
        ctx.beginPath();
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.masksProperties[i4].mode !== "n") {
            if (this.masksProperties[i4].inv) {
              ctx.moveTo(0, 0);
              ctx.lineTo(this.element.globalData.compSize.w, 0);
              ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
              ctx.lineTo(0, this.element.globalData.compSize.h);
              ctx.lineTo(0, 0);
            }
            data2 = this.viewData[i4].v;
            pt = transform2.applyToPointArray(data2.v[0][0], data2.v[0][1], 0);
            ctx.moveTo(pt[0], pt[1]);
            var j2;
            var jLen = data2._length;
            for (j2 = 1; j2 < jLen; j2 += 1) {
              pts = transform2.applyToTriplePoints(data2.o[j2 - 1], data2.i[j2], data2.v[j2]);
              ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }
            pts = transform2.applyToTriplePoints(data2.o[j2 - 1], data2.i[0], data2.v[0]);
            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
          }
        }
        this.element.globalData.renderer.save(true);
        ctx.clip();
      };
      CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
      CVMaskElement.prototype.destroy = function() {
        this.element = null;
      };
      function CVBaseElement() {
      }
      var operationsMap = {
        1: "source-in",
        2: "source-out",
        3: "source-in",
        4: "source-out"
      };
      CVBaseElement.prototype = {
        createElements: function createElements() {
        },
        initRendererElement: function initRendererElement() {
        },
        createContainerElements: function createContainerElements() {
          if (this.data.tt >= 1) {
            this.buffers = [];
            var canvasContext = this.globalData.canvasContext;
            var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
            this.buffers.push(bufferCanvas);
            var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
            this.buffers.push(bufferCanvas2);
            if (this.data.tt >= 3 && !document._isProxy) {
              assetLoader.loadLumaCanvas();
            }
          }
          this.canvasContext = this.globalData.canvasContext;
          this.transformCanvas = this.globalData.transformCanvas;
          this.renderableEffectsManager = new CVEffects(this);
          this.searchEffectTransforms();
        },
        createContent: function createContent() {
        },
        setBlendMode: function setBlendMode() {
          var globalData2 = this.globalData;
          if (globalData2.blendMode !== this.data.bm) {
            globalData2.blendMode = this.data.bm;
            var blendModeValue = getBlendMode(this.data.bm);
            globalData2.canvasContext.globalCompositeOperation = blendModeValue;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new CVMaskElement(this.data, this);
          this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
        },
        hideElement: function hideElement() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            this.hidden = true;
          }
        },
        showElement: function showElement() {
          if (this.isInRange && !this.isTransparent) {
            this.hidden = false;
            this._isFirstFrame = true;
            this.maskManager._isFirstFrame = true;
          }
        },
        clearCanvas: function clearCanvas(canvasContext) {
          canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
        },
        prepareLayer: function prepareLayer() {
          if (this.data.tt >= 1) {
            var buffer = this.buffers[0];
            var bufferCtx = buffer.getContext("2d");
            this.clearCanvas(bufferCtx);
            bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.currentTransform = this.canvasContext.getTransform();
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.setTransform(this.currentTransform);
          }
        },
        exitLayer: function exitLayer() {
          if (this.data.tt >= 1) {
            var buffer = this.buffers[1];
            var bufferCtx = buffer.getContext("2d");
            this.clearCanvas(bufferCtx);
            bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.setTransform(this.currentTransform);
            var mask2 = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
            mask2.renderFrame(true);
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            if (this.data.tt >= 3 && !document._isProxy) {
              var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
              var lumaBufferCtx = lumaBuffer.getContext("2d");
              lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
              this.clearCanvas(this.canvasContext);
              this.canvasContext.drawImage(lumaBuffer, 0, 0);
            }
            this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
            this.canvasContext.drawImage(buffer, 0, 0);
            this.canvasContext.globalCompositeOperation = "destination-over";
            this.canvasContext.drawImage(this.buffers[0], 0, 0);
            this.canvasContext.setTransform(this.currentTransform);
            this.canvasContext.globalCompositeOperation = "source-over";
          }
        },
        renderFrame: function renderFrame(forceRender) {
          if (this.hidden || this.data.hd) {
            return;
          }
          if (this.data.td === 1 && !forceRender) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderLocalTransform();
          this.setBlendMode();
          var forceRealStack = this.data.ty === 0;
          this.prepareLayer();
          this.globalData.renderer.save(forceRealStack);
          this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
          this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
          this.renderInnerContent();
          this.globalData.renderer.restore(forceRealStack);
          this.exitLayer();
          if (this.maskManager.hasMasks) {
            this.globalData.renderer.restore(true);
          }
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.canvasContext = null;
          this.data = null;
          this.globalData = null;
          this.maskManager.destroy();
        },
        mHelper: new Matrix()
      };
      CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
      CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
      function CVShapeData(element, data2, styles, transformsManager) {
        this.styledShapes = [];
        this.tr = [0, 0, 0, 0, 0, 0];
        var ty = 4;
        if (data2.ty === "rc") {
          ty = 5;
        } else if (data2.ty === "el") {
          ty = 6;
        } else if (data2.ty === "sr") {
          ty = 7;
        }
        this.sh = ShapePropertyFactory.getShapeProp(element, data2, ty, element);
        var i4;
        var len = styles.length;
        var styledShape;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (!styles[i4].closed) {
            styledShape = {
              transforms: transformsManager.addTransformSequence(styles[i4].transforms),
              trNodes: []
            };
            this.styledShapes.push(styledShape);
            styles[i4].elements.push(styledShape);
          }
        }
      }
      CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
      function CVShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.itemsData = [];
        this.prevViewData = [];
        this.shapeModifiers = [];
        this.processedElements = [];
        this.transformsManager = new ShapeTransformManager();
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
      CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
      CVShapeElement.prototype.transformHelper = {
        opacity: 1,
        _opMdf: false
      };
      CVShapeElement.prototype.dashResetter = [];
      CVShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
      };
      CVShapeElement.prototype.createStyleElement = function(data2, transforms) {
        var styleElem = {
          data: data2,
          type: data2.ty,
          preTransforms: this.transformsManager.addTransformSequence(transforms),
          transforms: [],
          elements: [],
          closed: data2.hd === true
        };
        var elementData = {};
        if (data2.ty === "fl" || data2.ty === "st") {
          elementData.c = PropertyFactory.getProp(this, data2.c, 1, 255, this);
          if (!elementData.c.k) {
            styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
          }
        } else if (data2.ty === "gf" || data2.ty === "gs") {
          elementData.s = PropertyFactory.getProp(this, data2.s, 1, null, this);
          elementData.e = PropertyFactory.getProp(this, data2.e, 1, null, this);
          elementData.h = PropertyFactory.getProp(this, data2.h || {
            k: 0
          }, 0, 0.01, this);
          elementData.a = PropertyFactory.getProp(this, data2.a || {
            k: 0
          }, 0, degToRads, this);
          elementData.g = new GradientProperty(this, data2.g, this);
        }
        elementData.o = PropertyFactory.getProp(this, data2.o, 0, 0.01, this);
        if (data2.ty === "st" || data2.ty === "gs") {
          styleElem.lc = lineCapEnum[data2.lc || 2];
          styleElem.lj = lineJoinEnum[data2.lj || 2];
          if (data2.lj == 1) {
            styleElem.ml = data2.ml;
          }
          elementData.w = PropertyFactory.getProp(this, data2.w, 0, null, this);
          if (!elementData.w.k) {
            styleElem.wi = elementData.w.v;
          }
          if (data2.d) {
            var d2 = new DashProperty(this, data2.d, "canvas", this);
            elementData.d = d2;
            if (!elementData.d.k) {
              styleElem.da = elementData.d.dashArray;
              styleElem["do"] = elementData.d.dashoffset[0];
            }
          }
        } else {
          styleElem.r = data2.r === 2 ? "evenodd" : "nonzero";
        }
        this.stylesList.push(styleElem);
        elementData.style = styleElem;
        return elementData;
      };
      CVShapeElement.prototype.createGroupElement = function() {
        var elementData = {
          it: [],
          prevViewData: []
        };
        return elementData;
      };
      CVShapeElement.prototype.createTransformElement = function(data2) {
        var elementData = {
          transform: {
            opacity: 1,
            _opMdf: false,
            key: this.transformsManager.getNewKey(),
            op: PropertyFactory.getProp(this, data2.o, 0, 0.01, this),
            mProps: TransformPropertyFactory.getTransformProperty(this, data2, this)
          }
        };
        return elementData;
      };
      CVShapeElement.prototype.createShapeElement = function(data2) {
        var elementData = new CVShapeData(this, data2, this.stylesList, this.transformsManager);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        return elementData;
      };
      CVShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i4;
        var len = this.itemsData.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.prevViewData[i4] = this.itemsData[i4];
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
        len = this.dynamicProperties.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          this.dynamicProperties[i4].getValue();
        }
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
      };
      CVShapeElement.prototype.addTransformToStyleList = function(transform2) {
        var i4;
        var len = this.stylesList.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (!this.stylesList[i4].closed) {
            this.stylesList[i4].transforms.push(transform2);
          }
        }
      };
      CVShapeElement.prototype.removeTransformFromStyleList = function() {
        var i4;
        var len = this.stylesList.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (!this.stylesList[i4].closed) {
            this.stylesList[i4].transforms.pop();
          }
        }
      };
      CVShapeElement.prototype.closeStyles = function(styles) {
        var i4;
        var len = styles.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          styles[i4].closed = true;
        }
      };
      CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
        var i4;
        var len = arr.length - 1;
        var j2;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var processedPos;
        var modifier;
        var currentTransform;
        var ownTransforms = [].concat(transforms);
        for (i4 = len; i4 >= 0; i4 -= 1) {
          processedPos = this.searchProcessedElement(arr[i4]);
          if (!processedPos) {
            arr[i4]._shouldRender = shouldRender;
          } else {
            itemsData[i4] = prevViewData[processedPos - 1];
          }
          if (arr[i4].ty === "fl" || arr[i4].ty === "st" || arr[i4].ty === "gf" || arr[i4].ty === "gs") {
            if (!processedPos) {
              itemsData[i4] = this.createStyleElement(arr[i4], ownTransforms);
            } else {
              itemsData[i4].style.closed = false;
            }
            ownStyles.push(itemsData[i4].style);
          } else if (arr[i4].ty === "gr") {
            if (!processedPos) {
              itemsData[i4] = this.createGroupElement(arr[i4]);
            } else {
              jLen = itemsData[i4].it.length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                itemsData[i4].prevViewData[j2] = itemsData[i4].it[j2];
              }
            }
            this.searchShapes(arr[i4].it, itemsData[i4].it, itemsData[i4].prevViewData, shouldRender, ownTransforms);
          } else if (arr[i4].ty === "tr") {
            if (!processedPos) {
              currentTransform = this.createTransformElement(arr[i4]);
              itemsData[i4] = currentTransform;
            }
            ownTransforms.push(itemsData[i4]);
            this.addTransformToStyleList(itemsData[i4]);
          } else if (arr[i4].ty === "sh" || arr[i4].ty === "rc" || arr[i4].ty === "el" || arr[i4].ty === "sr") {
            if (!processedPos) {
              itemsData[i4] = this.createShapeElement(arr[i4]);
            }
          } else if (arr[i4].ty === "tm" || arr[i4].ty === "rd" || arr[i4].ty === "pb" || arr[i4].ty === "zz" || arr[i4].ty === "op") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i4].ty);
              modifier.init(this, arr[i4]);
              itemsData[i4] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i4];
              modifier.closed = false;
            }
            ownModifiers.push(modifier);
          } else if (arr[i4].ty === "rp") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i4].ty);
              itemsData[i4] = modifier;
              modifier.init(this, arr, i4, itemsData);
              this.shapeModifiers.push(modifier);
              shouldRender = false;
            } else {
              modifier = itemsData[i4];
              modifier.closed = true;
            }
            ownModifiers.push(modifier);
          }
          this.addProcessedElement(arr[i4], i4 + 1);
        }
        this.removeTransformFromStyleList();
        this.closeStyles(ownStyles);
        len = ownModifiers.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          ownModifiers[i4].closed = true;
        }
      };
      CVShapeElement.prototype.renderInnerContent = function() {
        this.transformHelper.opacity = 1;
        this.transformHelper._opMdf = false;
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
      };
      CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
          groupTransform.opacity = parentTransform.opacity;
          groupTransform.opacity *= groupTransform.op.v;
          groupTransform._opMdf = true;
        }
      };
      CVShapeElement.prototype.drawLayer = function() {
        var i4;
        var len = this.stylesList.length;
        var j2;
        var jLen;
        var k2;
        var kLen;
        var elems;
        var nodes;
        var renderer2 = this.globalData.renderer;
        var ctx = this.globalData.canvasContext;
        var type;
        var currentStyle;
        for (i4 = 0; i4 < len; i4 += 1) {
          currentStyle = this.stylesList[i4];
          type = currentStyle.type;
          if (!((type === "st" || type === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
            renderer2.save();
            elems = currentStyle.elements;
            if (type === "st" || type === "gs") {
              renderer2.ctxStrokeStyle(type === "st" ? currentStyle.co : currentStyle.grd);
              renderer2.ctxLineWidth(currentStyle.wi);
              renderer2.ctxLineCap(currentStyle.lc);
              renderer2.ctxLineJoin(currentStyle.lj);
              renderer2.ctxMiterLimit(currentStyle.ml || 0);
            } else {
              renderer2.ctxFillStyle(type === "fl" ? currentStyle.co : currentStyle.grd);
            }
            renderer2.ctxOpacity(currentStyle.coOp);
            if (type !== "st" && type !== "gs") {
              ctx.beginPath();
            }
            renderer2.ctxTransform(currentStyle.preTransforms.finalTransform.props);
            jLen = elems.length;
            for (j2 = 0; j2 < jLen; j2 += 1) {
              if (type === "st" || type === "gs") {
                ctx.beginPath();
                if (currentStyle.da) {
                  ctx.setLineDash(currentStyle.da);
                  ctx.lineDashOffset = currentStyle["do"];
                }
              }
              nodes = elems[j2].trNodes;
              kLen = nodes.length;
              for (k2 = 0; k2 < kLen; k2 += 1) {
                if (nodes[k2].t === "m") {
                  ctx.moveTo(nodes[k2].p[0], nodes[k2].p[1]);
                } else if (nodes[k2].t === "c") {
                  ctx.bezierCurveTo(nodes[k2].pts[0], nodes[k2].pts[1], nodes[k2].pts[2], nodes[k2].pts[3], nodes[k2].pts[4], nodes[k2].pts[5]);
                } else {
                  ctx.closePath();
                }
              }
              if (type === "st" || type === "gs") {
                renderer2.ctxStroke();
                if (currentStyle.da) {
                  ctx.setLineDash(this.dashResetter);
                }
              }
            }
            if (type !== "st" && type !== "gs") {
              this.globalData.renderer.ctxFill(currentStyle.r);
            }
            renderer2.restore();
          }
        }
      };
      CVShapeElement.prototype.renderShape = function(parentTransform, items, data2, isMain) {
        var i4;
        var len = items.length - 1;
        var groupTransform;
        groupTransform = parentTransform;
        for (i4 = len; i4 >= 0; i4 -= 1) {
          if (items[i4].ty === "tr") {
            groupTransform = data2[i4].transform;
            this.renderShapeTransform(parentTransform, groupTransform);
          } else if (items[i4].ty === "sh" || items[i4].ty === "el" || items[i4].ty === "rc" || items[i4].ty === "sr") {
            this.renderPath(items[i4], data2[i4]);
          } else if (items[i4].ty === "fl") {
            this.renderFill(items[i4], data2[i4], groupTransform);
          } else if (items[i4].ty === "st") {
            this.renderStroke(items[i4], data2[i4], groupTransform);
          } else if (items[i4].ty === "gf" || items[i4].ty === "gs") {
            this.renderGradientFill(items[i4], data2[i4], groupTransform);
          } else if (items[i4].ty === "gr") {
            this.renderShape(groupTransform, items[i4].it, data2[i4].it);
          } else if (items[i4].ty === "tm") {
          }
        }
        if (isMain) {
          this.drawLayer();
        }
      };
      CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
          var shapeNodes = styledShape.trNodes;
          var paths = shape.paths;
          var i4;
          var len;
          var j2;
          var jLen = paths._length;
          shapeNodes.length = 0;
          var groupTransformMat = styledShape.transforms.finalTransform;
          for (j2 = 0; j2 < jLen; j2 += 1) {
            var pathNodes = paths.shapes[j2];
            if (pathNodes && pathNodes.v) {
              len = pathNodes._length;
              for (i4 = 1; i4 < len; i4 += 1) {
                if (i4 === 1) {
                  shapeNodes.push({
                    t: "m",
                    p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                  });
                }
                shapeNodes.push({
                  t: "c",
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i4 - 1], pathNodes.i[i4], pathNodes.v[i4])
                });
              }
              if (len === 1) {
                shapeNodes.push({
                  t: "m",
                  p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                });
              }
              if (pathNodes.c && len) {
                shapeNodes.push({
                  t: "c",
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i4 - 1], pathNodes.i[0], pathNodes.v[0])
                });
                shapeNodes.push({
                  t: "z"
                });
              }
            }
          }
          styledShape.trNodes = shapeNodes;
        }
      };
      CVShapeElement.prototype.renderPath = function(pathData, itemData) {
        if (pathData.hd !== true && pathData._shouldRender) {
          var i4;
          var len = itemData.styledShapes.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            this.renderStyledShape(itemData.styledShapes[i4], itemData.sh);
          }
        }
      };
      CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
      };
      CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var grd;
        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
          var ctx = this.globalData.canvasContext;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;
          if (styleData.t === 1) {
            grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
          } else {
            var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
            var percent = itemData.h.v;
            if (percent >= 1) {
              percent = 0.99;
            } else if (percent <= -1) {
              percent = -0.99;
            }
            var dist = rad * percent;
            var x2 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
            var y2 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
            grd = ctx.createRadialGradient(x2, y2, 0, pt1[0], pt1[1], rad);
          }
          var i4;
          var len = styleData.g.p;
          var cValues = itemData.g.c;
          var opacity = 1;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (itemData.g._hasOpacity && itemData.g._collapsable) {
              opacity = itemData.g.o[i4 * 2 + 1];
            }
            grd.addColorStop(cValues[i4 * 4] / 100, "rgba(" + cValues[i4 * 4 + 1] + "," + cValues[i4 * 4 + 2] + "," + cValues[i4 * 4 + 3] + "," + opacity + ")");
          }
          styleElem.grd = grd;
        }
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      };
      CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var d2 = itemData.d;
        if (d2 && (d2._mdf || this._isFirstFrame)) {
          styleElem.da = d2.dashArray;
          styleElem["do"] = d2.dashoffset[0];
        }
        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
        if (itemData.w._mdf || this._isFirstFrame) {
          styleElem.wi = itemData.w.v;
        }
      };
      CVShapeElement.prototype.destroy = function() {
        this.shapesData = null;
        this.globalData = null;
        this.canvasContext = null;
        this.stylesList.length = 0;
        this.itemsData.length = 0;
      };
      function CVTextElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.yOffset = 0;
        this.fillColorAnim = false;
        this.strokeColorAnim = false;
        this.strokeWidthAnim = false;
        this.stroke = false;
        this.fill = false;
        this.justifyOffset = 0;
        this.currentRender = null;
        this.renderType = "canvas";
        this.values = {
          fill: "rgba(0,0,0,0)",
          stroke: "rgba(0,0,0,0)",
          sWidth: 0,
          fValue: ""
        };
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
      CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
      CVTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var hasFill = false;
        if (documentData.fc) {
          hasFill = true;
          this.values.fill = this.buildColor(documentData.fc);
        } else {
          this.values.fill = "rgba(0,0,0,0)";
        }
        this.fill = hasFill;
        var hasStroke = false;
        if (documentData.sc) {
          hasStroke = true;
          this.values.stroke = this.buildColor(documentData.sc);
          this.values.sWidth = documentData.sw;
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        var i4;
        var len;
        var letters = documentData.l;
        var matrixHelper = this.mHelper;
        this.stroke = hasStroke;
        this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
        len = documentData.finalText.length;
        var charData;
        var shapeData;
        var k2;
        var kLen;
        var shapes;
        var j2;
        var jLen;
        var pathNodes;
        var commands;
        var pathArr;
        var singleShape = this.data.singleShape;
        var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var cnt = 0;
        for (i4 = 0; i4 < len; i4 += 1) {
          charData = this.globalData.fontManager.getCharData(documentData.finalText[i4], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          shapeData = charData && charData.data || {};
          matrixHelper.reset();
          if (singleShape && letters[i4].n) {
            xPos = -trackingOffset;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            firstLine = false;
          }
          shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
          jLen = shapes.length;
          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
          if (singleShape) {
            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i4].line, xPos, yPos);
          }
          commands = createSizedArray(jLen - 1);
          var commandsCounter = 0;
          for (j2 = 0; j2 < jLen; j2 += 1) {
            if (shapes[j2].ty === "sh") {
              kLen = shapes[j2].ks.k.i.length;
              pathNodes = shapes[j2].ks.k;
              pathArr = [];
              for (k2 = 1; k2 < kLen; k2 += 1) {
                if (k2 === 1) {
                  pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                }
                pathArr.push(matrixHelper.applyToX(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k2][0], pathNodes.i[k2][1], 0), matrixHelper.applyToY(pathNodes.i[k2][0], pathNodes.i[k2][1], 0), matrixHelper.applyToX(pathNodes.v[k2][0], pathNodes.v[k2][1], 0), matrixHelper.applyToY(pathNodes.v[k2][0], pathNodes.v[k2][1], 0));
              }
              pathArr.push(matrixHelper.applyToX(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
              commands[commandsCounter] = pathArr;
              commandsCounter += 1;
            }
          }
          if (singleShape) {
            xPos += letters[i4].l;
            xPos += trackingOffset;
          }
          if (this.textSpans[cnt]) {
            this.textSpans[cnt].elem = commands;
          } else {
            this.textSpans[cnt] = {
              elem: commands
            };
          }
          cnt += 1;
        }
      };
      CVTextElement.prototype.renderInnerContent = function() {
        this.validateText();
        var ctx = this.canvasContext;
        ctx.font = this.values.fValue;
        this.globalData.renderer.ctxLineCap("butt");
        this.globalData.renderer.ctxLineJoin("miter");
        this.globalData.renderer.ctxMiterLimit(4);
        if (!this.data.singleShape) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        }
        var i4;
        var len;
        var j2;
        var jLen;
        var k2;
        var kLen;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var lastFill = null;
        var lastStroke = null;
        var lastStrokeW = null;
        var commands;
        var pathArr;
        var renderer2 = this.globalData.renderer;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (!letters[i4].n) {
            renderedLetter = renderedLetters[i4];
            if (renderedLetter) {
              renderer2.save();
              renderer2.ctxTransform(renderedLetter.p);
              renderer2.ctxOpacity(renderedLetter.o);
            }
            if (this.fill) {
              if (renderedLetter && renderedLetter.fc) {
                if (lastFill !== renderedLetter.fc) {
                  renderer2.ctxFillStyle(renderedLetter.fc);
                  lastFill = renderedLetter.fc;
                }
              } else if (lastFill !== this.values.fill) {
                lastFill = this.values.fill;
                renderer2.ctxFillStyle(this.values.fill);
              }
              commands = this.textSpans[i4].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();
              for (j2 = 0; j2 < jLen; j2 += 1) {
                pathArr = commands[j2];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                for (k2 = 2; k2 < kLen; k2 += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k2], pathArr[k2 + 1], pathArr[k2 + 2], pathArr[k2 + 3], pathArr[k2 + 4], pathArr[k2 + 5]);
                }
              }
              this.globalData.canvasContext.closePath();
              renderer2.ctxFill();
            }
            if (this.stroke) {
              if (renderedLetter && renderedLetter.sw) {
                if (lastStrokeW !== renderedLetter.sw) {
                  lastStrokeW = renderedLetter.sw;
                  renderer2.ctxLineWidth(renderedLetter.sw);
                }
              } else if (lastStrokeW !== this.values.sWidth) {
                lastStrokeW = this.values.sWidth;
                renderer2.ctxLineWidth(this.values.sWidth);
              }
              if (renderedLetter && renderedLetter.sc) {
                if (lastStroke !== renderedLetter.sc) {
                  lastStroke = renderedLetter.sc;
                  renderer2.ctxStrokeStyle(renderedLetter.sc);
                }
              } else if (lastStroke !== this.values.stroke) {
                lastStroke = this.values.stroke;
                renderer2.ctxStrokeStyle(this.values.stroke);
              }
              commands = this.textSpans[i4].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();
              for (j2 = 0; j2 < jLen; j2 += 1) {
                pathArr = commands[j2];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                for (k2 = 2; k2 < kLen; k2 += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k2], pathArr[k2 + 1], pathArr[k2 + 2], pathArr[k2 + 3], pathArr[k2 + 4], pathArr[k2 + 5]);
                }
              }
              this.globalData.canvasContext.closePath();
              renderer2.ctxStroke();
            }
            if (renderedLetter) {
              this.globalData.renderer.restore();
            }
          }
        }
      };
      function CVImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        this.img = globalData2.imageLoader.getAsset(this.assetData);
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
      CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
      CVImageElement.prototype.createContent = function() {
        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
          var canvas = createTag("canvas");
          canvas.width = this.assetData.w;
          canvas.height = this.assetData.h;
          var ctx = canvas.getContext("2d");
          var imgW = this.img.width;
          var imgH = this.img.height;
          var imgRel = imgW / imgH;
          var canvasRel = this.assetData.w / this.assetData.h;
          var widthCrop;
          var heightCrop;
          var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
          if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
            heightCrop = imgH;
            widthCrop = heightCrop * canvasRel;
          } else {
            widthCrop = imgW;
            heightCrop = widthCrop / canvasRel;
          }
          ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
          this.img = canvas;
        }
      };
      CVImageElement.prototype.renderInnerContent = function() {
        this.canvasContext.drawImage(this.img, 0, 0);
      };
      CVImageElement.prototype.destroy = function() {
        this.img = null;
      };
      function CVSolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
      CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
      CVSolidElement.prototype.renderInnerContent = function() {
        this.globalData.renderer.ctxFillStyle(this.data.sc);
        this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
      };
      function CanvasRendererBase() {
      }
      extendPrototype([BaseRenderer], CanvasRendererBase);
      CanvasRendererBase.prototype.createShape = function(data2) {
        return new CVShapeElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createText = function(data2) {
        return new CVTextElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createImage = function(data2) {
        return new CVImageElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createSolid = function(data2) {
        return new CVSolidElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
      CanvasRendererBase.prototype.ctxTransform = function(props) {
        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
          return;
        }
        this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
      };
      CanvasRendererBase.prototype.ctxOpacity = function(op) {
        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
      };
      CanvasRendererBase.prototype.ctxFillStyle = function(value2) {
        this.canvasContext.fillStyle = value2;
      };
      CanvasRendererBase.prototype.ctxStrokeStyle = function(value2) {
        this.canvasContext.strokeStyle = value2;
      };
      CanvasRendererBase.prototype.ctxLineWidth = function(value2) {
        this.canvasContext.lineWidth = value2;
      };
      CanvasRendererBase.prototype.ctxLineCap = function(value2) {
        this.canvasContext.lineCap = value2;
      };
      CanvasRendererBase.prototype.ctxLineJoin = function(value2) {
        this.canvasContext.lineJoin = value2;
      };
      CanvasRendererBase.prototype.ctxMiterLimit = function(value2) {
        this.canvasContext.miterLimit = value2;
      };
      CanvasRendererBase.prototype.ctxFill = function(rule) {
        this.canvasContext.fill(rule);
      };
      CanvasRendererBase.prototype.ctxFillRect = function(x2, y2, w2, h2) {
        this.canvasContext.fillRect(x2, y2, w2, h2);
      };
      CanvasRendererBase.prototype.ctxStroke = function() {
        this.canvasContext.stroke();
      };
      CanvasRendererBase.prototype.reset = function() {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }
        this.contextData.reset();
      };
      CanvasRendererBase.prototype.save = function() {
        this.canvasContext.save();
      };
      CanvasRendererBase.prototype.restore = function(actionFlag) {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }
        if (actionFlag) {
          this.globalData.blendMode = "source-over";
        }
        this.contextData.restore(actionFlag);
      };
      CanvasRendererBase.prototype.configAnimation = function(animData) {
        if (this.animationItem.wrapper) {
          this.animationItem.container = createTag("canvas");
          var containerStyle = this.animationItem.container.style;
          containerStyle.width = "100%";
          containerStyle.height = "100%";
          var origin = "0px 0px 0px";
          containerStyle.transformOrigin = origin;
          containerStyle.mozTransformOrigin = origin;
          containerStyle.webkitTransformOrigin = origin;
          containerStyle["-webkit-transform"] = origin;
          containerStyle.contentVisibility = this.renderConfig.contentVisibility;
          this.animationItem.wrapper.appendChild(this.animationItem.container);
          this.canvasContext = this.animationItem.container.getContext("2d");
          if (this.renderConfig.className) {
            this.animationItem.container.setAttribute("class", this.renderConfig.className);
          }
          if (this.renderConfig.id) {
            this.animationItem.container.setAttribute("id", this.renderConfig.id);
          }
        } else {
          this.canvasContext = this.renderConfig.context;
        }
        this.contextData.setContext(this.canvasContext);
        this.data = animData;
        this.layers = animData.layers;
        this.transformCanvas = {
          w: animData.w,
          h: animData.h,
          sx: 0,
          sy: 0,
          tx: 0,
          ty: 0
        };
        this.setupGlobalData(animData, document.body);
        this.globalData.canvasContext = this.canvasContext;
        this.globalData.renderer = this;
        this.globalData.isDashed = false;
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.globalData.transformCanvas = this.transformCanvas;
        this.elements = createSizedArray(animData.layers.length);
        this.updateContainerSize();
      };
      CanvasRendererBase.prototype.updateContainerSize = function(width2, height2) {
        this.reset();
        var elementWidth;
        var elementHeight;
        if (width2) {
          elementWidth = width2;
          elementHeight = height2;
          this.canvasContext.canvas.width = elementWidth;
          this.canvasContext.canvas.height = elementHeight;
        } else {
          if (this.animationItem.wrapper && this.animationItem.container) {
            elementWidth = this.animationItem.wrapper.offsetWidth;
            elementHeight = this.animationItem.wrapper.offsetHeight;
          } else {
            elementWidth = this.canvasContext.canvas.width;
            elementHeight = this.canvasContext.canvas.height;
          }
          this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
          this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
        }
        var elementRel;
        var animationRel;
        if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
          var par = this.renderConfig.preserveAspectRatio.split(" ");
          var fillType = par[1] || "meet";
          var pos = par[0] || "xMidYMid";
          var xPos = pos.substr(0, 4);
          var yPos = pos.substr(4);
          elementRel = elementWidth / elementHeight;
          animationRel = this.transformCanvas.w / this.transformCanvas.h;
          if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          } else {
            this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          }
          if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
          } else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.tx = 0;
          }
          if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
          } else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.ty = 0;
          }
        } else if (this.renderConfig.preserveAspectRatio === "none") {
          this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        } else {
          this.transformCanvas.sx = this.renderConfig.dpr;
          this.transformCanvas.sy = this.renderConfig.dpr;
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        }
        this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
        this.ctxTransform(this.transformCanvas.props);
        this.canvasContext.beginPath();
        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        this.canvasContext.closePath();
        this.canvasContext.clip();
        this.renderFrame(this.renderedFrame, true);
      };
      CanvasRendererBase.prototype.destroy = function() {
        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        var i4;
        var len = this.layers ? this.layers.length : 0;
        for (i4 = len - 1; i4 >= 0; i4 -= 1) {
          if (this.elements[i4] && this.elements[i4].destroy) {
            this.elements[i4].destroy();
          }
        }
        this.elements.length = 0;
        this.globalData.canvasContext = null;
        this.animationItem.container = null;
        this.destroyed = true;
      };
      CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
          return;
        }
        this.renderedFrame = num;
        this.globalData.frameNum = num - this.animationItem._isFirstFrame;
        this.globalData.frameId += 1;
        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
        this.globalData.projectInterface.currentFrame = num;
        var i4;
        var len = this.layers.length;
        if (!this.completeLayers) {
          this.checkLayers(num);
        }
        for (i4 = len - 1; i4 >= 0; i4 -= 1) {
          if (this.completeLayers || this.elements[i4]) {
            this.elements[i4].prepareFrame(num - this.layers[i4].st);
          }
        }
        if (this.globalData._mdf) {
          if (this.renderConfig.clearCanvas === true) {
            this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
          } else {
            this.save();
          }
          for (i4 = len - 1; i4 >= 0; i4 -= 1) {
            if (this.completeLayers || this.elements[i4]) {
              this.elements[i4].renderFrame();
            }
          }
          if (this.renderConfig.clearCanvas !== true) {
            this.restore();
          }
        }
      };
      CanvasRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }
        var element = this.createItem(this.layers[pos], this, this.globalData);
        elements[pos] = element;
        element.initExpressions();
      };
      CanvasRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };
      CanvasRendererBase.prototype.hide = function() {
        this.animationItem.container.style.display = "none";
      };
      CanvasRendererBase.prototype.show = function() {
        this.animationItem.container.style.display = "block";
      };
      function CanvasContext() {
        this.opacity = -1;
        this.transform = createTypedArray("float32", 16);
        this.fillStyle = "";
        this.strokeStyle = "";
        this.lineWidth = "";
        this.lineCap = "";
        this.lineJoin = "";
        this.miterLimit = "";
        this.id = Math.random();
      }
      function CVContextData() {
        this.stack = [];
        this.cArrPos = 0;
        this.cTr = new Matrix();
        var i4;
        var len = 15;
        for (i4 = 0; i4 < len; i4 += 1) {
          var canvasContext = new CanvasContext();
          this.stack[i4] = canvasContext;
        }
        this._length = len;
        this.nativeContext = null;
        this.transformMat = new Matrix();
        this.currentOpacity = 1;
        this.currentFillStyle = "";
        this.appliedFillStyle = "";
        this.currentStrokeStyle = "";
        this.appliedStrokeStyle = "";
        this.currentLineWidth = "";
        this.appliedLineWidth = "";
        this.currentLineCap = "";
        this.appliedLineCap = "";
        this.currentLineJoin = "";
        this.appliedLineJoin = "";
        this.appliedMiterLimit = "";
        this.currentMiterLimit = "";
      }
      CVContextData.prototype.duplicate = function() {
        var newLength = this._length * 2;
        var i4 = 0;
        for (i4 = this._length; i4 < newLength; i4 += 1) {
          this.stack[i4] = new CanvasContext();
        }
        this._length = newLength;
      };
      CVContextData.prototype.reset = function() {
        this.cArrPos = 0;
        this.cTr.reset();
        this.stack[this.cArrPos].opacity = 1;
      };
      CVContextData.prototype.restore = function(forceRestore) {
        this.cArrPos -= 1;
        var currentContext = this.stack[this.cArrPos];
        var transform2 = currentContext.transform;
        var i4;
        var arr = this.cTr.props;
        for (i4 = 0; i4 < 16; i4 += 1) {
          arr[i4] = transform2[i4];
        }
        if (forceRestore) {
          this.nativeContext.restore();
          var prevStack = this.stack[this.cArrPos + 1];
          this.appliedFillStyle = prevStack.fillStyle;
          this.appliedStrokeStyle = prevStack.strokeStyle;
          this.appliedLineWidth = prevStack.lineWidth;
          this.appliedLineCap = prevStack.lineCap;
          this.appliedLineJoin = prevStack.lineJoin;
          this.appliedMiterLimit = prevStack.miterLimit;
        }
        this.nativeContext.setTransform(transform2[0], transform2[1], transform2[4], transform2[5], transform2[12], transform2[13]);
        if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
          this.nativeContext.globalAlpha = currentContext.opacity;
          this.currentOpacity = currentContext.opacity;
        }
        this.currentFillStyle = currentContext.fillStyle;
        this.currentStrokeStyle = currentContext.strokeStyle;
        this.currentLineWidth = currentContext.lineWidth;
        this.currentLineCap = currentContext.lineCap;
        this.currentLineJoin = currentContext.lineJoin;
        this.currentMiterLimit = currentContext.miterLimit;
      };
      CVContextData.prototype.save = function(saveOnNativeFlag) {
        if (saveOnNativeFlag) {
          this.nativeContext.save();
        }
        var props = this.cTr.props;
        if (this._length <= this.cArrPos) {
          this.duplicate();
        }
        var currentStack = this.stack[this.cArrPos];
        var i4;
        for (i4 = 0; i4 < 16; i4 += 1) {
          currentStack.transform[i4] = props[i4];
        }
        this.cArrPos += 1;
        var newStack = this.stack[this.cArrPos];
        newStack.opacity = currentStack.opacity;
        newStack.fillStyle = currentStack.fillStyle;
        newStack.strokeStyle = currentStack.strokeStyle;
        newStack.lineWidth = currentStack.lineWidth;
        newStack.lineCap = currentStack.lineCap;
        newStack.lineJoin = currentStack.lineJoin;
        newStack.miterLimit = currentStack.miterLimit;
      };
      CVContextData.prototype.setOpacity = function(value2) {
        this.stack[this.cArrPos].opacity = value2;
      };
      CVContextData.prototype.setContext = function(value2) {
        this.nativeContext = value2;
      };
      CVContextData.prototype.fillStyle = function(value2) {
        if (this.stack[this.cArrPos].fillStyle !== value2) {
          this.currentFillStyle = value2;
          this.stack[this.cArrPos].fillStyle = value2;
        }
      };
      CVContextData.prototype.strokeStyle = function(value2) {
        if (this.stack[this.cArrPos].strokeStyle !== value2) {
          this.currentStrokeStyle = value2;
          this.stack[this.cArrPos].strokeStyle = value2;
        }
      };
      CVContextData.prototype.lineWidth = function(value2) {
        if (this.stack[this.cArrPos].lineWidth !== value2) {
          this.currentLineWidth = value2;
          this.stack[this.cArrPos].lineWidth = value2;
        }
      };
      CVContextData.prototype.lineCap = function(value2) {
        if (this.stack[this.cArrPos].lineCap !== value2) {
          this.currentLineCap = value2;
          this.stack[this.cArrPos].lineCap = value2;
        }
      };
      CVContextData.prototype.lineJoin = function(value2) {
        if (this.stack[this.cArrPos].lineJoin !== value2) {
          this.currentLineJoin = value2;
          this.stack[this.cArrPos].lineJoin = value2;
        }
      };
      CVContextData.prototype.miterLimit = function(value2) {
        if (this.stack[this.cArrPos].miterLimit !== value2) {
          this.currentMiterLimit = value2;
          this.stack[this.cArrPos].miterLimit = value2;
        }
      };
      CVContextData.prototype.transform = function(props) {
        this.transformMat.cloneFromProps(props);
        var currentTransform = this.cTr;
        this.transformMat.multiply(currentTransform);
        currentTransform.cloneFromProps(this.transformMat.props);
        var trProps = currentTransform.props;
        this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
      };
      CVContextData.prototype.opacity = function(op) {
        var currentOpacity = this.stack[this.cArrPos].opacity;
        currentOpacity *= op < 0 ? 0 : op;
        if (this.stack[this.cArrPos].opacity !== currentOpacity) {
          if (this.currentOpacity !== op) {
            this.nativeContext.globalAlpha = op;
            this.currentOpacity = op;
          }
          this.stack[this.cArrPos].opacity = currentOpacity;
        }
      };
      CVContextData.prototype.fill = function(rule) {
        if (this.appliedFillStyle !== this.currentFillStyle) {
          this.appliedFillStyle = this.currentFillStyle;
          this.nativeContext.fillStyle = this.appliedFillStyle;
        }
        this.nativeContext.fill(rule);
      };
      CVContextData.prototype.fillRect = function(x2, y2, w2, h2) {
        if (this.appliedFillStyle !== this.currentFillStyle) {
          this.appliedFillStyle = this.currentFillStyle;
          this.nativeContext.fillStyle = this.appliedFillStyle;
        }
        this.nativeContext.fillRect(x2, y2, w2, h2);
      };
      CVContextData.prototype.stroke = function() {
        if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
          this.appliedStrokeStyle = this.currentStrokeStyle;
          this.nativeContext.strokeStyle = this.appliedStrokeStyle;
        }
        if (this.appliedLineWidth !== this.currentLineWidth) {
          this.appliedLineWidth = this.currentLineWidth;
          this.nativeContext.lineWidth = this.appliedLineWidth;
        }
        if (this.appliedLineCap !== this.currentLineCap) {
          this.appliedLineCap = this.currentLineCap;
          this.nativeContext.lineCap = this.appliedLineCap;
        }
        if (this.appliedLineJoin !== this.currentLineJoin) {
          this.appliedLineJoin = this.currentLineJoin;
          this.nativeContext.lineJoin = this.appliedLineJoin;
        }
        if (this.appliedMiterLimit !== this.currentMiterLimit) {
          this.appliedMiterLimit = this.currentMiterLimit;
          this.nativeContext.miterLimit = this.appliedMiterLimit;
        }
        this.nativeContext.stroke();
      };
      function CVCompElement(data2, globalData2, comp2) {
        this.completeLayers = false;
        this.layers = data2.layers;
        this.pendingElements = [];
        this.elements = createSizedArray(this.layers.length);
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
      CVCompElement.prototype.renderInnerContent = function() {
        var ctx = this.canvasContext;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.data.w, 0);
        ctx.lineTo(this.data.w, this.data.h);
        ctx.lineTo(0, this.data.h);
        ctx.lineTo(0, 0);
        ctx.clip();
        var i4;
        var len = this.layers.length;
        for (i4 = len - 1; i4 >= 0; i4 -= 1) {
          if (this.completeLayers || this.elements[i4]) {
            this.elements[i4].renderFrame();
          }
        }
      };
      CVCompElement.prototype.destroy = function() {
        var i4;
        var len = this.layers.length;
        for (i4 = len - 1; i4 >= 0; i4 -= 1) {
          if (this.elements[i4]) {
            this.elements[i4].destroy();
          }
        }
        this.layers = null;
        this.elements = null;
      };
      CVCompElement.prototype.createComp = function(data2) {
        return new CVCompElement(data2, this.globalData, this);
      };
      function CanvasRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.renderConfig = {
          clearCanvas: config && config.clearCanvas !== void 0 ? config.clearCanvas : true,
          context: config && config.context || null,
          progressiveLoad: config && config.progressiveLoad || false,
          preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          contentVisibility: config && config.contentVisibility || "visible",
          className: config && config.className || "",
          id: config && config.id || "",
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.renderConfig.dpr = config && config.dpr || 1;
        if (this.animationItem.wrapper) {
          this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
        }
        this.renderedFrame = -1;
        this.globalData = {
          frameNum: -1,
          _mdf: false,
          renderConfig: this.renderConfig,
          currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = "canvas";
        if (this.renderConfig.clearCanvas) {
          this.ctxTransform = this.contextData.transform.bind(this.contextData);
          this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
          this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
          this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
          this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
          this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
          this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
          this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
          this.ctxFill = this.contextData.fill.bind(this.contextData);
          this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
          this.ctxStroke = this.contextData.stroke.bind(this.contextData);
          this.save = this.contextData.save.bind(this.contextData);
        }
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer);
      CanvasRenderer.prototype.createComp = function(data2) {
        return new CVCompElement(data2, this.globalData, this);
      };
      function HBaseElement() {
      }
      HBaseElement.prototype = {
        checkBlendMode: function checkBlendMode() {
        },
        initRendererElement: function initRendererElement() {
          this.baseElement = createTag(this.data.tg || "div");
          if (this.data.hasMask) {
            this.svgElement = createNS("svg");
            this.layerElement = createNS("g");
            this.maskedElement = this.layerElement;
            this.svgElement.appendChild(this.layerElement);
            this.baseElement.appendChild(this.svgElement);
          } else {
            this.layerElement = this.baseElement;
          }
          styleDiv(this.baseElement);
        },
        createContainerElements: function createContainerElements() {
          this.renderableEffectsManager = new CVEffects(this);
          this.transformedElement = this.baseElement;
          this.maskedElement = this.layerElement;
          if (this.data.ln) {
            this.layerElement.setAttribute("id", this.data.ln);
          }
          if (this.data.cl) {
            this.layerElement.setAttribute("class", this.data.cl);
          }
          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
          if (this.finalTransform._matMdf) {
            var matrixValue = this.finalTransform.mat.toCSS();
            transformedElementStyle.transform = matrixValue;
            transformedElementStyle.webkitTransform = matrixValue;
          }
          if (this.finalTransform._opMdf) {
            transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
          }
        },
        renderFrame: function renderFrame() {
          if (this.data.hd || this.hidden) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderElement();
          this.renderInnerContent();
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.layerElement = null;
          this.transformedElement = null;
          if (this.matteElement) {
            this.matteElement = null;
          }
          if (this.maskManager) {
            this.maskManager.destroy();
            this.maskManager = null;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function addEffects() {
        },
        setMatte: function setMatte() {
        }
      };
      HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
      HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
      HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
      function HSolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
      HSolidElement.prototype.createContent = function() {
        var rect;
        if (this.data.hasMask) {
          rect = createNS("rect");
          rect.setAttribute("width", this.data.sw);
          rect.setAttribute("height", this.data.sh);
          rect.setAttribute("fill", this.data.sc);
          this.svgElement.setAttribute("width", this.data.sw);
          this.svgElement.setAttribute("height", this.data.sh);
        } else {
          rect = createTag("div");
          rect.style.width = this.data.sw + "px";
          rect.style.height = this.data.sh + "px";
          rect.style.backgroundColor = this.data.sc;
        }
        this.layerElement.appendChild(rect);
      };
      function HShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.shapeModifiers = [];
        this.itemsData = [];
        this.processedElements = [];
        this.animatedContents = [];
        this.shapesContainer = createNS("g");
        this.initElement(data2, globalData2, comp2);
        this.prevViewData = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
      }
      extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
      HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
      HShapeElement.prototype.createContent = function() {
        var cont;
        this.baseElement.style.fontSize = 0;
        if (this.data.hasMask) {
          this.layerElement.appendChild(this.shapesContainer);
          cont = this.svgElement;
        } else {
          cont = createNS("svg");
          var size = this.comp.data ? this.comp.data : this.globalData.compSize;
          cont.setAttribute("width", size.w);
          cont.setAttribute("height", size.h);
          cont.appendChild(this.shapesContainer);
          this.layerElement.appendChild(cont);
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
        this.filterUniqueShapes();
        this.shapeCont = cont;
      };
      HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
        var i4;
        var len = transformers.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          point = transformers[i4].mProps.v.applyToPointArray(point[0], point[1], 0);
        }
        return point;
      };
      HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
        var shape = item.sh.v;
        var transformers = item.transformers;
        var i4;
        var len = shape._length;
        var vPoint;
        var oPoint;
        var nextIPoint;
        var nextVPoint;
        if (len <= 1) {
          return;
        }
        for (i4 = 0; i4 < len - 1; i4 += 1) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i4]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i4]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[i4 + 1]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[i4 + 1]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
        if (shape.c) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i4]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i4]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
      };
      HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
        var bounds = this.shapeBoundingBox;
        boundingBox.x = bmMin(bounds.left, boundingBox.x);
        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
        boundingBox.y = bmMin(bounds.top, boundingBox.y);
        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
      };
      HShapeElement.prototype.shapeBoundingBox = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      HShapeElement.prototype.tempBoundingBox = {
        x: 0,
        xMax: 0,
        y: 0,
        yMax: 0,
        width: 0,
        height: 0
      };
      HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
        var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
        for (var a3, b2, c2, t5, b2ac, t1, t22, i4 = 0; i4 < 2; ++i4) {
          b2 = 6 * p0[i4] - 12 * p1[i4] + 6 * p2[i4];
          a3 = -3 * p0[i4] + 9 * p1[i4] - 9 * p2[i4] + 3 * p3[i4];
          c2 = 3 * p1[i4] - 3 * p0[i4];
          b2 |= 0;
          a3 |= 0;
          c2 |= 0;
          if (a3 === 0 && b2 === 0) {
          } else if (a3 === 0) {
            t5 = -c2 / b2;
            if (t5 > 0 && t5 < 1) {
              bounds[i4].push(this.calculateF(t5, p0, p1, p2, p3, i4));
            }
          } else {
            b2ac = b2 * b2 - 4 * c2 * a3;
            if (b2ac >= 0) {
              t1 = (-b2 + bmSqrt(b2ac)) / (2 * a3);
              if (t1 > 0 && t1 < 1)
                bounds[i4].push(this.calculateF(t1, p0, p1, p2, p3, i4));
              t22 = (-b2 - bmSqrt(b2ac)) / (2 * a3);
              if (t22 > 0 && t22 < 1)
                bounds[i4].push(this.calculateF(t22, p0, p1, p2, p3, i4));
            }
          }
        }
        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
      };
      HShapeElement.prototype.calculateF = function(t5, p0, p1, p2, p3, i4) {
        return bmPow(1 - t5, 3) * p0[i4] + 3 * bmPow(1 - t5, 2) * t5 * p1[i4] + 3 * (1 - t5) * bmPow(t5, 2) * p2[i4] + bmPow(t5, 3) * p3[i4];
      };
      HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
        var i4;
        var len = itemsData.length;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (itemsData[i4] && itemsData[i4].sh) {
            this.calculateShapeBoundingBox(itemsData[i4], boundingBox);
          } else if (itemsData[i4] && itemsData[i4].it) {
            this.calculateBoundingBox(itemsData[i4].it, boundingBox);
          } else if (itemsData[i4] && itemsData[i4].style && itemsData[i4].w) {
            this.expandStrokeBoundingBox(itemsData[i4].w, boundingBox);
          }
        }
      };
      HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
        var width2 = 0;
        if (widthProperty.keyframes) {
          for (var i4 = 0; i4 < widthProperty.keyframes.length; i4 += 1) {
            var kfw = widthProperty.keyframes[i4].s;
            if (kfw > width2) {
              width2 = kfw;
            }
          }
          width2 *= widthProperty.mult;
        } else {
          width2 = widthProperty.v * widthProperty.mult;
        }
        boundingBox.x -= width2;
        boundingBox.xMax += width2;
        boundingBox.y -= width2;
        boundingBox.yMax += width2;
      };
      HShapeElement.prototype.currentBoxContains = function(box) {
        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
      };
      HShapeElement.prototype.renderInnerContent = function() {
        this._renderShapeFrame();
        if (!this.hidden && (this._isFirstFrame || this._mdf)) {
          var tempBoundingBox = this.tempBoundingBox;
          var max = 999999;
          tempBoundingBox.x = max;
          tempBoundingBox.xMax = -max;
          tempBoundingBox.y = max;
          tempBoundingBox.yMax = -max;
          this.calculateBoundingBox(this.itemsData, tempBoundingBox);
          tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
          tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
          if (this.currentBoxContains(tempBoundingBox)) {
            return;
          }
          var changed = false;
          if (this.currentBBox.w !== tempBoundingBox.width) {
            this.currentBBox.w = tempBoundingBox.width;
            this.shapeCont.setAttribute("width", tempBoundingBox.width);
            changed = true;
          }
          if (this.currentBBox.h !== tempBoundingBox.height) {
            this.currentBBox.h = tempBoundingBox.height;
            this.shapeCont.setAttribute("height", tempBoundingBox.height);
            changed = true;
          }
          if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
            this.currentBBox.w = tempBoundingBox.width;
            this.currentBBox.h = tempBoundingBox.height;
            this.currentBBox.x = tempBoundingBox.x;
            this.currentBBox.y = tempBoundingBox.y;
            this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
            var shapeStyle = this.shapeCont.style;
            var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            shapeStyle.transform = shapeTransform;
            shapeStyle.webkitTransform = shapeTransform;
          }
        }
      };
      function HTextElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.textPaths = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
        this.renderType = "svg";
        this.isMasked = false;
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
      HTextElement.prototype.createContent = function() {
        this.isMasked = this.checkMasks();
        if (this.isMasked) {
          this.renderType = "svg";
          this.compW = this.comp.data.w;
          this.compH = this.comp.data.h;
          this.svgElement.setAttribute("width", this.compW);
          this.svgElement.setAttribute("height", this.compH);
          var g2 = createNS("g");
          this.maskedElement.appendChild(g2);
          this.innerElem = g2;
        } else {
          this.renderType = "html";
          this.innerElem = this.layerElement;
        }
        this.checkParenting();
      };
      HTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var innerElemStyle = this.innerElem.style;
        var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
        innerElemStyle.fill = textColor;
        innerElemStyle.color = textColor;
        if (documentData.sc) {
          innerElemStyle.stroke = this.buildColor(documentData.sc);
          innerElemStyle.strokeWidth = documentData.sw + "px";
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (!this.globalData.fontManager.chars) {
          innerElemStyle.fontSize = documentData.finalSize + "px";
          innerElemStyle.lineHeight = documentData.finalSize + "px";
          if (fontData.fClass) {
            this.innerElem.className = fontData.fClass;
          } else {
            innerElemStyle.fontFamily = fontData.fFamily;
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            innerElemStyle.fontStyle = fStyle;
            innerElemStyle.fontWeight = fWeight;
          }
        }
        var i4;
        var len;
        var letters = documentData.l;
        len = letters.length;
        var tSpan;
        var tParent;
        var tCont;
        var matrixHelper = this.mHelper;
        var shapes;
        var shapeStr = "";
        var cnt = 0;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.globalData.fontManager.chars) {
            if (!this.textPaths[cnt]) {
              tSpan = createNS("path");
              tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
              tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
              tSpan.setAttribute("stroke-miterlimit", "4");
            } else {
              tSpan = this.textPaths[cnt];
            }
            if (!this.isMasked) {
              if (this.textSpans[cnt]) {
                tParent = this.textSpans[cnt];
                tCont = tParent.children[0];
              } else {
                tParent = createTag("div");
                tParent.style.lineHeight = 0;
                tCont = createNS("svg");
                tCont.appendChild(tSpan);
                styleDiv(tParent);
              }
            }
          } else if (!this.isMasked) {
            if (this.textSpans[cnt]) {
              tParent = this.textSpans[cnt];
              tSpan = this.textPaths[cnt];
            } else {
              tParent = createTag("span");
              styleDiv(tParent);
              tSpan = createTag("span");
              styleDiv(tSpan);
              tParent.appendChild(tSpan);
            }
          } else {
            tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
          }
          if (this.globalData.fontManager.chars) {
            var charData = this.globalData.fontManager.getCharData(documentData.finalText[i4], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            var shapeData;
            if (charData) {
              shapeData = charData.data;
            } else {
              shapeData = null;
            }
            matrixHelper.reset();
            if (shapeData && shapeData.shapes && shapeData.shapes.length) {
              shapes = shapeData.shapes[0].it;
              matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
              shapeStr = this.createPathShape(matrixHelper, shapes);
              tSpan.setAttribute("d", shapeStr);
            }
            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);
              if (shapeData && shapeData.shapes) {
                document.body.appendChild(tCont);
                var boundingBox = tCont.getBBox();
                tCont.setAttribute("width", boundingBox.width + 2);
                tCont.setAttribute("height", boundingBox.height + 2);
                tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                var tContStyle = tCont.style;
                var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                tContStyle.transform = tContTranslation;
                tContStyle.webkitTransform = tContTranslation;
                letters[i4].yOffset = boundingBox.y - 1;
              } else {
                tCont.setAttribute("width", 1);
                tCont.setAttribute("height", 1);
              }
              tParent.appendChild(tCont);
            } else {
              this.innerElem.appendChild(tSpan);
            }
          } else {
            tSpan.textContent = letters[i4].val;
            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);
              var tStyle = tSpan.style;
              var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
              tStyle.transform = tSpanTranslation;
              tStyle.webkitTransform = tSpanTranslation;
            } else {
              this.innerElem.appendChild(tSpan);
            }
          }
          if (!this.isMasked) {
            this.textSpans[cnt] = tParent;
          } else {
            this.textSpans[cnt] = tSpan;
          }
          this.textSpans[cnt].style.display = "block";
          this.textPaths[cnt] = tSpan;
          cnt += 1;
        }
        while (cnt < this.textSpans.length) {
          this.textSpans[cnt].style.display = "none";
          cnt += 1;
        }
      };
      HTextElement.prototype.renderInnerContent = function() {
        this.validateText();
        var svgStyle;
        if (this.data.singleShape) {
          if (!this._isFirstFrame && !this.lettersChangedFlag) {
            return;
          }
          if (this.isMasked && this.finalTransform._matMdf) {
            this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
            svgStyle = this.svgElement.style;
            var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
            svgStyle.transform = translation;
            svgStyle.webkitTransform = translation;
          }
        }
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
          return;
        }
        var i4;
        var len;
        var count = 0;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var textSpan;
        var textPath;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (letters[i4].n) {
            count += 1;
          } else {
            textSpan = this.textSpans[i4];
            textPath = this.textPaths[i4];
            renderedLetter = renderedLetters[count];
            count += 1;
            if (renderedLetter._mdf.m) {
              if (!this.isMasked) {
                textSpan.style.webkitTransform = renderedLetter.m;
                textSpan.style.transform = renderedLetter.m;
              } else {
                textSpan.setAttribute("transform", renderedLetter.m);
              }
            }
            textSpan.style.opacity = renderedLetter.o;
            if (renderedLetter.sw && renderedLetter._mdf.sw) {
              textPath.setAttribute("stroke-width", renderedLetter.sw);
            }
            if (renderedLetter.sc && renderedLetter._mdf.sc) {
              textPath.setAttribute("stroke", renderedLetter.sc);
            }
            if (renderedLetter.fc && renderedLetter._mdf.fc) {
              textPath.setAttribute("fill", renderedLetter.fc);
              textPath.style.color = renderedLetter.fc;
            }
          }
        }
        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
          var boundingBox = this.innerElem.getBBox();
          if (this.currentBBox.w !== boundingBox.width) {
            this.currentBBox.w = boundingBox.width;
            this.svgElement.setAttribute("width", boundingBox.width);
          }
          if (this.currentBBox.h !== boundingBox.height) {
            this.currentBBox.h = boundingBox.height;
            this.svgElement.setAttribute("height", boundingBox.height);
          }
          var margin = 1;
          if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
            this.currentBBox.w = boundingBox.width + margin * 2;
            this.currentBBox.h = boundingBox.height + margin * 2;
            this.currentBBox.x = boundingBox.x - margin;
            this.currentBBox.y = boundingBox.y - margin;
            this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
            svgStyle = this.svgElement.style;
            var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            svgStyle.transform = svgTransform;
            svgStyle.webkitTransform = svgTransform;
          }
        }
      };
      function HCameraElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initHierarchy();
        var getProp = PropertyFactory.getProp;
        this.pe = getProp(this, data2.pe, 0, 0, this);
        if (data2.ks.p.s) {
          this.px = getProp(this, data2.ks.p.x, 1, 0, this);
          this.py = getProp(this, data2.ks.p.y, 1, 0, this);
          this.pz = getProp(this, data2.ks.p.z, 1, 0, this);
        } else {
          this.p = getProp(this, data2.ks.p, 1, 0, this);
        }
        if (data2.ks.a) {
          this.a = getProp(this, data2.ks.a, 1, 0, this);
        }
        if (data2.ks.or.k.length && data2.ks.or.k[0].to) {
          var i4;
          var len = data2.ks.or.k.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            data2.ks.or.k[i4].to = null;
            data2.ks.or.k[i4].ti = null;
          }
        }
        this.or = getProp(this, data2.ks.or, 1, degToRads, this);
        this.or.sh = true;
        this.rx = getProp(this, data2.ks.rx, 0, degToRads, this);
        this.ry = getProp(this, data2.ks.ry, 0, degToRads, this);
        this.rz = getProp(this, data2.ks.rz, 0, degToRads, this);
        this.mat = new Matrix();
        this._prevMat = new Matrix();
        this._isFirstFrame = true;
        this.finalTransform = {
          mProp: this
        };
      }
      extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
      HCameraElement.prototype.setup = function() {
        var i4;
        var len = this.comp.threeDElements.length;
        var comp2;
        var perspectiveStyle;
        var containerStyle;
        for (i4 = 0; i4 < len; i4 += 1) {
          comp2 = this.comp.threeDElements[i4];
          if (comp2.type === "3d") {
            perspectiveStyle = comp2.perspectiveElem.style;
            containerStyle = comp2.container.style;
            var perspective = this.pe.v + "px";
            var origin = "0px 0px 0px";
            var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            perspectiveStyle.perspective = perspective;
            perspectiveStyle.webkitPerspective = perspective;
            containerStyle.transformOrigin = origin;
            containerStyle.mozTransformOrigin = origin;
            containerStyle.webkitTransformOrigin = origin;
            perspectiveStyle.transform = matrix;
            perspectiveStyle.webkitTransform = matrix;
          }
        }
      };
      HCameraElement.prototype.createElements = function() {
      };
      HCameraElement.prototype.hide = function() {
      };
      HCameraElement.prototype.renderFrame = function() {
        var _mdf = this._isFirstFrame;
        var i4;
        var len;
        if (this.hierarchy) {
          len = this.hierarchy.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            _mdf = this.hierarchy[i4].finalTransform.mProp._mdf || _mdf;
          }
        }
        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
          this.mat.reset();
          if (this.hierarchy) {
            len = this.hierarchy.length - 1;
            for (i4 = len; i4 >= 0; i4 -= 1) {
              var mTransf = this.hierarchy[i4].finalTransform.mProp;
              this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
              this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
              this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
              this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
              this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
            }
          }
          if (this.p) {
            this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
          } else {
            this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
          }
          if (this.a) {
            var diffVector;
            if (this.p) {
              diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
            } else {
              diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
            }
            var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
            var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
            var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
            var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
            var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
            this.mat.rotateY(mRotationY).rotateX(-mRotationX);
          }
          this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
          this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
          this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
          this.mat.translate(0, 0, this.pe.v);
          var hasMatrixChanged = !this._prevMat.equals(this.mat);
          if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
            len = this.comp.threeDElements.length;
            var comp2;
            var perspectiveStyle;
            var containerStyle;
            for (i4 = 0; i4 < len; i4 += 1) {
              comp2 = this.comp.threeDElements[i4];
              if (comp2.type === "3d") {
                if (hasMatrixChanged) {
                  var matValue = this.mat.toCSS();
                  containerStyle = comp2.container.style;
                  containerStyle.transform = matValue;
                  containerStyle.webkitTransform = matValue;
                }
                if (this.pe._mdf) {
                  perspectiveStyle = comp2.perspectiveElem.style;
                  perspectiveStyle.perspective = this.pe.v + "px";
                  perspectiveStyle.webkitPerspective = this.pe.v + "px";
                }
              }
            }
            this.mat.clone(this._prevMat);
          }
        }
        this._isFirstFrame = false;
      };
      HCameraElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
      };
      HCameraElement.prototype.destroy = function() {
      };
      HCameraElement.prototype.getBaseElement = function() {
        return null;
      };
      function HImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
      HImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        var img = new Image();
        if (this.data.hasMask) {
          this.imageElem = createNS("image");
          this.imageElem.setAttribute("width", this.assetData.w + "px");
          this.imageElem.setAttribute("height", this.assetData.h + "px");
          this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
          this.layerElement.appendChild(this.imageElem);
          this.baseElement.setAttribute("width", this.assetData.w);
          this.baseElement.setAttribute("height", this.assetData.h);
        } else {
          this.layerElement.appendChild(img);
        }
        img.crossOrigin = "anonymous";
        img.src = assetPath;
        if (this.data.ln) {
          this.baseElement.setAttribute("id", this.data.ln);
        }
      };
      function HybridRendererBase(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config && config.className || "",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "400%",
            height: config && config.filterSize && config.filterSize.height || "400%",
            x: config && config.filterSize && config.filterSize.x || "-100%",
            y: config && config.filterSize && config.filterSize.y || "-100%"
          }
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
      }
      extendPrototype([BaseRenderer], HybridRendererBase);
      HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
      HybridRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };
      HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newDOMElement = element.getBaseElement();
        if (!newDOMElement) {
          return;
        }
        var layer = this.layers[pos];
        if (!layer.ddd || !this.supports3d) {
          if (this.threeDElements) {
            this.addTo3dContainer(newDOMElement, pos);
          } else {
            var i4 = 0;
            var nextDOMElement;
            var nextLayer;
            var tmpDOMElement;
            while (i4 < pos) {
              if (this.elements[i4] && this.elements[i4] !== true && this.elements[i4].getBaseElement) {
                nextLayer = this.elements[i4];
                tmpDOMElement = this.layers[i4].ddd ? this.getThreeDContainerByPos(i4) : nextLayer.getBaseElement();
                nextDOMElement = tmpDOMElement || nextDOMElement;
              }
              i4 += 1;
            }
            if (nextDOMElement) {
              if (!layer.ddd || !this.supports3d) {
                this.layerElement.insertBefore(newDOMElement, nextDOMElement);
              }
            } else if (!layer.ddd || !this.supports3d) {
              this.layerElement.appendChild(newDOMElement);
            }
          }
        } else {
          this.addTo3dContainer(newDOMElement, pos);
        }
      };
      HybridRendererBase.prototype.createShape = function(data2) {
        if (!this.supports3d) {
          return new SVGShapeElement(data2, this.globalData, this);
        }
        return new HShapeElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createText = function(data2) {
        if (!this.supports3d) {
          return new SVGTextLottieElement(data2, this.globalData, this);
        }
        return new HTextElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createCamera = function(data2) {
        this.camera = new HCameraElement(data2, this.globalData, this);
        return this.camera;
      };
      HybridRendererBase.prototype.createImage = function(data2) {
        if (!this.supports3d) {
          return new IImageElement(data2, this.globalData, this);
        }
        return new HImageElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createSolid = function(data2) {
        if (!this.supports3d) {
          return new ISolidElement(data2, this.globalData, this);
        }
        return new HSolidElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
      HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
        var i4 = 0;
        var len = this.threeDElements.length;
        while (i4 < len) {
          if (this.threeDElements[i4].startPos <= pos && this.threeDElements[i4].endPos >= pos) {
            return this.threeDElements[i4].perspectiveElem;
          }
          i4 += 1;
        }
        return null;
      };
      HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
        var perspectiveElem = createTag("div");
        var style;
        var containerStyle;
        styleDiv(perspectiveElem);
        var container = createTag("div");
        styleDiv(container);
        if (type === "3d") {
          style = perspectiveElem.style;
          style.width = this.globalData.compSize.w + "px";
          style.height = this.globalData.compSize.h + "px";
          var center = "50% 50%";
          style.webkitTransformOrigin = center;
          style.mozTransformOrigin = center;
          style.transformOrigin = center;
          containerStyle = container.style;
          var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
          containerStyle.transform = matrix;
          containerStyle.webkitTransform = matrix;
        }
        perspectiveElem.appendChild(container);
        var threeDContainerData = {
          container,
          perspectiveElem,
          startPos: pos,
          endPos: pos,
          type
        };
        this.threeDElements.push(threeDContainerData);
        return threeDContainerData;
      };
      HybridRendererBase.prototype.build3dContainers = function() {
        var i4;
        var len = this.layers.length;
        var lastThreeDContainerData;
        var currentContainer = "";
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.layers[i4].ddd && this.layers[i4].ty !== 3) {
            if (currentContainer !== "3d") {
              currentContainer = "3d";
              lastThreeDContainerData = this.createThreeDContainer(i4, "3d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i4);
          } else {
            if (currentContainer !== "2d") {
              currentContainer = "2d";
              lastThreeDContainerData = this.createThreeDContainer(i4, "2d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i4);
          }
        }
        len = this.threeDElements.length;
        for (i4 = len - 1; i4 >= 0; i4 -= 1) {
          this.resizerElem.appendChild(this.threeDElements[i4].perspectiveElem);
        }
      };
      HybridRendererBase.prototype.addTo3dContainer = function(elem2, pos) {
        var i4 = 0;
        var len = this.threeDElements.length;
        while (i4 < len) {
          if (pos <= this.threeDElements[i4].endPos) {
            var j2 = this.threeDElements[i4].startPos;
            var nextElement;
            while (j2 < pos) {
              if (this.elements[j2] && this.elements[j2].getBaseElement) {
                nextElement = this.elements[j2].getBaseElement();
              }
              j2 += 1;
            }
            if (nextElement) {
              this.threeDElements[i4].container.insertBefore(elem2, nextElement);
            } else {
              this.threeDElements[i4].container.appendChild(elem2);
            }
            break;
          }
          i4 += 1;
        }
      };
      HybridRendererBase.prototype.configAnimation = function(animData) {
        var resizerElem = createTag("div");
        var wrapper = this.animationItem.wrapper;
        var style = resizerElem.style;
        style.width = animData.w + "px";
        style.height = animData.h + "px";
        this.resizerElem = resizerElem;
        styleDiv(resizerElem);
        style.transformStyle = "flat";
        style.mozTransformStyle = "flat";
        style.webkitTransformStyle = "flat";
        if (this.renderConfig.className) {
          resizerElem.setAttribute("class", this.renderConfig.className);
        }
        wrapper.appendChild(resizerElem);
        style.overflow = "hidden";
        var svg = createNS("svg");
        svg.setAttribute("width", "1");
        svg.setAttribute("height", "1");
        styleDiv(svg);
        this.resizerElem.appendChild(svg);
        var defs = createNS("defs");
        svg.appendChild(defs);
        this.data = animData;
        this.setupGlobalData(animData, svg);
        this.globalData.defs = defs;
        this.layers = animData.layers;
        this.layerElement = this.resizerElem;
        this.build3dContainers();
        this.updateContainerSize();
      };
      HybridRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        this.animationItem.container = null;
        this.globalData.defs = null;
        var i4;
        var len = this.layers ? this.layers.length : 0;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.elements[i4] && this.elements[i4].destroy) {
            this.elements[i4].destroy();
          }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };
      HybridRendererBase.prototype.updateContainerSize = function() {
        var elementWidth = this.animationItem.wrapper.offsetWidth;
        var elementHeight = this.animationItem.wrapper.offsetHeight;
        var elementRel = elementWidth / elementHeight;
        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
        var sx;
        var sy;
        var tx;
        var ty;
        if (animationRel > elementRel) {
          sx = elementWidth / this.globalData.compSize.w;
          sy = elementWidth / this.globalData.compSize.w;
          tx = 0;
          ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
        } else {
          sx = elementHeight / this.globalData.compSize.h;
          sy = elementHeight / this.globalData.compSize.h;
          tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
          ty = 0;
        }
        var style = this.resizerElem.style;
        style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
        style.transform = style.webkitTransform;
      };
      HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
      HybridRendererBase.prototype.hide = function() {
        this.resizerElem.style.display = "none";
      };
      HybridRendererBase.prototype.show = function() {
        this.resizerElem.style.display = "block";
      };
      HybridRendererBase.prototype.initItems = function() {
        this.buildAllItems();
        if (this.camera) {
          this.camera.setup();
        } else {
          var cWidth = this.globalData.compSize.w;
          var cHeight = this.globalData.compSize.h;
          var i4;
          var len = this.threeDElements.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            var style = this.threeDElements[i4].perspectiveElem.style;
            style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
            style.perspective = style.webkitPerspective;
          }
        }
      };
      HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
        var i4;
        var len = assets.length;
        var floatingContainer = createTag("div");
        for (i4 = 0; i4 < len; i4 += 1) {
          if (assets[i4].xt) {
            var comp2 = this.createComp(assets[i4], floatingContainer, this.globalData.comp, null);
            comp2.initExpressions();
            this.globalData.projectInterface.registerComposition(comp2);
          }
        }
      };
      function HCompElement(data2, globalData2, comp2) {
        this.layers = data2.layers;
        this.supports3d = !data2.hasMask;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
      HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
      HCompElement.prototype.createContainerElements = function() {
        this._createBaseContainerElements();
        if (this.data.hasMask) {
          this.svgElement.setAttribute("width", this.data.w);
          this.svgElement.setAttribute("height", this.data.h);
          this.transformedElement = this.baseElement;
        } else {
          this.transformedElement = this.layerElement;
        }
      };
      HCompElement.prototype.addTo3dContainer = function(elem2, pos) {
        var j2 = 0;
        var nextElement;
        while (j2 < pos) {
          if (this.elements[j2] && this.elements[j2].getBaseElement) {
            nextElement = this.elements[j2].getBaseElement();
          }
          j2 += 1;
        }
        if (nextElement) {
          this.layerElement.insertBefore(elem2, nextElement);
        } else {
          this.layerElement.appendChild(elem2);
        }
      };
      HCompElement.prototype.createComp = function(data2) {
        if (!this.supports3d) {
          return new SVGCompElement(data2, this.globalData, this);
        }
        return new HCompElement(data2, this.globalData, this);
      };
      function HybridRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config && config.className || "",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "400%",
            height: config && config.filterSize && config.filterSize.height || "400%",
            x: config && config.filterSize && config.filterSize.x || "-100%",
            y: config && config.filterSize && config.filterSize.y || "-100%"
          },
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
      }
      extendPrototype([HybridRendererBase], HybridRenderer);
      HybridRenderer.prototype.createComp = function(data2) {
        if (!this.supports3d) {
          return new SVGCompElement(data2, this.globalData, this);
        }
        return new HCompElement(data2, this.globalData, this);
      };
      var CompExpressionInterface = function() {
        return function(comp2) {
          function _thisLayerFunction(name2) {
            var i4 = 0;
            var len = comp2.layers.length;
            while (i4 < len) {
              if (comp2.layers[i4].nm === name2 || comp2.layers[i4].ind === name2) {
                return comp2.elements[i4].layerInterface;
              }
              i4 += 1;
            }
            return null;
          }
          Object.defineProperty(_thisLayerFunction, "_name", {
            value: comp2.data.nm
          });
          _thisLayerFunction.layer = _thisLayerFunction;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.height = comp2.data.h || comp2.globalData.compSize.h;
          _thisLayerFunction.width = comp2.data.w || comp2.globalData.compSize.w;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.frameDuration = 1 / comp2.globalData.frameRate;
          _thisLayerFunction.displayStartTime = 0;
          _thisLayerFunction.numLayers = comp2.layers.length;
          return _thisLayerFunction;
        };
      }();
      function _typeof$2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$2 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$2 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$2(obj);
      }
      function seedRandom(pool, math) {
        var global2 = this, width2 = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width2, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask2 = width2 - 1, nodecrypto;
        function seedrandom(seed, options, callback) {
          var key2 = [];
          options = options === true ? {
            entropy: true
          } : options || {};
          var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key2);
          var arc4 = new ARC4(key2);
          var prng = function prng2() {
            var n3 = arc4.g(chunks), d2 = startdenom, x2 = 0;
            while (n3 < significance) {
              n3 = (n3 + x2) * width2;
              d2 *= width2;
              x2 = arc4.g(1);
            }
            while (n3 >= overflow) {
              n3 /= 2;
              d2 /= 2;
              x2 >>>= 1;
            }
            return (n3 + x2) / d2;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng["double"] = prng;
          mixkey(tostring(arc4.S), pool);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
        }
        math["seed" + rngname] = seedrandom;
        function ARC4(key2) {
          var t5, keylen = key2.length, me = this, i4 = 0, j2 = me.i = me.j = 0, s2 = me.S = [];
          if (!keylen) {
            key2 = [keylen++];
          }
          while (i4 < width2) {
            s2[i4] = i4++;
          }
          for (i4 = 0; i4 < width2; i4++) {
            s2[i4] = s2[j2 = mask2 & j2 + key2[i4 % keylen] + (t5 = s2[i4])];
            s2[j2] = t5;
          }
          me.g = function(count) {
            var t6, r3 = 0, i5 = me.i, j3 = me.j, s3 = me.S;
            while (count--) {
              t6 = s3[i5 = mask2 & i5 + 1];
              r3 = r3 * width2 + s3[mask2 & (s3[i5] = s3[j3 = mask2 & j3 + t6]) + (s3[j3] = t6)];
            }
            me.i = i5;
            me.j = j3;
            return r3;
          };
        }
        function copy(f3, t5) {
          t5.i = f3.i;
          t5.j = f3.j;
          t5.S = f3.S.slice();
          return t5;
        }
        function flatten(obj, depth) {
          var result = [], typ = _typeof$2(obj), prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten(obj[prop], depth - 1));
              } catch (e5) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key2) {
          var stringseed = seed + "", smear, j2 = 0;
          while (j2 < stringseed.length) {
            key2[mask2 & j2] = mask2 & (smear ^= key2[mask2 & j2] * 19) + stringseed.charCodeAt(j2++);
          }
          return tostring(key2);
        }
        function autoseed() {
          try {
            if (nodecrypto) {
              return tostring(nodecrypto.randomBytes(width2));
            }
            var out = new Uint8Array(width2);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
            return tostring(out);
          } catch (e5) {
            var browser = global2.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
          }
        }
        function tostring(a3) {
          return String.fromCharCode.apply(0, a3);
        }
        mixkey(math.random(), pool);
      }
      ;
      function initialize$2(BMMath2) {
        seedRandom([], BMMath2);
      }
      var propTypes = {
        SHAPE: "shape"
      };
      function _typeof$1(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$1 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$1 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$1(obj);
      }
      var ExpressionManager = function() {
        "use strict";
        var ob = {};
        var Math = BMMath;
        var window = null;
        var document = null;
        var XMLHttpRequest = null;
        var fetch = null;
        var frames = null;
        var _lottieGlobal = {};
        initialize$2(BMMath);
        function resetFrame() {
          _lottieGlobal = {};
        }
        function $bm_isInstanceOfArray(arr) {
          return arr.constructor === Array || arr.constructor === Float32Array;
        }
        function isNumerable(tOfV, v2) {
          return tOfV === "number" || v2 instanceof Number || tOfV === "boolean" || tOfV === "string";
        }
        function $bm_neg(a3) {
          var tOfA = _typeof$1(a3);
          if (tOfA === "number" || a3 instanceof Number || tOfA === "boolean") {
            return -a3;
          }
          if ($bm_isInstanceOfArray(a3)) {
            var i4;
            var lenA = a3.length;
            var retArr = [];
            for (i4 = 0; i4 < lenA; i4 += 1) {
              retArr[i4] = -a3[i4];
            }
            return retArr;
          }
          if (a3.propType) {
            return a3.v;
          }
          return -a3;
        }
        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get;
        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get;
        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
        function sum(a3, b2) {
          var tOfA = _typeof$1(a3);
          var tOfB = _typeof$1(b2);
          if (isNumerable(tOfA, a3) && isNumerable(tOfB, b2) || tOfA === "string" || tOfB === "string") {
            return a3 + b2;
          }
          if ($bm_isInstanceOfArray(a3) && isNumerable(tOfB, b2)) {
            a3 = a3.slice(0);
            a3[0] += b2;
            return a3;
          }
          if (isNumerable(tOfA, a3) && $bm_isInstanceOfArray(b2)) {
            b2 = b2.slice(0);
            b2[0] = a3 + b2[0];
            return b2;
          }
          if ($bm_isInstanceOfArray(a3) && $bm_isInstanceOfArray(b2)) {
            var i4 = 0;
            var lenA = a3.length;
            var lenB = b2.length;
            var retArr = [];
            while (i4 < lenA || i4 < lenB) {
              if ((typeof a3[i4] === "number" || a3[i4] instanceof Number) && (typeof b2[i4] === "number" || b2[i4] instanceof Number)) {
                retArr[i4] = a3[i4] + b2[i4];
              } else {
                retArr[i4] = b2[i4] === void 0 ? a3[i4] : a3[i4] || b2[i4];
              }
              i4 += 1;
            }
            return retArr;
          }
          return 0;
        }
        var add = sum;
        function sub(a3, b2) {
          var tOfA = _typeof$1(a3);
          var tOfB = _typeof$1(b2);
          if (isNumerable(tOfA, a3) && isNumerable(tOfB, b2)) {
            if (tOfA === "string") {
              a3 = parseInt(a3, 10);
            }
            if (tOfB === "string") {
              b2 = parseInt(b2, 10);
            }
            return a3 - b2;
          }
          if ($bm_isInstanceOfArray(a3) && isNumerable(tOfB, b2)) {
            a3 = a3.slice(0);
            a3[0] -= b2;
            return a3;
          }
          if (isNumerable(tOfA, a3) && $bm_isInstanceOfArray(b2)) {
            b2 = b2.slice(0);
            b2[0] = a3 - b2[0];
            return b2;
          }
          if ($bm_isInstanceOfArray(a3) && $bm_isInstanceOfArray(b2)) {
            var i4 = 0;
            var lenA = a3.length;
            var lenB = b2.length;
            var retArr = [];
            while (i4 < lenA || i4 < lenB) {
              if ((typeof a3[i4] === "number" || a3[i4] instanceof Number) && (typeof b2[i4] === "number" || b2[i4] instanceof Number)) {
                retArr[i4] = a3[i4] - b2[i4];
              } else {
                retArr[i4] = b2[i4] === void 0 ? a3[i4] : a3[i4] || b2[i4];
              }
              i4 += 1;
            }
            return retArr;
          }
          return 0;
        }
        function mul(a3, b2) {
          var tOfA = _typeof$1(a3);
          var tOfB = _typeof$1(b2);
          var arr;
          if (isNumerable(tOfA, a3) && isNumerable(tOfB, b2)) {
            return a3 * b2;
          }
          var i4;
          var len;
          if ($bm_isInstanceOfArray(a3) && isNumerable(tOfB, b2)) {
            len = a3.length;
            arr = createTypedArray("float32", len);
            for (i4 = 0; i4 < len; i4 += 1) {
              arr[i4] = a3[i4] * b2;
            }
            return arr;
          }
          if (isNumerable(tOfA, a3) && $bm_isInstanceOfArray(b2)) {
            len = b2.length;
            arr = createTypedArray("float32", len);
            for (i4 = 0; i4 < len; i4 += 1) {
              arr[i4] = a3 * b2[i4];
            }
            return arr;
          }
          return 0;
        }
        function div(a3, b2) {
          var tOfA = _typeof$1(a3);
          var tOfB = _typeof$1(b2);
          var arr;
          if (isNumerable(tOfA, a3) && isNumerable(tOfB, b2)) {
            return a3 / b2;
          }
          var i4;
          var len;
          if ($bm_isInstanceOfArray(a3) && isNumerable(tOfB, b2)) {
            len = a3.length;
            arr = createTypedArray("float32", len);
            for (i4 = 0; i4 < len; i4 += 1) {
              arr[i4] = a3[i4] / b2;
            }
            return arr;
          }
          if (isNumerable(tOfA, a3) && $bm_isInstanceOfArray(b2)) {
            len = b2.length;
            arr = createTypedArray("float32", len);
            for (i4 = 0; i4 < len; i4 += 1) {
              arr[i4] = a3 / b2[i4];
            }
            return arr;
          }
          return 0;
        }
        function mod(a3, b2) {
          if (typeof a3 === "string") {
            a3 = parseInt(a3, 10);
          }
          if (typeof b2 === "string") {
            b2 = parseInt(b2, 10);
          }
          return a3 % b2;
        }
        var $bm_sum = sum;
        var $bm_sub = sub;
        var $bm_mul = mul;
        var $bm_div = div;
        var $bm_mod = mod;
        function clamp(num, min, max) {
          if (min > max) {
            var mm = max;
            max = min;
            min = mm;
          }
          return Math.min(Math.max(num, min), max);
        }
        function radiansToDegrees(val2) {
          return val2 / degToRads;
        }
        var radians_to_degrees = radiansToDegrees;
        function degreesToRadians(val2) {
          return val2 * degToRads;
        }
        var degrees_to_radians = radiansToDegrees;
        var helperLengthArray = [0, 0, 0, 0, 0, 0];
        function length(arr1, arr2) {
          if (typeof arr1 === "number" || arr1 instanceof Number) {
            arr2 = arr2 || 0;
            return Math.abs(arr1 - arr2);
          }
          if (!arr2) {
            arr2 = helperLengthArray;
          }
          var i4;
          var len = Math.min(arr1.length, arr2.length);
          var addedLength = 0;
          for (i4 = 0; i4 < len; i4 += 1) {
            addedLength += Math.pow(arr2[i4] - arr1[i4], 2);
          }
          return Math.sqrt(addedLength);
        }
        function normalize(vec) {
          return div(vec, length(vec));
        }
        function rgbToHsl(val2) {
          var r3 = val2[0];
          var g2 = val2[1];
          var b2 = val2[2];
          var max = Math.max(r3, g2, b2);
          var min = Math.min(r3, g2, b2);
          var h2;
          var s2;
          var l3 = (max + min) / 2;
          if (max === min) {
            h2 = 0;
            s2 = 0;
          } else {
            var d2 = max - min;
            s2 = l3 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
            switch (max) {
              case r3:
                h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
                break;
              case g2:
                h2 = (b2 - r3) / d2 + 2;
                break;
              case b2:
                h2 = (r3 - g2) / d2 + 4;
                break;
              default:
                break;
            }
            h2 /= 6;
          }
          return [h2, s2, l3, val2[3]];
        }
        function hue2rgb(p2, q, t5) {
          if (t5 < 0)
            t5 += 1;
          if (t5 > 1)
            t5 -= 1;
          if (t5 < 1 / 6)
            return p2 + (q - p2) * 6 * t5;
          if (t5 < 1 / 2)
            return q;
          if (t5 < 2 / 3)
            return p2 + (q - p2) * (2 / 3 - t5) * 6;
          return p2;
        }
        function hslToRgb(val2) {
          var h2 = val2[0];
          var s2 = val2[1];
          var l3 = val2[2];
          var r3;
          var g2;
          var b2;
          if (s2 === 0) {
            r3 = l3;
            b2 = l3;
            g2 = l3;
          } else {
            var q = l3 < 0.5 ? l3 * (1 + s2) : l3 + s2 - l3 * s2;
            var p2 = 2 * l3 - q;
            r3 = hue2rgb(p2, q, h2 + 1 / 3);
            g2 = hue2rgb(p2, q, h2);
            b2 = hue2rgb(p2, q, h2 - 1 / 3);
          }
          return [r3, g2, b2, val2[3]];
        }
        function linear(t5, tMin, tMax, value1, value2) {
          if (value1 === void 0 || value2 === void 0) {
            value1 = tMin;
            value2 = tMax;
            tMin = 0;
            tMax = 1;
          }
          if (tMax < tMin) {
            var _tMin = tMax;
            tMax = tMin;
            tMin = _tMin;
          }
          if (t5 <= tMin) {
            return value1;
          }
          if (t5 >= tMax) {
            return value2;
          }
          var perc = tMax === tMin ? 0 : (t5 - tMin) / (tMax - tMin);
          if (!value1.length) {
            return value1 + (value2 - value1) * perc;
          }
          var i4;
          var len = value1.length;
          var arr = createTypedArray("float32", len);
          for (i4 = 0; i4 < len; i4 += 1) {
            arr[i4] = value1[i4] + (value2[i4] - value1[i4]) * perc;
          }
          return arr;
        }
        function random(min, max) {
          if (max === void 0) {
            if (min === void 0) {
              min = 0;
              max = 1;
            } else {
              max = min;
              min = void 0;
            }
          }
          if (max.length) {
            var i4;
            var len = max.length;
            if (!min) {
              min = createTypedArray("float32", len);
            }
            var arr = createTypedArray("float32", len);
            var rnd = BMMath.random();
            for (i4 = 0; i4 < len; i4 += 1) {
              arr[i4] = min[i4] + rnd * (max[i4] - min[i4]);
            }
            return arr;
          }
          if (min === void 0) {
            min = 0;
          }
          var rndm = BMMath.random();
          return min + rndm * (max - min);
        }
        function createPath(points, inTangents, outTangents, closed) {
          var i4;
          var len = points.length;
          var path = shapePool.newElement();
          path.setPathData(!!closed, len);
          var arrPlaceholder = [0, 0];
          var inVertexPoint;
          var outVertexPoint;
          for (i4 = 0; i4 < len; i4 += 1) {
            inVertexPoint = inTangents && inTangents[i4] ? inTangents[i4] : arrPlaceholder;
            outVertexPoint = outTangents && outTangents[i4] ? outTangents[i4] : arrPlaceholder;
            path.setTripleAt(points[i4][0], points[i4][1], outVertexPoint[0] + points[i4][0], outVertexPoint[1] + points[i4][1], inVertexPoint[0] + points[i4][0], inVertexPoint[1] + points[i4][1], i4, true);
          }
          return path;
        }
        function initiateExpression(elem, data, property) {
          function noOp(_value) {
            return _value;
          }
          if (!elem.globalData.renderConfig.runExpressions) {
            return noOp;
          }
          var val = data.x;
          var needsVelocity = /velocity(?![\w\d])/.test(val);
          var _needsRandom = val.indexOf("random") !== -1;
          var elemType = elem.data.ty;
          var transform;
          var $bm_transform;
          var content;
          var effect;
          var thisProperty = property;
          thisProperty.valueAtTime = thisProperty.getValueAtTime;
          Object.defineProperty(thisProperty, "value", {
            get: function get2() {
              return thisProperty.v;
            }
          });
          elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
          elem.comp.displayStartTime = 0;
          var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
          var outPoint = elem.data.op / elem.comp.globalData.frameRate;
          var width = elem.data.sw ? elem.data.sw : 0;
          var height = elem.data.sh ? elem.data.sh : 0;
          var name = elem.data.nm;
          var loopIn;
          var loop_in;
          var loopOut;
          var loop_out;
          var smooth;
          var toWorld;
          var fromWorld;
          var fromComp;
          var toComp;
          var fromCompToSurface;
          var position;
          var rotation;
          var anchorPoint;
          var scale;
          var thisLayer;
          var thisComp;
          var mask;
          var valueAtTime;
          var velocityAtTime;
          var scoped_bm_rt;
          var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0];
          var numKeys = property.kf ? data.k.length : 0;
          var active = !this.data || this.data.hd !== true;
          var wiggle = function wiggle2(freq, amp) {
            var iWiggle;
            var j2;
            var lenWiggle = this.pv.length ? this.pv.length : 1;
            var addedAmps = createTypedArray("float32", lenWiggle);
            freq = 5;
            var iterations = Math.floor(time * freq);
            iWiggle = 0;
            j2 = 0;
            while (iWiggle < iterations) {
              for (j2 = 0; j2 < lenWiggle; j2 += 1) {
                addedAmps[j2] += -amp + amp * 2 * BMMath.random();
              }
              iWiggle += 1;
            }
            var periods = time * freq;
            var perc = periods - Math.floor(periods);
            var arr = createTypedArray("float32", lenWiggle);
            if (lenWiggle > 1) {
              for (j2 = 0; j2 < lenWiggle; j2 += 1) {
                arr[j2] = this.pv[j2] + addedAmps[j2] + (-amp + amp * 2 * BMMath.random()) * perc;
              }
              return arr;
            }
            return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
          }.bind(this);
          if (thisProperty.loopIn) {
            loopIn = thisProperty.loopIn.bind(thisProperty);
            loop_in = loopIn;
          }
          if (thisProperty.loopOut) {
            loopOut = thisProperty.loopOut.bind(thisProperty);
            loop_out = loopOut;
          }
          if (thisProperty.smooth) {
            smooth = thisProperty.smooth.bind(thisProperty);
          }
          function loopInDuration(type, duration) {
            return loopIn(type, duration, true);
          }
          function loopOutDuration(type, duration) {
            return loopOut(type, duration, true);
          }
          if (this.getValueAtTime) {
            valueAtTime = this.getValueAtTime.bind(this);
          }
          if (this.getVelocityAtTime) {
            velocityAtTime = this.getVelocityAtTime.bind(this);
          }
          var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
          function lookAt(elem1, elem2) {
            var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
            var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
            var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
            return [yaw, pitch, 0];
          }
          function easeOut(t5, tMin, tMax, val1, val2) {
            return applyEase(easeOutBez, t5, tMin, tMax, val1, val2);
          }
          function easeIn(t5, tMin, tMax, val1, val2) {
            return applyEase(easeInBez, t5, tMin, tMax, val1, val2);
          }
          function ease(t5, tMin, tMax, val1, val2) {
            return applyEase(easeInOutBez, t5, tMin, tMax, val1, val2);
          }
          function applyEase(fn, t5, tMin, tMax, val1, val2) {
            if (val1 === void 0) {
              val1 = tMin;
              val2 = tMax;
            } else {
              t5 = (t5 - tMin) / (tMax - tMin);
            }
            if (t5 > 1) {
              t5 = 1;
            } else if (t5 < 0) {
              t5 = 0;
            }
            var mult = fn(t5);
            if ($bm_isInstanceOfArray(val1)) {
              var iKey;
              var lenKey = val1.length;
              var arr = createTypedArray("float32", lenKey);
              for (iKey = 0; iKey < lenKey; iKey += 1) {
                arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
              }
              return arr;
            }
            return (val2 - val1) * mult + val1;
          }
          function nearestKey(time2) {
            var iKey;
            var lenKey = data.k.length;
            var index2;
            var keyTime;
            if (!data.k.length || typeof data.k[0] === "number") {
              index2 = 0;
              keyTime = 0;
            } else {
              index2 = -1;
              time2 *= elem.comp.globalData.frameRate;
              if (time2 < data.k[0].t) {
                index2 = 1;
                keyTime = data.k[0].t;
              } else {
                for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                  if (time2 === data.k[iKey].t) {
                    index2 = iKey + 1;
                    keyTime = data.k[iKey].t;
                    break;
                  } else if (time2 > data.k[iKey].t && time2 < data.k[iKey + 1].t) {
                    if (time2 - data.k[iKey].t > data.k[iKey + 1].t - time2) {
                      index2 = iKey + 2;
                      keyTime = data.k[iKey + 1].t;
                    } else {
                      index2 = iKey + 1;
                      keyTime = data.k[iKey].t;
                    }
                    break;
                  }
                }
                if (index2 === -1) {
                  index2 = iKey + 1;
                  keyTime = data.k[iKey].t;
                }
              }
            }
            var obKey = {};
            obKey.index = index2;
            obKey.time = keyTime / elem.comp.globalData.frameRate;
            return obKey;
          }
          function key(ind) {
            var obKey;
            var iKey;
            var lenKey;
            if (!data.k.length || typeof data.k[0] === "number") {
              throw new Error("The property has no keyframe at index " + ind);
            }
            ind -= 1;
            obKey = {
              time: data.k[ind].t / elem.comp.globalData.frameRate,
              value: []
            };
            var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
            lenKey = arr.length;
            for (iKey = 0; iKey < lenKey; iKey += 1) {
              obKey[iKey] = arr[iKey];
              obKey.value[iKey] = arr[iKey];
            }
            return obKey;
          }
          function framesToTime(fr, fps) {
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }
            return fr / fps;
          }
          function timeToFrames(t5, fps) {
            if (!t5 && t5 !== 0) {
              t5 = time;
            }
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }
            return t5 * fps;
          }
          function seedRandom(seed) {
            BMMath.seedrandom(randSeed + seed);
          }
          function sourceRectAtTime() {
            return elem.sourceRectAtTime();
          }
          function substring(init, end) {
            if (typeof value === "string") {
              if (end === void 0) {
                return value.substring(init);
              }
              return value.substring(init, end);
            }
            return "";
          }
          function substr(init, end) {
            if (typeof value === "string") {
              if (end === void 0) {
                return value.substr(init);
              }
              return value.substr(init, end);
            }
            return "";
          }
          function posterizeTime(framesPerSecond) {
            time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
            value = valueAtTime(time);
          }
          var time;
          var velocity;
          var value;
          var text;
          var textIndex;
          var textTotal;
          var selectorValue;
          var index = elem.data.ind;
          var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
          var parent;
          var randSeed = Math.floor(Math.random() * 1e6);
          var globalData = elem.globalData;
          function executeExpression(_value) {
            value = _value;
            if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") {
              return value;
            }
            if (this.propType === "textSelector") {
              textIndex = this.textIndex;
              textTotal = this.textTotal;
              selectorValue = this.selectorValue;
            }
            if (!thisLayer) {
              text = elem.layerInterface.text;
              thisLayer = elem.layerInterface;
              thisComp = elem.comp.compInterface;
              toWorld = thisLayer.toWorld.bind(thisLayer);
              fromWorld = thisLayer.fromWorld.bind(thisLayer);
              fromComp = thisLayer.fromComp.bind(thisLayer);
              toComp = thisLayer.toComp.bind(thisLayer);
              mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
              fromCompToSurface = fromComp;
            }
            if (!transform) {
              transform = elem.layerInterface("ADBE Transform Group");
              $bm_transform = transform;
              if (transform) {
                anchorPoint = transform.anchorPoint;
              }
            }
            if (elemType === 4 && !content) {
              content = thisLayer("ADBE Root Vectors Group");
            }
            if (!effect) {
              effect = thisLayer(4);
            }
            hasParent = !!(elem.hierarchy && elem.hierarchy.length);
            if (hasParent && !parent) {
              parent = elem.hierarchy[0].layerInterface;
            }
            time = this.comp.renderedFrame / this.comp.globalData.frameRate;
            if (_needsRandom) {
              seedRandom(randSeed + time);
            }
            if (needsVelocity) {
              velocity = velocityAtTime(time);
            }
            expression_function();
            this.frameExpressionId = elem.globalData.frameId;
            scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
            return scoped_bm_rt;
          }
          executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
          return executeExpression;
        }
        ob.initiateExpression = initiateExpression;
        ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
        ob.resetFrame = resetFrame;
        return ob;
      }();
      var Expressions = function() {
        var ob2 = {};
        ob2.initExpressions = initExpressions;
        ob2.resetFrame = ExpressionManager.resetFrame;
        function initExpressions(animation) {
          var stackCount = 0;
          var registers = [];
          function pushExpression() {
            stackCount += 1;
          }
          function popExpression() {
            stackCount -= 1;
            if (stackCount === 0) {
              releaseInstances();
            }
          }
          function registerExpressionProperty(expression) {
            if (registers.indexOf(expression) === -1) {
              registers.push(expression);
            }
          }
          function releaseInstances() {
            var i4;
            var len = registers.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              registers[i4].release();
            }
            registers.length = 0;
          }
          animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
          animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
          animation.renderer.globalData.pushExpression = pushExpression;
          animation.renderer.globalData.popExpression = popExpression;
          animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
        }
        return ob2;
      }();
      var MaskManagerInterface = function() {
        function MaskInterface(mask2, data2) {
          this._mask = mask2;
          this._data = data2;
        }
        Object.defineProperty(MaskInterface.prototype, "maskPath", {
          get: function get2() {
            if (this._mask.prop.k) {
              this._mask.prop.getValue();
            }
            return this._mask.prop;
          }
        });
        Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
          get: function get2() {
            if (this._mask.op.k) {
              this._mask.op.getValue();
            }
            return this._mask.op.v * 100;
          }
        });
        var MaskManager = function MaskManager2(maskManager) {
          var _masksInterfaces = createSizedArray(maskManager.viewData.length);
          var i4;
          var len = maskManager.viewData.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            _masksInterfaces[i4] = new MaskInterface(maskManager.viewData[i4], maskManager.masksProperties[i4]);
          }
          var maskFunction = function maskFunction2(name2) {
            i4 = 0;
            while (i4 < len) {
              if (maskManager.masksProperties[i4].nm === name2) {
                return _masksInterfaces[i4];
              }
              i4 += 1;
            }
            return null;
          };
          return maskFunction;
        };
        return MaskManager;
      }();
      var ExpressionPropertyInterface = function() {
        var defaultUnidimensionalValue = {
          pv: 0,
          v: 0,
          mult: 1
        };
        var defaultMultidimensionalValue = {
          pv: [0, 0, 0],
          v: [0, 0, 0],
          mult: 1
        };
        function completeProperty(expressionValue, property2, type) {
          Object.defineProperty(expressionValue, "velocity", {
            get: function get2() {
              return property2.getVelocityAtTime(property2.comp.currentFrame);
            }
          });
          expressionValue.numKeys = property2.keyframes ? property2.keyframes.length : 0;
          expressionValue.key = function(pos) {
            if (!expressionValue.numKeys) {
              return 0;
            }
            var value2 = "";
            if ("s" in property2.keyframes[pos - 1]) {
              value2 = property2.keyframes[pos - 1].s;
            } else if ("e" in property2.keyframes[pos - 2]) {
              value2 = property2.keyframes[pos - 2].e;
            } else {
              value2 = property2.keyframes[pos - 2].s;
            }
            var valueProp = type === "unidimensional" ? new Number(value2) : Object.assign({}, value2);
            valueProp.time = property2.keyframes[pos - 1].t / property2.elem.comp.globalData.frameRate;
            valueProp.value = type === "unidimensional" ? value2[0] : value2;
            return valueProp;
          };
          expressionValue.valueAtTime = property2.getValueAtTime;
          expressionValue.speedAtTime = property2.getSpeedAtTime;
          expressionValue.velocityAtTime = property2.getVelocityAtTime;
          expressionValue.propertyGroup = property2.propertyGroup;
        }
        function UnidimensionalPropertyInterface(property2) {
          if (!property2 || !("pv" in property2)) {
            property2 = defaultUnidimensionalValue;
          }
          var mult = 1 / property2.mult;
          var val2 = property2.pv * mult;
          var expressionValue = new Number(val2);
          expressionValue.value = val2;
          completeProperty(expressionValue, property2, "unidimensional");
          return function() {
            if (property2.k) {
              property2.getValue();
            }
            val2 = property2.v * mult;
            if (expressionValue.value !== val2) {
              expressionValue = new Number(val2);
              expressionValue.value = val2;
              completeProperty(expressionValue, property2, "unidimensional");
            }
            return expressionValue;
          };
        }
        function MultidimensionalPropertyInterface(property2) {
          if (!property2 || !("pv" in property2)) {
            property2 = defaultMultidimensionalValue;
          }
          var mult = 1 / property2.mult;
          var len = property2.data && property2.data.l || property2.pv.length;
          var expressionValue = createTypedArray("float32", len);
          var arrValue = createTypedArray("float32", len);
          expressionValue.value = arrValue;
          completeProperty(expressionValue, property2, "multidimensional");
          return function() {
            if (property2.k) {
              property2.getValue();
            }
            for (var i4 = 0; i4 < len; i4 += 1) {
              arrValue[i4] = property2.v[i4] * mult;
              expressionValue[i4] = arrValue[i4];
            }
            return expressionValue;
          };
        }
        function defaultGetter() {
          return defaultUnidimensionalValue;
        }
        return function(property2) {
          if (!property2) {
            return defaultGetter;
          }
          if (property2.propType === "unidimensional") {
            return UnidimensionalPropertyInterface(property2);
          }
          return MultidimensionalPropertyInterface(property2);
        };
      }();
      var TransformExpressionInterface = function() {
        return function(transform2) {
          function _thisFunction(name2) {
            switch (name2) {
              case "scale":
              case "Scale":
              case "ADBE Scale":
              case 6:
                return _thisFunction.scale;
              case "rotation":
              case "Rotation":
              case "ADBE Rotation":
              case "ADBE Rotate Z":
              case 10:
                return _thisFunction.rotation;
              case "ADBE Rotate X":
                return _thisFunction.xRotation;
              case "ADBE Rotate Y":
                return _thisFunction.yRotation;
              case "position":
              case "Position":
              case "ADBE Position":
              case 2:
                return _thisFunction.position;
              case "ADBE Position_0":
                return _thisFunction.xPosition;
              case "ADBE Position_1":
                return _thisFunction.yPosition;
              case "ADBE Position_2":
                return _thisFunction.zPosition;
              case "anchorPoint":
              case "AnchorPoint":
              case "Anchor Point":
              case "ADBE AnchorPoint":
              case 1:
                return _thisFunction.anchorPoint;
              case "opacity":
              case "Opacity":
              case 11:
                return _thisFunction.opacity;
              default:
                return null;
            }
          }
          Object.defineProperty(_thisFunction, "rotation", {
            get: ExpressionPropertyInterface(transform2.r || transform2.rz)
          });
          Object.defineProperty(_thisFunction, "zRotation", {
            get: ExpressionPropertyInterface(transform2.rz || transform2.r)
          });
          Object.defineProperty(_thisFunction, "xRotation", {
            get: ExpressionPropertyInterface(transform2.rx)
          });
          Object.defineProperty(_thisFunction, "yRotation", {
            get: ExpressionPropertyInterface(transform2.ry)
          });
          Object.defineProperty(_thisFunction, "scale", {
            get: ExpressionPropertyInterface(transform2.s)
          });
          var _px;
          var _py;
          var _pz;
          var _transformFactory;
          if (transform2.p) {
            _transformFactory = ExpressionPropertyInterface(transform2.p);
          } else {
            _px = ExpressionPropertyInterface(transform2.px);
            _py = ExpressionPropertyInterface(transform2.py);
            if (transform2.pz) {
              _pz = ExpressionPropertyInterface(transform2.pz);
            }
          }
          Object.defineProperty(_thisFunction, "position", {
            get: function get2() {
              if (transform2.p) {
                return _transformFactory();
              }
              return [_px(), _py(), _pz ? _pz() : 0];
            }
          });
          Object.defineProperty(_thisFunction, "xPosition", {
            get: ExpressionPropertyInterface(transform2.px)
          });
          Object.defineProperty(_thisFunction, "yPosition", {
            get: ExpressionPropertyInterface(transform2.py)
          });
          Object.defineProperty(_thisFunction, "zPosition", {
            get: ExpressionPropertyInterface(transform2.pz)
          });
          Object.defineProperty(_thisFunction, "anchorPoint", {
            get: ExpressionPropertyInterface(transform2.a)
          });
          Object.defineProperty(_thisFunction, "opacity", {
            get: ExpressionPropertyInterface(transform2.o)
          });
          Object.defineProperty(_thisFunction, "skew", {
            get: ExpressionPropertyInterface(transform2.sk)
          });
          Object.defineProperty(_thisFunction, "skewAxis", {
            get: ExpressionPropertyInterface(transform2.sa)
          });
          Object.defineProperty(_thisFunction, "orientation", {
            get: ExpressionPropertyInterface(transform2.or)
          });
          return _thisFunction;
        };
      }();
      var LayerExpressionInterface = function() {
        function getMatrix(time2) {
          var toWorldMat = new Matrix();
          if (time2 !== void 0) {
            var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time2);
            propMatrix.clone(toWorldMat);
          } else {
            var transformMat = this._elem.finalTransform.mProp;
            transformMat.applyToMatrix(toWorldMat);
          }
          return toWorldMat;
        }
        function toWorldVec(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.applyPoint(toWorldMat, arr);
        }
        function toWorld2(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          return this.applyPoint(toWorldMat, arr);
        }
        function fromWorldVec(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.invertPoint(toWorldMat, arr);
        }
        function fromWorld2(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          return this.invertPoint(toWorldMat, arr);
        }
        function applyPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i4;
            var len = this._elem.hierarchy.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              this._elem.hierarchy[i4].finalTransform.mProp.applyToMatrix(matrix);
            }
          }
          return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
        }
        function invertPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i4;
            var len = this._elem.hierarchy.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              this._elem.hierarchy[i4].finalTransform.mProp.applyToMatrix(matrix);
            }
          }
          return matrix.inversePoint(arr);
        }
        function fromComp2(arr) {
          var toWorldMat = new Matrix();
          toWorldMat.reset();
          this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i4;
            var len = this._elem.hierarchy.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              this._elem.hierarchy[i4].finalTransform.mProp.applyToMatrix(toWorldMat);
            }
            return toWorldMat.inversePoint(arr);
          }
          return toWorldMat.inversePoint(arr);
        }
        function sampleImage() {
          return [1, 1, 1, 1];
        }
        return function(elem2) {
          var transformInterface;
          function _registerMaskInterface(maskManager) {
            _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem2);
          }
          function _registerEffectsInterface(effects) {
            _thisLayerFunction.effect = effects;
          }
          function _thisLayerFunction(name2) {
            switch (name2) {
              case "ADBE Root Vectors Group":
              case "Contents":
              case 2:
                return _thisLayerFunction.shapeInterface;
              case 1:
              case 6:
              case "Transform":
              case "transform":
              case "ADBE Transform Group":
                return transformInterface;
              case 4:
              case "ADBE Effect Parade":
              case "effects":
              case "Effects":
                return _thisLayerFunction.effect;
              case "ADBE Text Properties":
                return _thisLayerFunction.textInterface;
              default:
                return null;
            }
          }
          _thisLayerFunction.getMatrix = getMatrix;
          _thisLayerFunction.invertPoint = invertPoint;
          _thisLayerFunction.applyPoint = applyPoint;
          _thisLayerFunction.toWorld = toWorld2;
          _thisLayerFunction.toWorldVec = toWorldVec;
          _thisLayerFunction.fromWorld = fromWorld2;
          _thisLayerFunction.fromWorldVec = fromWorldVec;
          _thisLayerFunction.toComp = toWorld2;
          _thisLayerFunction.fromComp = fromComp2;
          _thisLayerFunction.sampleImage = sampleImage;
          _thisLayerFunction.sourceRectAtTime = elem2.sourceRectAtTime.bind(elem2);
          _thisLayerFunction._elem = elem2;
          transformInterface = TransformExpressionInterface(elem2.finalTransform.mProp);
          var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
          Object.defineProperties(_thisLayerFunction, {
            hasParent: {
              get: function get2() {
                return elem2.hierarchy.length;
              }
            },
            parent: {
              get: function get2() {
                return elem2.hierarchy[0].layerInterface;
              }
            },
            rotation: getDescriptor(transformInterface, "rotation"),
            scale: getDescriptor(transformInterface, "scale"),
            position: getDescriptor(transformInterface, "position"),
            opacity: getDescriptor(transformInterface, "opacity"),
            anchorPoint: anchorPointDescriptor,
            anchor_point: anchorPointDescriptor,
            transform: {
              get: function get2() {
                return transformInterface;
              }
            },
            active: {
              get: function get2() {
                return elem2.isInRange;
              }
            }
          });
          _thisLayerFunction.startTime = elem2.data.st;
          _thisLayerFunction.index = elem2.data.ind;
          _thisLayerFunction.source = elem2.data.refId;
          _thisLayerFunction.height = elem2.data.ty === 0 ? elem2.data.h : 100;
          _thisLayerFunction.width = elem2.data.ty === 0 ? elem2.data.w : 100;
          _thisLayerFunction.inPoint = elem2.data.ip / elem2.comp.globalData.frameRate;
          _thisLayerFunction.outPoint = elem2.data.op / elem2.comp.globalData.frameRate;
          _thisLayerFunction._name = elem2.data.nm;
          _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
          _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
          return _thisLayerFunction;
        };
      }();
      var propertyGroupFactory = function() {
        return function(interfaceFunction, parentPropertyGroup) {
          return function(val2) {
            val2 = val2 === void 0 ? 1 : val2;
            if (val2 <= 0) {
              return interfaceFunction;
            }
            return parentPropertyGroup(val2 - 1);
          };
        };
      }();
      var PropertyInterface = function() {
        return function(propertyName, propertyGroup) {
          var interfaceFunction = {
            _name: propertyName
          };
          function _propertyGroup(val2) {
            val2 = val2 === void 0 ? 1 : val2;
            if (val2 <= 0) {
              return interfaceFunction;
            }
            return propertyGroup(val2 - 1);
          }
          return _propertyGroup;
        };
      }();
      var EffectsExpressionInterface = function() {
        var ob2 = {
          createEffectsInterface
        };
        function createEffectsInterface(elem2, propertyGroup) {
          if (elem2.effectsManager) {
            var effectElements = [];
            var effectsData = elem2.data.ef;
            var i4;
            var len = elem2.effectsManager.effectElements.length;
            for (i4 = 0; i4 < len; i4 += 1) {
              effectElements.push(createGroupInterface(effectsData[i4], elem2.effectsManager.effectElements[i4], propertyGroup, elem2));
            }
            var effects = elem2.data.ef || [];
            var groupInterface = function groupInterface2(name2) {
              i4 = 0;
              len = effects.length;
              while (i4 < len) {
                if (name2 === effects[i4].nm || name2 === effects[i4].mn || name2 === effects[i4].ix) {
                  return effectElements[i4];
                }
                i4 += 1;
              }
              return null;
            };
            Object.defineProperty(groupInterface, "numProperties", {
              get: function get2() {
                return effects.length;
              }
            });
            return groupInterface;
          }
          return null;
        }
        function createGroupInterface(data2, elements, propertyGroup, elem2) {
          function groupInterface(name2) {
            var effects = data2.ef;
            var i5 = 0;
            var len2 = effects.length;
            while (i5 < len2) {
              if (name2 === effects[i5].nm || name2 === effects[i5].mn || name2 === effects[i5].ix) {
                if (effects[i5].ty === 5) {
                  return effectElements[i5];
                }
                return effectElements[i5]();
              }
              i5 += 1;
            }
            throw new Error();
          }
          var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
          var effectElements = [];
          var i4;
          var len = data2.ef.length;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (data2.ef[i4].ty === 5) {
              effectElements.push(createGroupInterface(data2.ef[i4], elements.effectElements[i4], elements.effectElements[i4].propertyGroup, elem2));
            } else {
              effectElements.push(createValueInterface(elements.effectElements[i4], data2.ef[i4].ty, elem2, _propertyGroup));
            }
          }
          if (data2.mn === "ADBE Color Control") {
            Object.defineProperty(groupInterface, "color", {
              get: function get2() {
                return effectElements[0]();
              }
            });
          }
          Object.defineProperties(groupInterface, {
            numProperties: {
              get: function get2() {
                return data2.np;
              }
            },
            _name: {
              value: data2.nm
            },
            propertyGroup: {
              value: _propertyGroup
            }
          });
          groupInterface.enabled = data2.en !== 0;
          groupInterface.active = groupInterface.enabled;
          return groupInterface;
        }
        function createValueInterface(element, type, elem2, propertyGroup) {
          var expressionProperty = ExpressionPropertyInterface(element.p);
          function interfaceFunction() {
            if (type === 10) {
              return elem2.comp.compInterface(element.p.v);
            }
            return expressionProperty();
          }
          if (element.p.setGroupProperty) {
            element.p.setGroupProperty(PropertyInterface("", propertyGroup));
          }
          return interfaceFunction;
        }
        return ob2;
      }();
      var ShapePathInterface = function() {
        return function pathInterfaceFactory(shape, view, propertyGroup) {
          var prop = view.sh;
          function interfaceFunction(val2) {
            if (val2 === "Shape" || val2 === "shape" || val2 === "Path" || val2 === "path" || val2 === "ADBE Vector Shape" || val2 === 2) {
              return interfaceFunction.path;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            path: {
              get: function get2() {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              }
            },
            shape: {
              get: function get2() {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              }
            },
            _name: {
              value: shape.nm
            },
            ix: {
              value: shape.ix
            },
            propertyIndex: {
              value: shape.ix
            },
            mn: {
              value: shape.mn
            },
            propertyGroup: {
              value: propertyGroup
            }
          });
          return interfaceFunction;
        };
      }();
      var ShapeExpressionInterface = function() {
        function iterateElements(shapes, view, propertyGroup) {
          var arr = [];
          var i4;
          var len = shapes ? shapes.length : 0;
          for (i4 = 0; i4 < len; i4 += 1) {
            if (shapes[i4].ty === "gr") {
              arr.push(groupInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "fl") {
              arr.push(fillInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "st") {
              arr.push(strokeInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "tm") {
              arr.push(trimInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "tr") {
            } else if (shapes[i4].ty === "el") {
              arr.push(ellipseInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "sr") {
              arr.push(starInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "sh") {
              arr.push(ShapePathInterface(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "rc") {
              arr.push(rectInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "rd") {
              arr.push(roundedInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "rp") {
              arr.push(repeaterInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else if (shapes[i4].ty === "gf") {
              arr.push(gradientFillInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            } else {
              arr.push(defaultInterfaceFactory(shapes[i4], view[i4], propertyGroup));
            }
          }
          return arr;
        }
        function contentsInterfaceFactory(shape, view, propertyGroup) {
          var interfaces2;
          var interfaceFunction = function _interfaceFunction(value2) {
            var i4 = 0;
            var len = interfaces2.length;
            while (i4 < len) {
              if (interfaces2[i4]._name === value2 || interfaces2[i4].mn === value2 || interfaces2[i4].propertyIndex === value2 || interfaces2[i4].ix === value2 || interfaces2[i4].ind === value2) {
                return interfaces2[i4];
              }
              i4 += 1;
            }
            if (typeof value2 === "number") {
              return interfaces2[value2 - 1];
            }
            return null;
          };
          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaces2 = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
          interfaceFunction.numProperties = interfaces2.length;
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.transform = transformInterface;
          interfaceFunction.propertyIndex = shape.cix;
          interfaceFunction._name = shape.nm;
          return interfaceFunction;
        }
        function groupInterfaceFactory(shape, view, propertyGroup) {
          var interfaceFunction = function _interfaceFunction(value2) {
            switch (value2) {
              case "ADBE Vectors Group":
              case "Contents":
              case 2:
                return interfaceFunction.content;
              default:
                return interfaceFunction.transform;
            }
          };
          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var content2 = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.content = content2;
          interfaceFunction.transform = transformInterface;
          Object.defineProperty(interfaceFunction, "_name", {
            get: function get2() {
              return shape.nm;
            }
          });
          interfaceFunction.numProperties = shape.np;
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.nm = shape.nm;
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function fillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === "Color" || val2 === "color") {
              return interfaceFunction.color;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
          return interfaceFunction;
        }
        function gradientFillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === "Start Point" || val2 === "start point") {
              return interfaceFunction.startPoint;
            }
            if (val2 === "End Point" || val2 === "end point") {
              return interfaceFunction.endPoint;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            startPoint: {
              get: ExpressionPropertyInterface(view.s)
            },
            endPoint: {
              get: ExpressionPropertyInterface(view.e)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            type: {
              get: function get2() {
                return "a";
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
          view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
          return interfaceFunction;
        }
        function defaultInterfaceFactory() {
          function interfaceFunction() {
            return null;
          }
          return interfaceFunction;
        }
        function strokeInterfaceFactory(shape, view, propertyGroup) {
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
          function addPropertyToDashOb(i5) {
            Object.defineProperty(dashOb, shape.d[i5].nm, {
              get: ExpressionPropertyInterface(view.d.dataProps[i5].p)
            });
          }
          var i4;
          var len = shape.d ? shape.d.length : 0;
          var dashOb = {};
          for (i4 = 0; i4 < len; i4 += 1) {
            addPropertyToDashOb(i4);
            view.d.dataProps[i4].p.setGroupProperty(_dashPropertyGroup);
          }
          function interfaceFunction(val2) {
            if (val2 === "Color" || val2 === "color") {
              return interfaceFunction.color;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            if (val2 === "Stroke Width" || val2 === "stroke width") {
              return interfaceFunction.strokeWidth;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            strokeWidth: {
              get: ExpressionPropertyInterface(view.w)
            },
            dash: {
              get: function get2() {
                return dashOb;
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
          return interfaceFunction;
        }
        function trimInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === shape.e.ix || val2 === "End" || val2 === "end") {
              return interfaceFunction.end;
            }
            if (val2 === shape.s.ix) {
              return interfaceFunction.start;
            }
            if (val2 === shape.o.ix) {
              return interfaceFunction.offset;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaceFunction.propertyIndex = shape.ix;
          view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
          view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.propertyGroup = propertyGroup;
          Object.defineProperties(interfaceFunction, {
            start: {
              get: ExpressionPropertyInterface(view.s)
            },
            end: {
              get: ExpressionPropertyInterface(view.e)
            },
            offset: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function transformInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.a.ix === value2 || value2 === "Anchor Point") {
              return interfaceFunction.anchorPoint;
            }
            if (shape.o.ix === value2 || value2 === "Opacity") {
              return interfaceFunction.opacity;
            }
            if (shape.p.ix === value2 || value2 === "Position") {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2 || value2 === "Rotation" || value2 === "ADBE Vector Rotation") {
              return interfaceFunction.rotation;
            }
            if (shape.s.ix === value2 || value2 === "Scale") {
              return interfaceFunction.scale;
            }
            if (shape.sk && shape.sk.ix === value2 || value2 === "Skew") {
              return interfaceFunction.skew;
            }
            if (shape.sa && shape.sa.ix === value2 || value2 === "Skew Axis") {
              return interfaceFunction.skewAxis;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
          view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
          view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          if (view.transform.mProps.sk) {
            view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
            view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
          }
          view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            opacity: {
              get: ExpressionPropertyInterface(view.transform.mProps.o)
            },
            position: {
              get: ExpressionPropertyInterface(view.transform.mProps.p)
            },
            anchorPoint: {
              get: ExpressionPropertyInterface(view.transform.mProps.a)
            },
            scale: {
              get: ExpressionPropertyInterface(view.transform.mProps.s)
            },
            rotation: {
              get: ExpressionPropertyInterface(view.transform.mProps.r)
            },
            skew: {
              get: ExpressionPropertyInterface(view.transform.mProps.sk)
            },
            skewAxis: {
              get: ExpressionPropertyInterface(view.transform.mProps.sa)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.ty = "tr";
          interfaceFunction.mn = shape.mn;
          interfaceFunction.propertyGroup = propertyGroup;
          return interfaceFunction;
        }
        function ellipseInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.s.ix === value2) {
              return interfaceFunction.size;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaceFunction.propertyIndex = shape.ix;
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function starInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2) {
              return interfaceFunction.rotation;
            }
            if (shape.pt.ix === value2) {
              return interfaceFunction.points;
            }
            if (shape.or.ix === value2 || value2 === "ADBE Vector Star Outer Radius") {
              return interfaceFunction.outerRadius;
            }
            if (shape.os.ix === value2) {
              return interfaceFunction.outerRoundness;
            }
            if (shape.ir && (shape.ir.ix === value2 || value2 === "ADBE Vector Star Inner Radius")) {
              return interfaceFunction.innerRadius;
            }
            if (shape.is && shape.is.ix === value2) {
              return interfaceFunction.innerRoundness;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
          prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
          prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          if (shape.ir) {
            prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
            prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
          }
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            rotation: {
              get: ExpressionPropertyInterface(prop.r)
            },
            points: {
              get: ExpressionPropertyInterface(prop.pt)
            },
            outerRadius: {
              get: ExpressionPropertyInterface(prop.or)
            },
            outerRoundness: {
              get: ExpressionPropertyInterface(prop.os)
            },
            innerRadius: {
              get: ExpressionPropertyInterface(prop.ir)
            },
            innerRoundness: {
              get: ExpressionPropertyInterface(prop.is)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function rectInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2) {
              return interfaceFunction.roundness;
            }
            if (shape.s.ix === value2 || value2 === "Size" || value2 === "ADBE Vector Rect Size") {
              return interfaceFunction.size;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            roundness: {
              get: ExpressionPropertyInterface(prop.r)
            },
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function roundedInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.r.ix === value2 || value2 === "Round Corners 1") {
              return interfaceFunction.radius;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            radius: {
              get: ExpressionPropertyInterface(prop.rd)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function repeaterInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.c.ix === value2 || value2 === "Copies") {
              return interfaceFunction.copies;
            }
            if (shape.o.ix === value2 || value2 === "Offset") {
              return interfaceFunction.offset;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
          prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            copies: {
              get: ExpressionPropertyInterface(prop.c)
            },
            offset: {
              get: ExpressionPropertyInterface(prop.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        return function(shapes, view, propertyGroup) {
          var interfaces2;
          function _interfaceFunction(value2) {
            if (typeof value2 === "number") {
              value2 = value2 === void 0 ? 1 : value2;
              if (value2 === 0) {
                return propertyGroup;
              }
              return interfaces2[value2 - 1];
            }
            var i4 = 0;
            var len = interfaces2.length;
            while (i4 < len) {
              if (interfaces2[i4]._name === value2) {
                return interfaces2[i4];
              }
              i4 += 1;
            }
            return null;
          }
          function parentGroupWrapper() {
            return propertyGroup;
          }
          _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
          interfaces2 = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
          _interfaceFunction.numProperties = interfaces2.length;
          _interfaceFunction._name = "Contents";
          return _interfaceFunction;
        };
      }();
      var TextExpressionInterface = function() {
        return function(elem2) {
          var _sourceText;
          function _thisLayerFunction(name2) {
            switch (name2) {
              case "ADBE Text Document":
                return _thisLayerFunction.sourceText;
              default:
                return null;
            }
          }
          Object.defineProperty(_thisLayerFunction, "sourceText", {
            get: function get2() {
              elem2.textProperty.getValue();
              var stringValue = elem2.textProperty.currentData.t;
              if (!_sourceText || stringValue !== _sourceText.value) {
                _sourceText = new String(stringValue);
                _sourceText.value = stringValue || new String(stringValue);
                Object.defineProperty(_sourceText, "style", {
                  get: function get3() {
                    return {
                      fillColor: elem2.textProperty.currentData.fc
                    };
                  }
                });
              }
              return _sourceText;
            }
          });
          return _thisLayerFunction;
        };
      }();
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      var FootageInterface = function() {
        var outlineInterfaceFactory = function outlineInterfaceFactory2(elem2) {
          var currentPropertyName = "";
          var currentProperty = elem2.getFootageData();
          function init() {
            currentPropertyName = "";
            currentProperty = elem2.getFootageData();
            return searchProperty;
          }
          function searchProperty(value2) {
            if (currentProperty[value2]) {
              currentPropertyName = value2;
              currentProperty = currentProperty[value2];
              if (_typeof(currentProperty) === "object") {
                return searchProperty;
              }
              return currentProperty;
            }
            var propertyNameIndex = value2.indexOf(currentPropertyName);
            if (propertyNameIndex !== -1) {
              var index2 = parseInt(value2.substr(propertyNameIndex + currentPropertyName.length), 10);
              currentProperty = currentProperty[index2];
              if (_typeof(currentProperty) === "object") {
                return searchProperty;
              }
              return currentProperty;
            }
            return "";
          }
          return init;
        };
        var dataInterfaceFactory = function dataInterfaceFactory2(elem2) {
          function interfaceFunction(value2) {
            if (value2 === "Outline") {
              return interfaceFunction.outlineInterface();
            }
            return null;
          }
          interfaceFunction._name = "Outline";
          interfaceFunction.outlineInterface = outlineInterfaceFactory(elem2);
          return interfaceFunction;
        };
        return function(elem2) {
          function _interfaceFunction(value2) {
            if (value2 === "Data") {
              return _interfaceFunction.dataInterface;
            }
            return null;
          }
          _interfaceFunction._name = "Data";
          _interfaceFunction.dataInterface = dataInterfaceFactory(elem2);
          return _interfaceFunction;
        };
      }();
      var interfaces = {
        layer: LayerExpressionInterface,
        effects: EffectsExpressionInterface,
        comp: CompExpressionInterface,
        shape: ShapeExpressionInterface,
        text: TextExpressionInterface,
        footage: FootageInterface
      };
      function getInterface(type) {
        return interfaces[type] || null;
      }
      var expressionHelpers = function() {
        function searchExpressions(elem2, data2, prop) {
          if (data2.x) {
            prop.k = true;
            prop.x = true;
            prop.initiateExpression = ExpressionManager.initiateExpression;
            prop.effectsSequence.push(prop.initiateExpression(elem2, data2, prop).bind(prop));
          }
        }
        function getValueAtTime(frameNum) {
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;
          if (frameNum !== this._cachingAtTime.lastFrame) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
            this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
            this._cachingAtTime.lastFrame = frameNum;
          }
          return this._cachingAtTime.value;
        }
        function getSpeedAtTime(frameNum) {
          var delta = -0.01;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var speed = 0;
          if (v1.length) {
            var i4;
            for (i4 = 0; i4 < v1.length; i4 += 1) {
              speed += Math.pow(v2[i4] - v1[i4], 2);
            }
            speed = Math.sqrt(speed) * 100;
          } else {
            speed = 0;
          }
          return speed;
        }
        function getVelocityAtTime(frameNum) {
          if (this.vel !== void 0) {
            return this.vel;
          }
          var delta = -1e-3;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var velocity2;
          if (v1.length) {
            velocity2 = createTypedArray("float32", v1.length);
            var i4;
            for (i4 = 0; i4 < v1.length; i4 += 1) {
              velocity2[i4] = (v2[i4] - v1[i4]) / delta;
            }
          } else {
            velocity2 = (v2 - v1) / delta;
          }
          return velocity2;
        }
        function getStaticValueAtTime() {
          return this.pv;
        }
        function setGroupProperty(propertyGroup) {
          this.propertyGroup = propertyGroup;
        }
        return {
          searchExpressions,
          getSpeedAtTime,
          getVelocityAtTime,
          getValueAtTime,
          getStaticValueAtTime,
          setGroupProperty
        };
      }();
      function addPropertyDecorator() {
        function loopOut2(type, duration, durationFlag) {
          if (!this.k || !this.keyframes) {
            return this.pv;
          }
          type = type ? type.toLowerCase() : "";
          var currentFrame = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var lastKeyFrame = keyframes[keyframes.length - 1].t;
          if (currentFrame <= lastKeyFrame) {
            return this.pv;
          }
          var cycleDuration;
          var firstKeyFrame;
          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }
            firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
            } else {
              cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
            }
            firstKeyFrame = lastKeyFrame - cycleDuration;
          }
          var i4;
          var len;
          var ret;
          if (type === "pingpong") {
            var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
            if (iterations % 2 !== 0) {
              return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            }
          } else if (type === "offset") {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;
              for (i4 = 0; i4 < len; i4 += 1) {
                ret[i4] = (endV[i4] - initV[i4]) * repeats + current[i4];
              }
              return ret;
            }
            return (endV - initV) * repeats + current;
          } else if (type === "continue") {
            var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var nextLastValue = this.getValueAtTime((lastKeyFrame - 1e-3) / this.comp.globalData.frameRate, 0);
            if (this.pv.length) {
              ret = new Array(lastValue.length);
              len = ret.length;
              for (i4 = 0; i4 < len; i4 += 1) {
                ret[i4] = lastValue[i4] + (lastValue[i4] - nextLastValue[i4]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
              }
              return ret;
            }
            return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 1e-3);
          }
          return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
        }
        function loopIn2(type, duration, durationFlag) {
          if (!this.k) {
            return this.pv;
          }
          type = type ? type.toLowerCase() : "";
          var currentFrame = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var firstKeyFrame = keyframes[0].t;
          if (currentFrame >= firstKeyFrame) {
            return this.pv;
          }
          var cycleDuration;
          var lastKeyFrame;
          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }
            lastKeyFrame = keyframes[duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
            } else {
              cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
            }
            lastKeyFrame = firstKeyFrame + cycleDuration;
          }
          var i4;
          var len;
          var ret;
          if (type === "pingpong") {
            var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
            if (iterations % 2 === 0) {
              return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            }
          } else if (type === "offset") {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;
              for (i4 = 0; i4 < len; i4 += 1) {
                ret[i4] = current[i4] - (endV[i4] - initV[i4]) * repeats;
              }
              return ret;
            }
            return current - (endV - initV) * repeats;
          } else if (type === "continue") {
            var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var nextFirstValue = this.getValueAtTime((firstKeyFrame + 1e-3) / this.comp.globalData.frameRate, 0);
            if (this.pv.length) {
              ret = new Array(firstValue.length);
              len = ret.length;
              for (i4 = 0; i4 < len; i4 += 1) {
                ret[i4] = firstValue[i4] + (firstValue[i4] - nextFirstValue[i4]) * (firstKeyFrame - currentFrame) / 1e-3;
              }
              return ret;
            }
            return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 1e-3;
          }
          return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);
        }
        function smooth2(width2, samples) {
          if (!this.k) {
            return this.pv;
          }
          width2 = (width2 || 0.4) * 0.5;
          samples = Math.floor(samples || 5);
          if (samples <= 1) {
            return this.pv;
          }
          var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
          var initFrame2 = currentTime - width2;
          var endFrame = currentTime + width2;
          var sampleFrequency = samples > 1 ? (endFrame - initFrame2) / (samples - 1) : 1;
          var i4 = 0;
          var j2 = 0;
          var value2;
          if (this.pv.length) {
            value2 = createTypedArray("float32", this.pv.length);
          } else {
            value2 = 0;
          }
          var sampleValue;
          while (i4 < samples) {
            sampleValue = this.getValueAtTime(initFrame2 + i4 * sampleFrequency);
            if (this.pv.length) {
              for (j2 = 0; j2 < this.pv.length; j2 += 1) {
                value2[j2] += sampleValue[j2];
              }
            } else {
              value2 += sampleValue;
            }
            i4 += 1;
          }
          if (this.pv.length) {
            for (j2 = 0; j2 < this.pv.length; j2 += 1) {
              value2[j2] /= samples;
            }
          } else {
            value2 /= samples;
          }
          return value2;
        }
        function getTransformValueAtTime(time2) {
          if (!this._transformCachingAtTime) {
            this._transformCachingAtTime = {
              v: new Matrix()
            };
          }
          var matrix = this._transformCachingAtTime.v;
          matrix.cloneFromProps(this.pre.props);
          if (this.appliedTransformations < 1) {
            var anchor = this.a.getValueAtTime(time2);
            matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
          }
          if (this.appliedTransformations < 2) {
            var scale2 = this.s.getValueAtTime(time2);
            matrix.scale(scale2[0] * this.s.mult, scale2[1] * this.s.mult, scale2[2] * this.s.mult);
          }
          if (this.sk && this.appliedTransformations < 3) {
            var skew = this.sk.getValueAtTime(time2);
            var skewAxis = this.sa.getValueAtTime(time2);
            matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
          }
          if (this.r && this.appliedTransformations < 4) {
            var rotation2 = this.r.getValueAtTime(time2);
            matrix.rotate(-rotation2 * this.r.mult);
          } else if (!this.r && this.appliedTransformations < 4) {
            var rotationZ = this.rz.getValueAtTime(time2);
            var rotationY = this.ry.getValueAtTime(time2);
            var rotationX = this.rx.getValueAtTime(time2);
            var orientation = this.or.getValueAtTime(time2);
            matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
          }
          if (this.data.p && this.data.p.s) {
            var positionX = this.px.getValueAtTime(time2);
            var positionY = this.py.getValueAtTime(time2);
            if (this.data.p.z) {
              var positionZ = this.pz.getValueAtTime(time2);
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
            } else {
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
            }
          } else {
            var position2 = this.p.getValueAtTime(time2);
            matrix.translate(position2[0] * this.p.mult, position2[1] * this.p.mult, -position2[2] * this.p.mult);
          }
          return matrix;
        }
        function getTransformStaticValueAtTime() {
          return this.v.clone(new Matrix());
        }
        var getTransformProperty = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function(elem2, data2, container) {
          var prop = getTransformProperty(elem2, data2, container);
          if (prop.dynamicProperties.length) {
            prop.getValueAtTime = getTransformValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
          }
          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          return prop;
        };
        var propertyGetProp = PropertyFactory.getProp;
        PropertyFactory.getProp = function(elem2, data2, type, mult, container) {
          var prop = propertyGetProp(elem2, data2, type, mult, container);
          if (prop.kf) {
            prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
          }
          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          prop.loopOut = loopOut2;
          prop.loopIn = loopIn2;
          prop.smooth = smooth2;
          prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
          prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
          prop.numKeys = data2.a === 1 ? data2.k.length : 0;
          prop.propertyIndex = data2.ix;
          var value2 = 0;
          if (type !== 0) {
            value2 = createTypedArray("float32", data2.a === 1 ? data2.k[0].s.length : data2.k.length);
          }
          prop._cachingAtTime = {
            lastFrame: initialDefaultFrame,
            lastIndex: 0,
            value: value2
          };
          expressionHelpers.searchExpressions(elem2, data2, prop);
          if (prop.k) {
            container.addDynamicProperty(prop);
          }
          return prop;
        };
        function getShapeValueAtTime(frameNum) {
          if (!this._cachingAtTime) {
            this._cachingAtTime = {
              shapeValue: shapePool.clone(this.pv),
              lastIndex: 0,
              lastTime: initialDefaultFrame
            };
          }
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;
          if (frameNum !== this._cachingAtTime.lastTime) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
            this._cachingAtTime.lastTime = frameNum;
            this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
          }
          return this._cachingAtTime.shapeValue;
        }
        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
        function ShapeExpressions() {
        }
        ShapeExpressions.prototype = {
          vertices: function vertices(prop, time2) {
            if (this.k) {
              this.getValue();
            }
            var shapePath = this.v;
            if (time2 !== void 0) {
              shapePath = this.getValueAtTime(time2, 0);
            }
            var i4;
            var len = shapePath._length;
            var vertices2 = shapePath[prop];
            var points = shapePath.v;
            var arr = createSizedArray(len);
            for (i4 = 0; i4 < len; i4 += 1) {
              if (prop === "i" || prop === "o") {
                arr[i4] = [vertices2[i4][0] - points[i4][0], vertices2[i4][1] - points[i4][1]];
              } else {
                arr[i4] = [vertices2[i4][0], vertices2[i4][1]];
              }
            }
            return arr;
          },
          points: function points(time2) {
            return this.vertices("v", time2);
          },
          inTangents: function inTangents(time2) {
            return this.vertices("i", time2);
          },
          outTangents: function outTangents(time2) {
            return this.vertices("o", time2);
          },
          isClosed: function isClosed() {
            return this.v.c;
          },
          pointOnPath: function pointOnPath(perc, time2) {
            var shapePath = this.v;
            if (time2 !== void 0) {
              shapePath = this.getValueAtTime(time2, 0);
            }
            if (!this._segmentsLength) {
              this._segmentsLength = bez.getSegmentsLength(shapePath);
            }
            var segmentsLength = this._segmentsLength;
            var lengths = segmentsLength.lengths;
            var lengthPos = segmentsLength.totalLength * perc;
            var i4 = 0;
            var len = lengths.length;
            var accumulatedLength = 0;
            var pt;
            while (i4 < len) {
              if (accumulatedLength + lengths[i4].addedLength > lengthPos) {
                var initIndex = i4;
                var endIndex = shapePath.c && i4 === len - 1 ? 0 : i4 + 1;
                var segmentPerc = (lengthPos - accumulatedLength) / lengths[i4].addedLength;
                pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i4]);
                break;
              } else {
                accumulatedLength += lengths[i4].addedLength;
              }
              i4 += 1;
            }
            if (!pt) {
              pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
            }
            return pt;
          },
          vectorOnPath: function vectorOnPath(perc, time2, vectorType) {
            if (perc == 1) {
              perc = this.v.c;
            } else if (perc == 0) {
              perc = 0.999;
            }
            var pt1 = this.pointOnPath(perc, time2);
            var pt2 = this.pointOnPath(perc + 1e-3, time2);
            var xLength = pt2[0] - pt1[0];
            var yLength = pt2[1] - pt1[1];
            var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
            if (magnitude === 0) {
              return [0, 0];
            }
            var unitVector = vectorType === "tangent" ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
            return unitVector;
          },
          tangentOnPath: function tangentOnPath(perc, time2) {
            return this.vectorOnPath(perc, time2, "tangent");
          },
          normalOnPath: function normalOnPath(perc, time2) {
            return this.vectorOnPath(perc, time2, "normal");
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime
        };
        extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
        extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function(elem2, data2, type, arr, trims) {
          var prop = propertyGetShapeProp(elem2, data2, type, arr, trims);
          prop.propertyIndex = data2.ix;
          prop.lock = false;
          if (type === 3) {
            expressionHelpers.searchExpressions(elem2, data2.pt, prop);
          } else if (type === 4) {
            expressionHelpers.searchExpressions(elem2, data2.ks, prop);
          }
          if (prop.k) {
            elem2.addDynamicProperty(prop);
          }
          return prop;
        };
      }
      function initialize$1() {
        addPropertyDecorator();
      }
      function addDecorator() {
        function searchExpressions() {
          if (this.data.d.x) {
            this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
            this.addEffect(this.getExpressionValue.bind(this));
            return true;
          }
          return null;
        }
        TextProperty.prototype.getExpressionValue = function(currentValue, text2) {
          var newValue = this.calculateExpression(text2);
          if (currentValue.t !== newValue) {
            var newData = {};
            this.copyData(newData, currentValue);
            newData.t = newValue.toString();
            newData.__complete = false;
            return newData;
          }
          return currentValue;
        };
        TextProperty.prototype.searchProperty = function() {
          var isKeyframed = this.searchKeyframes();
          var hasExpressions = this.searchExpressions();
          this.kf = isKeyframed || hasExpressions;
          return this.kf;
        };
        TextProperty.prototype.searchExpressions = searchExpressions;
      }
      function initialize() {
        addDecorator();
      }
      function SVGComposableEffect() {
      }
      SVGComposableEffect.prototype = {
        createMergeNode: function createMergeNode(resultId, ins) {
          var feMerge = createNS("feMerge");
          feMerge.setAttribute("result", resultId);
          var feMergeNode;
          var i4;
          for (i4 = 0; i4 < ins.length; i4 += 1) {
            feMergeNode = createNS("feMergeNode");
            feMergeNode.setAttribute("in", ins[i4]);
            feMerge.appendChild(feMergeNode);
            feMerge.appendChild(feMergeNode);
          }
          return feMerge;
        }
      };
      var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
      function SVGTintFilter(filter, filterManager, elem2, id, source) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", linearFilterValue + " 1 0");
        this.linearFilter = feColorMatrix;
        feColorMatrix.setAttribute("result", id + "_tint_1");
        filter.appendChild(feColorMatrix);
        feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id + "_tint_2");
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
        var feMerge = this.createMergeNode(id, [source, id + "_tint_1", id + "_tint_2"]);
        filter.appendChild(feMerge);
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter);
      SVGTintFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var colorBlack = this.filterManager.effectElements[0].p.v;
          var colorWhite = this.filterManager.effectElements[1].p.v;
          var opacity = this.filterManager.effectElements[2].p.v / 100;
          this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0");
          this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0");
        }
      };
      function SVGFillFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id);
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
      }
      SVGFillFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color = this.filterManager.effectElements[2].p.v;
          var opacity = this.filterManager.effectElements[6].p.v;
          this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
        }
      };
      function SVGStrokeEffect(fil, filterManager, elem2) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.elem = elem2;
        this.paths = [];
      }
      SVGStrokeEffect.prototype.initialize = function() {
        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
        var path;
        var groupPath;
        var i4;
        var len;
        if (this.filterManager.effectElements[1].p.v === 1) {
          len = this.elem.maskManager.masksProperties.length;
          i4 = 0;
        } else {
          i4 = this.filterManager.effectElements[0].p.v - 1;
          len = i4 + 1;
        }
        groupPath = createNS("g");
        groupPath.setAttribute("fill", "none");
        groupPath.setAttribute("stroke-linecap", "round");
        groupPath.setAttribute("stroke-dashoffset", 1);
        for (i4; i4 < len; i4 += 1) {
          path = createNS("path");
          groupPath.appendChild(path);
          this.paths.push({
            p: path,
            m: i4
          });
        }
        if (this.filterManager.effectElements[10].p.v === 3) {
          var mask2 = createNS("mask");
          var id = createElementID();
          mask2.setAttribute("id", id);
          mask2.setAttribute("mask-type", "alpha");
          mask2.appendChild(groupPath);
          this.elem.globalData.defs.appendChild(mask2);
          var g2 = createNS("g");
          g2.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
          while (elemChildren[0]) {
            g2.appendChild(elemChildren[0]);
          }
          this.elem.layerElement.appendChild(g2);
          this.masker = mask2;
          groupPath.setAttribute("stroke", "#fff");
        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (this.filterManager.effectElements[10].p.v === 2) {
            elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
            while (elemChildren.length) {
              this.elem.layerElement.removeChild(elemChildren[0]);
            }
          }
          this.elem.layerElement.appendChild(groupPath);
          this.elem.layerElement.removeAttribute("mask");
          groupPath.setAttribute("stroke", "#fff");
        }
        this.initialized = true;
        this.pathMasker = groupPath;
      };
      SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
        if (!this.initialized) {
          this.initialize();
        }
        var i4;
        var len = this.paths.length;
        var mask2;
        var path;
        for (i4 = 0; i4 < len; i4 += 1) {
          if (this.paths[i4].m !== -1) {
            mask2 = this.elem.maskManager.viewData[this.paths[i4].m];
            path = this.paths[i4].p;
            if (forceRender || this.filterManager._mdf || mask2.prop._mdf) {
              path.setAttribute("d", mask2.lastPath);
            }
            if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask2.prop._mdf) {
              var dasharrayValue;
              if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                var s2 = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var e5 = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var l3 = path.getTotalLength();
                dasharrayValue = "0 0 0 " + l3 * s2 + " ";
                var lineLength = l3 * (e5 - s2);
                var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                var units = Math.floor(lineLength / segment);
                var j2;
                for (j2 = 0; j2 < units; j2 += 1) {
                  dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                }
                dasharrayValue += "0 " + l3 * 10 + " 0 0";
              } else {
                dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
              }
              path.setAttribute("stroke-dasharray", dasharrayValue);
            }
          }
        }
        if (forceRender || this.filterManager.effectElements[4].p._mdf) {
          this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
        }
        if (forceRender || this.filterManager.effectElements[6].p._mdf) {
          this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
        }
        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (forceRender || this.filterManager.effectElements[3].p._mdf) {
            var color = this.filterManager.effectElements[3].p.v;
            this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
          }
        }
      };
      function SVGTritoneFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
        filter.appendChild(feColorMatrix);
        var feComponentTransfer = createNS("feComponentTransfer");
        feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
        feComponentTransfer.setAttribute("result", id);
        this.matrixFilter = feComponentTransfer;
        var feFuncR = createNS("feFuncR");
        feFuncR.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncR);
        this.feFuncR = feFuncR;
        var feFuncG = createNS("feFuncG");
        feFuncG.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncG);
        this.feFuncG = feFuncG;
        var feFuncB = createNS("feFuncB");
        feFuncB.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncB);
        this.feFuncB = feFuncB;
        filter.appendChild(feComponentTransfer);
      }
      SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color1 = this.filterManager.effectElements[0].p.v;
          var color2 = this.filterManager.effectElements[1].p.v;
          var color3 = this.filterManager.effectElements[2].p.v;
          var tableR = color3[0] + " " + color2[0] + " " + color1[0];
          var tableG = color3[1] + " " + color2[1] + " " + color1[1];
          var tableB = color3[2] + " " + color2[2] + " " + color1[2];
          this.feFuncR.setAttribute("tableValues", tableR);
          this.feFuncG.setAttribute("tableValues", tableG);
          this.feFuncB.setAttribute("tableValues", tableB);
        }
      };
      function SVGProLevelsFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var effectElements = this.filterManager.effectElements;
        var feComponentTransfer = createNS("feComponentTransfer");
        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
          this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
        }
        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
          this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
        }
        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
          this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
        }
        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
          this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
        }
        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          filter.appendChild(feComponentTransfer);
        }
        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
          feComponentTransfer = createNS("feComponentTransfer");
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          feComponentTransfer.setAttribute("result", id);
          filter.appendChild(feComponentTransfer);
          this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
          this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
          this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
        }
      }
      SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
        var feFunc = createNS(type);
        feFunc.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFunc);
        return feFunc;
      };
      SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
        var cnt = 0;
        var segments = 256;
        var perc;
        var min = Math.min(inputBlack, inputWhite);
        var max = Math.max(inputBlack, inputWhite);
        var table = Array.call(null, {
          length: segments
        });
        var colorValue;
        var pos = 0;
        var outputDelta = outputWhite - outputBlack;
        var inputDelta = inputWhite - inputBlack;
        while (cnt <= 256) {
          perc = cnt / 256;
          if (perc <= min) {
            colorValue = inputDelta < 0 ? outputWhite : outputBlack;
          } else if (perc >= max) {
            colorValue = inputDelta < 0 ? outputBlack : outputWhite;
          } else {
            colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
          }
          table[pos] = colorValue;
          pos += 1;
          cnt += 256 / (segments - 1);
        }
        return table.join(" ");
      };
      SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var val2;
          var effectElements = this.filterManager.effectElements;
          if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
            val2 = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
            this.feFuncRComposed.setAttribute("tableValues", val2);
            this.feFuncGComposed.setAttribute("tableValues", val2);
            this.feFuncBComposed.setAttribute("tableValues", val2);
          }
          if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
            val2 = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
            this.feFuncR.setAttribute("tableValues", val2);
          }
          if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
            val2 = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
            this.feFuncG.setAttribute("tableValues", val2);
          }
          if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
            val2 = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
            this.feFuncB.setAttribute("tableValues", val2);
          }
          if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
            val2 = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
            this.feFuncA.setAttribute("tableValues", val2);
          }
        }
      };
      function SVGDropShadowEffect(filter, filterManager, elem2, id, source) {
        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
        var filterSize = filterManager.data.fs || globalFilterSize;
        filter.setAttribute("x", filterSize.x || globalFilterSize.x);
        filter.setAttribute("y", filterSize.y || globalFilterSize.y);
        filter.setAttribute("width", filterSize.width || globalFilterSize.width);
        filter.setAttribute("height", filterSize.height || globalFilterSize.height);
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("in", "SourceAlpha");
        feGaussianBlur.setAttribute("result", id + "_drop_shadow_1");
        feGaussianBlur.setAttribute("stdDeviation", "0");
        this.feGaussianBlur = feGaussianBlur;
        filter.appendChild(feGaussianBlur);
        var feOffset = createNS("feOffset");
        feOffset.setAttribute("dx", "25");
        feOffset.setAttribute("dy", "0");
        feOffset.setAttribute("in", id + "_drop_shadow_1");
        feOffset.setAttribute("result", id + "_drop_shadow_2");
        this.feOffset = feOffset;
        filter.appendChild(feOffset);
        var feFlood = createNS("feFlood");
        feFlood.setAttribute("flood-color", "#00ff00");
        feFlood.setAttribute("flood-opacity", "1");
        feFlood.setAttribute("result", id + "_drop_shadow_3");
        this.feFlood = feFlood;
        filter.appendChild(feFlood);
        var feComposite = createNS("feComposite");
        feComposite.setAttribute("in", id + "_drop_shadow_3");
        feComposite.setAttribute("in2", id + "_drop_shadow_2");
        feComposite.setAttribute("operator", "in");
        feComposite.setAttribute("result", id + "_drop_shadow_4");
        filter.appendChild(feComposite);
        var feMerge = this.createMergeNode(id, [id + "_drop_shadow_4", source]);
        filter.appendChild(feMerge);
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
      SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          if (forceRender || this.filterManager.effectElements[4].p._mdf) {
            this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
          }
          if (forceRender || this.filterManager.effectElements[0].p._mdf) {
            var col = this.filterManager.effectElements[0].p.v;
            this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
          }
          if (forceRender || this.filterManager.effectElements[1].p._mdf) {
            this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
          }
          if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
            var distance = this.filterManager.effectElements[3].p.v;
            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
            var x2 = distance * Math.cos(angle);
            var y2 = distance * Math.sin(angle);
            this.feOffset.setAttribute("dx", x2);
            this.feOffset.setAttribute("dy", y2);
          }
        }
      };
      var _svgMatteSymbols = [];
      function SVGMatte3Effect(filterElem, filterManager, elem2) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.filterElem = filterElem;
        this.elem = elem2;
        elem2.matteElement = createNS("g");
        elem2.matteElement.appendChild(elem2.layerElement);
        elem2.matteElement.appendChild(elem2.transformedElement);
        elem2.baseElement = elem2.matteElement;
      }
      SVGMatte3Effect.prototype.findSymbol = function(mask2) {
        var i4 = 0;
        var len = _svgMatteSymbols.length;
        while (i4 < len) {
          if (_svgMatteSymbols[i4] === mask2) {
            return _svgMatteSymbols[i4];
          }
          i4 += 1;
        }
        return null;
      };
      SVGMatte3Effect.prototype.replaceInParent = function(mask2, symbolId) {
        var parentNode = mask2.layerElement.parentNode;
        if (!parentNode) {
          return;
        }
        var children = parentNode.children;
        var i4 = 0;
        var len = children.length;
        while (i4 < len) {
          if (children[i4] === mask2.layerElement) {
            break;
          }
          i4 += 1;
        }
        var nextChild;
        if (i4 <= len - 2) {
          nextChild = children[i4 + 1];
        }
        var useElem = createNS("use");
        useElem.setAttribute("href", "#" + symbolId);
        if (nextChild) {
          parentNode.insertBefore(useElem, nextChild);
        } else {
          parentNode.appendChild(useElem);
        }
      };
      SVGMatte3Effect.prototype.setElementAsMask = function(elem2, mask2) {
        if (!this.findSymbol(mask2)) {
          var symbolId = createElementID();
          var masker = createNS("mask");
          masker.setAttribute("id", mask2.layerId);
          masker.setAttribute("mask-type", "alpha");
          _svgMatteSymbols.push(mask2);
          var defs = elem2.globalData.defs;
          defs.appendChild(masker);
          var symbol = createNS("symbol");
          symbol.setAttribute("id", symbolId);
          this.replaceInParent(mask2, symbolId);
          symbol.appendChild(mask2.layerElement);
          defs.appendChild(symbol);
          var useElem = createNS("use");
          useElem.setAttribute("href", "#" + symbolId);
          masker.appendChild(useElem);
          mask2.data.hd = false;
          mask2.show();
        }
        elem2.setMatte(mask2.layerId);
      };
      SVGMatte3Effect.prototype.initialize = function() {
        var ind = this.filterManager.effectElements[0].p.v;
        var elements = this.elem.comp.elements;
        var i4 = 0;
        var len = elements.length;
        while (i4 < len) {
          if (elements[i4] && elements[i4].data.ind === ind) {
            this.setElementAsMask(this.elem, elements[i4]);
          }
          i4 += 1;
        }
        this.initialized = true;
      };
      SVGMatte3Effect.prototype.renderFrame = function() {
        if (!this.initialized) {
          this.initialize();
        }
      };
      function SVGGaussianBlurEffect(filter, filterManager, elem2, id) {
        filter.setAttribute("x", "-100%");
        filter.setAttribute("y", "-100%");
        filter.setAttribute("width", "300%");
        filter.setAttribute("height", "300%");
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("result", id);
        filter.appendChild(feGaussianBlur);
        this.feGaussianBlur = feGaussianBlur;
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var kBlurrinessToSigma = 0.3;
          var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
          var dimensions = this.filterManager.effectElements[1].p.v;
          var sigmaX = dimensions == 3 ? 0 : sigma;
          var sigmaY = dimensions == 2 ? 0 : sigma;
          this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
          var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
          this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
        }
      };
      function TransformEffect() {
      }
      TransformEffect.prototype.init = function(effectsManager) {
        this.effectsManager = effectsManager;
        this.type = effectTypes.TRANSFORM_EFFECT;
        this.matrix = new Matrix();
        this.opacity = -1;
        this._mdf = false;
        this._opMdf = false;
      };
      TransformEffect.prototype.renderFrame = function(forceFrame) {
        this._opMdf = false;
        this._mdf = false;
        if (forceFrame || this.effectsManager._mdf) {
          var effectElements = this.effectsManager.effectElements;
          var anchor = effectElements[0].p.v;
          var position2 = effectElements[1].p.v;
          var isUniformScale = effectElements[2].p.v === 1;
          var scaleHeight = effectElements[3].p.v;
          var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
          var skew = effectElements[5].p.v;
          var skewAxis = effectElements[6].p.v;
          var rotation2 = effectElements[7].p.v;
          this.matrix.reset();
          this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
          this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
          this.matrix.rotate(-rotation2 * degToRads);
          this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
          this.matrix.translate(position2[0], position2[1], 0);
          this._mdf = true;
          if (this.opacity !== effectElements[8].p.v) {
            this.opacity = effectElements[8].p.v;
            this._opMdf = true;
          }
        }
      };
      function SVGTransformEffect(_2, filterManager) {
        this.init(filterManager);
      }
      extendPrototype([TransformEffect], SVGTransformEffect);
      function CVTransformEffect(effectsManager) {
        this.init(effectsManager);
      }
      extendPrototype([TransformEffect], CVTransformEffect);
      registerRenderer("canvas", CanvasRenderer);
      registerRenderer("html", HybridRenderer);
      registerRenderer("svg", SVGRenderer);
      ShapeModifiers.registerModifier("tm", TrimModifier);
      ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
      ShapeModifiers.registerModifier("rp", RepeaterModifier);
      ShapeModifiers.registerModifier("rd", RoundCornersModifier);
      ShapeModifiers.registerModifier("zz", ZigZagModifier);
      ShapeModifiers.registerModifier("op", OffsetPathModifier);
      setExpressionsPlugin(Expressions);
      setExpressionInterfaces(getInterface);
      initialize$1();
      initialize();
      registerEffect$1(20, SVGTintFilter, true);
      registerEffect$1(21, SVGFillFilter, true);
      registerEffect$1(22, SVGStrokeEffect, false);
      registerEffect$1(23, SVGTritoneFilter, true);
      registerEffect$1(24, SVGProLevelsFilter, true);
      registerEffect$1(25, SVGDropShadowEffect, true);
      registerEffect$1(28, SVGMatte3Effect, false);
      registerEffect$1(29, SVGGaussianBlurEffect, true);
      registerEffect$1(35, SVGTransformEffect, false);
      registerEffect(35, CVTransformEffect);
      return lottie;
    });
  }
});

// node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS({
  "node_modules/universal-user-agent/dist-node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function getUserAgent6() {
      if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
      }
      if (typeof process === "object" && process.version !== void 0) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
      }
      return "<environment undetectable>";
    }
    exports2.getUserAgent = getUserAgent6;
  }
});

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports2, module2) {
    module2.exports = register;
    function register(state, name2, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name2)) {
        return name2.reverse().reduce(function(callback, name3) {
          return register.bind(null, state, name3, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name2]) {
          return method(options);
        }
        return state.registry[name2].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports2, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name2, hook5) {
      var orig = hook5;
      if (!state.registry[name2]) {
        state.registry[name2] = [];
      }
      if (kind === "before") {
        hook5 = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook5 = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook5 = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
            return orig(error, options);
          });
        };
      }
      state.registry[name2].push({
        hook: hook5,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports2, module2) {
    module2.exports = removeHook;
    function removeHook(state, name2, method) {
      if (!state.registry[name2]) {
        return;
      }
      var index2 = state.registry[name2].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index2 === -1) {
        return;
      }
      state.registry[name2].splice(index2, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports2, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook5, state, name2) {
      var removeHookRef = bindable(removeHook, null).apply(
        null,
        name2 ? [state, name2] : [state]
      );
      hook5.api = { remove: removeHookRef };
      hook5.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name2 ? [state, kind, name2] : [state, kind];
        hook5[kind] = hook5.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook5 = register.bind(null, state);
      bindApi(hook5, state);
      return hook5;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn(
          '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
        );
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/@octokit/endpoint/dist-web/index.js
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key2) => {
    newObj[key2.toLowerCase()] = object[key2];
    return newObj;
  }, {});
}
function isPlainObject(value2) {
  if (typeof value2 !== "object" || value2 === null)
    return false;
  if (Object.prototype.toString.call(value2) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value2);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value2);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key2) => {
    if (isPlainObject(options[key2])) {
      if (!(key2 in defaults))
        Object.assign(result, { [key2]: options[key2] });
      else
        result[key2] = mergeDeep(defaults[key2], options[key2]);
    } else {
      Object.assign(result, { [key2]: options[key2] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key2 in obj) {
    if (obj[key2] === void 0) {
      delete obj[key2];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a3;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a3 = defaults.mediaType.previews) == null ? void 0 : _a3.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name2) => {
    if (name2 === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name2}=${encodeURIComponent(parameters[name2])}`;
  }).join("&");
}
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a3, b2) => a3.concat(b2), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key2 of Object.keys(object)) {
    if (keysToOmit.indexOf(key2) === -1) {
      result[key2] = object[key2];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value2, key2) {
  value2 = operator === "+" || operator === "#" ? encodeReserved(value2) : encodeUnreserved(value2);
  if (key2) {
    return encodeUnreserved(key2) + "=" + value2;
  } else {
    return value2;
  }
}
function isDefined(value2) {
  return value2 !== void 0 && value2 !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key2, modifier) {
  var value2 = context[key2], result = [];
  if (isDefined(value2) && value2 !== "") {
    if (typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
      value2 = value2.toString();
      if (modifier && modifier !== "*") {
        value2 = value2.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value2, isKeyOperator(operator) ? key2 : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value2)) {
          value2.filter(isDefined).forEach(function(value22) {
            result.push(
              encodeValue(operator, value22, isKeyOperator(operator) ? key2 : "")
            );
          });
        } else {
          Object.keys(value2).forEach(function(k2) {
            if (isDefined(value2[k2])) {
              result.push(encodeValue(operator, value2[k2], k2));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value2)) {
          value2.filter(isDefined).forEach(function(value22) {
            tmp.push(encodeValue(operator, value22));
          });
        } else {
          Object.keys(value2).forEach(function(k2) {
            if (isDefined(value2[k2])) {
              tmp.push(encodeUnreserved(k2));
              tmp.push(encodeValue(operator, value2[k2].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key2) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value2)) {
        result.push(encodeUnreserved(key2));
      }
    } else if (value2 === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key2) + "=");
    } else if (value2 === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_2, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a3;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a3 = options.mediaType.previews) == null ? void 0 : _a3.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var import_universal_user_agent, VERSION, userAgent, DEFAULTS, urlVariableRegex, endpoint;
var init_dist_web = __esm({
  "node_modules/@octokit/endpoint/dist-web/index.js"() {
    import_universal_user_agent = __toESM(require_dist_node());
    VERSION = "9.0.4";
    userAgent = `octokit-endpoint.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`;
    DEFAULTS = {
      method: "GET",
      baseUrl: "https://api.github.com",
      headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent
      },
      mediaType: {
        format: ""
      }
    };
    urlVariableRegex = /\{[^}]+\}/g;
    endpoint = withDefaults(null, DEFAULTS);
  }
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node2 = __commonJS({
  "node_modules/deprecation/dist-node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Deprecation2 = class extends Error {
      constructor(message) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "Deprecation";
      }
    };
    exports2.Deprecation = Deprecation2;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k2) {
        wrapper[k2] = fn[k2];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i4 = 0; i4 < args.length; i4++) {
          args[i4] = arguments[i4];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k2) {
            ret[k2] = cb2[k2];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f3 = function() {
        if (f3.called)
          return f3.value;
        f3.called = true;
        return f3.value = fn.apply(this, arguments);
      };
      f3.called = false;
      return f3;
    }
    function onceStrict(fn) {
      var f3 = function() {
        if (f3.called)
          throw new Error(f3.onceError);
        f3.called = true;
        return f3.value = fn.apply(this, arguments);
      };
      var name2 = fn.name || "Function wrapped with `once`";
      f3.onceError = name2 + " shouldn't be called more than once";
      f3.called = false;
      return f3;
    }
  }
});

// node_modules/@octokit/request-error/dist-web/index.js
var dist_web_exports = {};
__export(dist_web_exports, {
  RequestError: () => RequestError
});
var import_deprecation, import_once, logOnceCode, logOnceHeaders, RequestError;
var init_dist_web2 = __esm({
  "node_modules/@octokit/request-error/dist-web/index.js"() {
    import_deprecation = __toESM(require_dist_node2());
    import_once = __toESM(require_once());
    logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
    logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
    RequestError = class extends Error {
      constructor(message, statusCode, options) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = statusCode;
        let headers;
        if ("headers" in options && typeof options.headers !== "undefined") {
          headers = options.headers;
        }
        if ("response" in options) {
          this.response = options.response;
          headers = options.response.headers;
        }
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
          requestCopy.headers = Object.assign({}, options.request.headers, {
            authorization: options.request.headers.authorization.replace(
              / .*$/,
              " [REDACTED]"
            )
          });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
        Object.defineProperty(this, "code", {
          get() {
            logOnceCode(
              new import_deprecation.Deprecation(
                "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
              )
            );
            return statusCode;
          }
        });
        Object.defineProperty(this, "headers", {
          get() {
            logOnceHeaders(
              new import_deprecation.Deprecation(
                "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
              )
            );
            return headers || {};
          }
        });
      }
    };
  }
});

// node_modules/@octokit/request/dist-web/index.js
var dist_web_exports2 = {};
__export(dist_web_exports2, {
  request: () => request
});
function isPlainObject2(value2) {
  if (typeof value2 !== "object" || value2 === null)
    return false;
  if (Object.prototype.toString.call(value2) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value2);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value2);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a3, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a3 = requestOptions.request) == null ? void 0 : _a3.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch: fetch2 } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch2 = requestOptions.request.fetch;
  }
  if (!fetch2) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch2(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data2 = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data2), status, {
        response: {
          url,
          status,
          headers,
          data: data2
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data2) => {
    return {
      status,
      url,
      headers,
      data: data2
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data2) {
  if (typeof data2 === "string")
    return data2;
  if ("message" in data2) {
    if (Array.isArray(data2.errors)) {
      return `${data2.message}: ${data2.errors.map(JSON.stringify).join(", ")}`;
    }
    return data2.message;
  }
  return `Unknown error: ${JSON.stringify(data2)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var import_universal_user_agent2, VERSION2, request;
var init_dist_web3 = __esm({
  "node_modules/@octokit/request/dist-web/index.js"() {
    init_dist_web();
    import_universal_user_agent2 = __toESM(require_dist_node());
    init_dist_web2();
    VERSION2 = "8.1.6";
    request = withDefaults2(endpoint, {
      headers: {
        "user-agent": `octokit-request.js/${VERSION2} ${(0, import_universal_user_agent2.getUserAgent)()}`
      }
    });
  }
});

// node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node3 = __commonJS({
  "node_modules/@octokit/graphql/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      GraphqlResponseError: () => GraphqlResponseError,
      graphql: () => graphql2,
      withCustomRequest: () => withCustomRequest
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_request32 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_universal_user_agent6 = require_dist_node();
    var VERSION12 = "7.0.2";
    var import_request22 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_request4 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    function _buildMessageForResponseErrors(data2) {
      return `Request failed due to following response errors:
` + data2.errors.map((e5) => ` - ${e5.message}`).join("\n");
    }
    var GraphqlResponseError = class extends Error {
      constructor(request2, headers, response) {
        super(_buildMessageForResponseErrors(response));
        this.request = request2;
        this.headers = headers;
        this.response = response;
        this.name = "GraphqlResponseError";
        this.errors = response.errors;
        this.data = response.data;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    var NON_VARIABLE_OPTIONS = [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "query",
      "mediaType"
    ];
    var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
    var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
    function graphql(request2, query, options) {
      if (options) {
        if (typeof query === "string" && "query" in options) {
          return Promise.reject(
            new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
          );
        }
        for (const key2 in options) {
          if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key2))
            continue;
          return Promise.reject(
            new Error(
              `[@octokit/graphql] "${key2}" cannot be used as variable name`
            )
          );
        }
      }
      const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
      const requestOptions = Object.keys(
        parsedOptions
      ).reduce((result, key2) => {
        if (NON_VARIABLE_OPTIONS.includes(key2)) {
          result[key2] = parsedOptions[key2];
          return result;
        }
        if (!result.variables) {
          result.variables = {};
        }
        result.variables[key2] = parsedOptions[key2];
        return result;
      }, {});
      const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
      if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
      }
      return request2(requestOptions).then((response) => {
        if (response.data.errors) {
          const headers = {};
          for (const key2 of Object.keys(response.headers)) {
            headers[key2] = response.headers[key2];
          }
          throw new GraphqlResponseError(
            requestOptions,
            headers,
            response.data
          );
        }
        return response.data.data;
      });
    }
    function withDefaults3(request2, newDefaults) {
      const newRequest = request2.defaults(newDefaults);
      const newApi = (query, options) => {
        return graphql(newRequest, query, options);
      };
      return Object.assign(newApi, {
        defaults: withDefaults3.bind(null, newRequest),
        endpoint: newRequest.endpoint
      });
    }
    var graphql2 = withDefaults3(import_request32.request, {
      headers: {
        "user-agent": `octokit-graphql.js/${VERSION12} ${(0, import_universal_user_agent6.getUserAgent)()}`
      },
      method: "POST",
      url: "/graphql"
    });
    function withCustomRequest(customRequest) {
      return withDefaults3(customRequest, {
        method: "POST",
        url: "/graphql"
      });
    }
  }
});

// node_modules/@octokit/auth-token/dist-web/index.js
var dist_web_exports3 = {};
__export(dist_web_exports3, {
  createTokenAuth: () => createTokenAuth
});
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var REGEX_IS_INSTALLATION_LEGACY, REGEX_IS_INSTALLATION, REGEX_IS_USER_TO_SERVER, createTokenAuth;
var init_dist_web4 = __esm({
  "node_modules/@octokit/auth-token/dist-web/index.js"() {
    REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
    REGEX_IS_INSTALLATION = /^ghs_/;
    REGEX_IS_USER_TO_SERVER = /^ghu_/;
    createTokenAuth = function createTokenAuth2(token) {
      if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
      }
      if (typeof token !== "string") {
        throw new Error(
          "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
        );
      }
      token = token.replace(/^(token|bearer) +/i, "");
      return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token)
      });
    };
  }
});

// node_modules/@octokit/core/dist-node/index.js
var require_dist_node4 = __commonJS({
  "node_modules/@octokit/core/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      Octokit: () => Octokit2
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_universal_user_agent6 = require_dist_node();
    var import_before_after_hook = require_before_after_hook();
    var import_request4 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_graphql = require_dist_node3();
    var import_auth_token = (init_dist_web4(), __toCommonJS(dist_web_exports3));
    var VERSION12 = "5.0.2";
    var noop2 = () => {
    };
    var consoleWarn = console.warn.bind(console);
    var consoleError = console.error.bind(console);
    var userAgentTrail = `octokit-core.js/${VERSION12} ${(0, import_universal_user_agent6.getUserAgent)()}`;
    var _a3;
    var Octokit2 = (_a3 = class {
      static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
          constructor(...args) {
            const options = args[0] || {};
            if (typeof defaults === "function") {
              super(defaults(options));
              return;
            }
            super(
              Object.assign(
                {},
                defaults,
                options,
                options.userAgent && defaults.userAgent ? {
                  userAgent: `${options.userAgent} ${defaults.userAgent}`
                } : null
              )
            );
          }
        };
        return OctokitWithDefaults;
      }
      /**
       * Attach a plugin (or many) to your Octokit instance.
       *
       * @example
       * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
       */
      static plugin(...newPlugins) {
        var _a4;
        const currentPlugins = this.plugins;
        const NewOctokit = (_a4 = class extends this {
        }, _a4.plugins = currentPlugins.concat(
          newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
        ), _a4);
        return NewOctokit;
      }
      constructor(options = {}) {
        const hook5 = new import_before_after_hook.Collection();
        const requestDefaults = {
          baseUrl: import_request4.request.endpoint.DEFAULTS.baseUrl,
          headers: {},
          request: Object.assign({}, options.request, {
            // @ts-ignore internal usage only, no need to type
            hook: hook5.bind(null, "request")
          }),
          mediaType: {
            previews: [],
            format: ""
          }
        };
        requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
        if (options.baseUrl) {
          requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
          requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
          requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = import_request4.request.defaults(requestDefaults);
        this.graphql = (0, import_graphql.withCustomRequest)(this.request).defaults(requestDefaults);
        this.log = Object.assign(
          {
            debug: noop2,
            info: noop2,
            warn: consoleWarn,
            error: consoleError
          },
          options.log
        );
        this.hook = hook5;
        if (!options.authStrategy) {
          if (!options.auth) {
            this.auth = async () => ({
              type: "unauthenticated"
            });
          } else {
            const auth5 = (0, import_auth_token.createTokenAuth)(options.auth);
            hook5.wrap("request", auth5.hook);
            this.auth = auth5;
          }
        } else {
          const { authStrategy, ...otherOptions } = options;
          const auth5 = authStrategy(
            Object.assign(
              {
                request: this.request,
                log: this.log,
                // we pass the current octokit instance as well as its constructor options
                // to allow for authentication strategies that return a new octokit instance
                // that shares the same internal state as the current one. The original
                // requirement for this was the "event-octokit" authentication strategy
                // of https://github.com/probot/octokit-auth-probot.
                octokit: this,
                octokitOptions: otherOptions
              },
              options.auth
            )
          );
          hook5.wrap("request", auth5.hook);
          this.auth = auth5;
        }
        const classConstructor = this.constructor;
        for (let i4 = 0; i4 < classConstructor.plugins.length; ++i4) {
          Object.assign(this, classConstructor.plugins[i4](this, options));
        }
      }
    }, _a3.VERSION = VERSION12, _a3.plugins = [], _a3);
  }
});

// node_modules/bottleneck/light.js
var require_light = __commonJS({
  "node_modules/bottleneck/light.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.Bottleneck = factory();
    })(exports2, function() {
      "use strict";
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getCjsExportFromNamespace(n3) {
        return n3 && n3["default"] || n3;
      }
      var load = function(received, defaults, onto = {}) {
        var k2, ref, v2;
        for (k2 in defaults) {
          v2 = defaults[k2];
          onto[k2] = (ref = received[k2]) != null ? ref : v2;
        }
        return onto;
      };
      var overwrite = function(received, defaults, onto = {}) {
        var k2, v2;
        for (k2 in received) {
          v2 = received[k2];
          if (defaults[k2] !== void 0) {
            onto[k2] = v2;
          }
        }
        return onto;
      };
      var parser = {
        load,
        overwrite
      };
      var DLList;
      DLList = class DLList {
        constructor(incr, decr) {
          this.incr = incr;
          this.decr = decr;
          this._first = null;
          this._last = null;
          this.length = 0;
        }
        push(value2) {
          var node;
          this.length++;
          if (typeof this.incr === "function") {
            this.incr();
          }
          node = {
            value: value2,
            prev: this._last,
            next: null
          };
          if (this._last != null) {
            this._last.next = node;
            this._last = node;
          } else {
            this._first = this._last = node;
          }
          return void 0;
        }
        shift() {
          var value2;
          if (this._first == null) {
            return;
          } else {
            this.length--;
            if (typeof this.decr === "function") {
              this.decr();
            }
          }
          value2 = this._first.value;
          if ((this._first = this._first.next) != null) {
            this._first.prev = null;
          } else {
            this._last = null;
          }
          return value2;
        }
        first() {
          if (this._first != null) {
            return this._first.value;
          }
        }
        getArray() {
          var node, ref, results;
          node = this._first;
          results = [];
          while (node != null) {
            results.push((ref = node, node = node.next, ref.value));
          }
          return results;
        }
        forEachShift(cb) {
          var node;
          node = this.shift();
          while (node != null) {
            cb(node), node = this.shift();
          }
          return void 0;
        }
        debug() {
          var node, ref, ref1, ref2, results;
          node = this._first;
          results = [];
          while (node != null) {
            results.push((ref = node, node = node.next, {
              value: ref.value,
              prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
              next: (ref2 = ref.next) != null ? ref2.value : void 0
            }));
          }
          return results;
        }
      };
      var DLList_1 = DLList;
      var Events;
      Events = class Events {
        constructor(instance) {
          this.instance = instance;
          this._events = {};
          if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
            throw new Error("An Emitter already exists for this object");
          }
          this.instance.on = (name2, cb) => {
            return this._addListener(name2, "many", cb);
          };
          this.instance.once = (name2, cb) => {
            return this._addListener(name2, "once", cb);
          };
          this.instance.removeAllListeners = (name2 = null) => {
            if (name2 != null) {
              return delete this._events[name2];
            } else {
              return this._events = {};
            }
          };
        }
        _addListener(name2, status, cb) {
          var base;
          if ((base = this._events)[name2] == null) {
            base[name2] = [];
          }
          this._events[name2].push({ cb, status });
          return this.instance;
        }
        listenerCount(name2) {
          if (this._events[name2] != null) {
            return this._events[name2].length;
          } else {
            return 0;
          }
        }
        async trigger(name2, ...args) {
          var e5, promises;
          try {
            if (name2 !== "debug") {
              this.trigger("debug", `Event triggered: ${name2}`, args);
            }
            if (this._events[name2] == null) {
              return;
            }
            this._events[name2] = this._events[name2].filter(function(listener) {
              return listener.status !== "none";
            });
            promises = this._events[name2].map(async (listener) => {
              var e6, returned;
              if (listener.status === "none") {
                return;
              }
              if (listener.status === "once") {
                listener.status = "none";
              }
              try {
                returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;
                if (typeof (returned != null ? returned.then : void 0) === "function") {
                  return await returned;
                } else {
                  return returned;
                }
              } catch (error) {
                e6 = error;
                {
                  this.trigger("error", e6);
                }
                return null;
              }
            });
            return (await Promise.all(promises)).find(function(x2) {
              return x2 != null;
            });
          } catch (error) {
            e5 = error;
            {
              this.trigger("error", e5);
            }
            return null;
          }
        }
      };
      var Events_1 = Events;
      var DLList$1, Events$1, Queues;
      DLList$1 = DLList_1;
      Events$1 = Events_1;
      Queues = class Queues {
        constructor(num_priorities) {
          var i4;
          this.Events = new Events$1(this);
          this._length = 0;
          this._lists = function() {
            var j2, ref, results;
            results = [];
            for (i4 = j2 = 1, ref = num_priorities; 1 <= ref ? j2 <= ref : j2 >= ref; i4 = 1 <= ref ? ++j2 : --j2) {
              results.push(new DLList$1(() => {
                return this.incr();
              }, () => {
                return this.decr();
              }));
            }
            return results;
          }.call(this);
        }
        incr() {
          if (this._length++ === 0) {
            return this.Events.trigger("leftzero");
          }
        }
        decr() {
          if (--this._length === 0) {
            return this.Events.trigger("zero");
          }
        }
        push(job) {
          return this._lists[job.options.priority].push(job);
        }
        queued(priority) {
          if (priority != null) {
            return this._lists[priority].length;
          } else {
            return this._length;
          }
        }
        shiftAll(fn) {
          return this._lists.forEach(function(list) {
            return list.forEachShift(fn);
          });
        }
        getFirst(arr = this._lists) {
          var j2, len, list;
          for (j2 = 0, len = arr.length; j2 < len; j2++) {
            list = arr[j2];
            if (list.length > 0) {
              return list;
            }
          }
          return [];
        }
        shiftLastFrom(priority) {
          return this.getFirst(this._lists.slice(priority).reverse()).shift();
        }
      };
      var Queues_1 = Queues;
      var BottleneckError;
      BottleneckError = class BottleneckError extends Error {
      };
      var BottleneckError_1 = BottleneckError;
      var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;
      NUM_PRIORITIES = 10;
      DEFAULT_PRIORITY = 5;
      parser$1 = parser;
      BottleneckError$1 = BottleneckError_1;
      Job = class Job {
        constructor(task, args, options, jobDefaults, rejectOnDrop, Events2, _states, Promise2) {
          this.task = task;
          this.args = args;
          this.rejectOnDrop = rejectOnDrop;
          this.Events = Events2;
          this._states = _states;
          this.Promise = Promise2;
          this.options = parser$1.load(options, jobDefaults);
          this.options.priority = this._sanitizePriority(this.options.priority);
          if (this.options.id === jobDefaults.id) {
            this.options.id = `${this.options.id}-${this._randomIndex()}`;
          }
          this.promise = new this.Promise((_resolve, _reject) => {
            this._resolve = _resolve;
            this._reject = _reject;
          });
          this.retryCount = 0;
        }
        _sanitizePriority(priority) {
          var sProperty;
          sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
          if (sProperty < 0) {
            return 0;
          } else if (sProperty > NUM_PRIORITIES - 1) {
            return NUM_PRIORITIES - 1;
          } else {
            return sProperty;
          }
        }
        _randomIndex() {
          return Math.random().toString(36).slice(2);
        }
        doDrop({ error, message = "This job has been dropped by Bottleneck" } = {}) {
          if (this._states.remove(this.options.id)) {
            if (this.rejectOnDrop) {
              this._reject(error != null ? error : new BottleneckError$1(message));
            }
            this.Events.trigger("dropped", { args: this.args, options: this.options, task: this.task, promise: this.promise });
            return true;
          } else {
            return false;
          }
        }
        _assertStatus(expected) {
          var status;
          status = this._states.jobStatus(this.options.id);
          if (!(status === expected || expected === "DONE" && status === null)) {
            throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
          }
        }
        doReceive() {
          this._states.start(this.options.id);
          return this.Events.trigger("received", { args: this.args, options: this.options });
        }
        doQueue(reachedHWM, blocked) {
          this._assertStatus("RECEIVED");
          this._states.next(this.options.id);
          return this.Events.trigger("queued", { args: this.args, options: this.options, reachedHWM, blocked });
        }
        doRun() {
          if (this.retryCount === 0) {
            this._assertStatus("QUEUED");
            this._states.next(this.options.id);
          } else {
            this._assertStatus("EXECUTING");
          }
          return this.Events.trigger("scheduled", { args: this.args, options: this.options });
        }
        async doExecute(chained, clearGlobalState, run, free) {
          var error, eventInfo, passed;
          if (this.retryCount === 0) {
            this._assertStatus("RUNNING");
            this._states.next(this.options.id);
          } else {
            this._assertStatus("EXECUTING");
          }
          eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount };
          this.Events.trigger("executing", eventInfo);
          try {
            passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args));
            if (clearGlobalState()) {
              this.doDone(eventInfo);
              await free(this.options, eventInfo);
              this._assertStatus("DONE");
              return this._resolve(passed);
            }
          } catch (error1) {
            error = error1;
            return this._onFailure(error, eventInfo, clearGlobalState, run, free);
          }
        }
        doExpire(clearGlobalState, run, free) {
          var error, eventInfo;
          if (this._states.jobStatus(this.options.id === "RUNNING")) {
            this._states.next(this.options.id);
          }
          this._assertStatus("EXECUTING");
          eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount };
          error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);
          return this._onFailure(error, eventInfo, clearGlobalState, run, free);
        }
        async _onFailure(error, eventInfo, clearGlobalState, run, free) {
          var retry2, retryAfter;
          if (clearGlobalState()) {
            retry2 = await this.Events.trigger("failed", error, eventInfo);
            if (retry2 != null) {
              retryAfter = ~~retry2;
              this.Events.trigger("retry", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);
              this.retryCount++;
              return run(retryAfter);
            } else {
              this.doDone(eventInfo);
              await free(this.options, eventInfo);
              this._assertStatus("DONE");
              return this._reject(error);
            }
          }
        }
        doDone(eventInfo) {
          this._assertStatus("EXECUTING");
          this._states.next(this.options.id);
          return this.Events.trigger("done", eventInfo);
        }
      };
      var Job_1 = Job;
      var BottleneckError$2, LocalDatastore, parser$2;
      parser$2 = parser;
      BottleneckError$2 = BottleneckError_1;
      LocalDatastore = class LocalDatastore {
        constructor(instance, storeOptions, storeInstanceOptions) {
          this.instance = instance;
          this.storeOptions = storeOptions;
          this.clientId = this.instance._randomIndex();
          parser$2.load(storeInstanceOptions, storeInstanceOptions, this);
          this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
          this._running = 0;
          this._done = 0;
          this._unblockTime = 0;
          this.ready = this.Promise.resolve();
          this.clients = {};
          this._startHeartbeat();
        }
        _startHeartbeat() {
          var base;
          if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
            return typeof (base = this.heartbeat = setInterval(() => {
              var amount, incr, maximum, now, reservoir;
              now = Date.now();
              if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
                this._lastReservoirRefresh = now;
                this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
                this.instance._drainAll(this.computeCapacity());
              }
              if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
                ({
                  reservoirIncreaseAmount: amount,
                  reservoirIncreaseMaximum: maximum,
                  reservoir
                } = this.storeOptions);
                this._lastReservoirIncrease = now;
                incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
                if (incr > 0) {
                  this.storeOptions.reservoir += incr;
                  return this.instance._drainAll(this.computeCapacity());
                }
              }
            }, this.heartbeatInterval)).unref === "function" ? base.unref() : void 0;
          } else {
            return clearInterval(this.heartbeat);
          }
        }
        async __publish__(message) {
          await this.yieldLoop();
          return this.instance.Events.trigger("message", message.toString());
        }
        async __disconnect__(flush) {
          await this.yieldLoop();
          clearInterval(this.heartbeat);
          return this.Promise.resolve();
        }
        yieldLoop(t5 = 0) {
          return new this.Promise(function(resolve, reject) {
            return setTimeout(resolve, t5);
          });
        }
        computePenalty() {
          var ref;
          return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5e3;
        }
        async __updateSettings__(options) {
          await this.yieldLoop();
          parser$2.overwrite(options, options, this.storeOptions);
          this._startHeartbeat();
          this.instance._drainAll(this.computeCapacity());
          return true;
        }
        async __running__() {
          await this.yieldLoop();
          return this._running;
        }
        async __queued__() {
          await this.yieldLoop();
          return this.instance.queued();
        }
        async __done__() {
          await this.yieldLoop();
          return this._done;
        }
        async __groupCheck__(time2) {
          await this.yieldLoop();
          return this._nextRequest + this.timeout < time2;
        }
        computeCapacity() {
          var maxConcurrent, reservoir;
          ({ maxConcurrent, reservoir } = this.storeOptions);
          if (maxConcurrent != null && reservoir != null) {
            return Math.min(maxConcurrent - this._running, reservoir);
          } else if (maxConcurrent != null) {
            return maxConcurrent - this._running;
          } else if (reservoir != null) {
            return reservoir;
          } else {
            return null;
          }
        }
        conditionsCheck(weight) {
          var capacity;
          capacity = this.computeCapacity();
          return capacity == null || weight <= capacity;
        }
        async __incrementReservoir__(incr) {
          var reservoir;
          await this.yieldLoop();
          reservoir = this.storeOptions.reservoir += incr;
          this.instance._drainAll(this.computeCapacity());
          return reservoir;
        }
        async __currentReservoir__() {
          await this.yieldLoop();
          return this.storeOptions.reservoir;
        }
        isBlocked(now) {
          return this._unblockTime >= now;
        }
        check(weight, now) {
          return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
        }
        async __check__(weight) {
          var now;
          await this.yieldLoop();
          now = Date.now();
          return this.check(weight, now);
        }
        async __register__(index2, weight, expiration) {
          var now, wait2;
          await this.yieldLoop();
          now = Date.now();
          if (this.conditionsCheck(weight)) {
            this._running += weight;
            if (this.storeOptions.reservoir != null) {
              this.storeOptions.reservoir -= weight;
            }
            wait2 = Math.max(this._nextRequest - now, 0);
            this._nextRequest = now + wait2 + this.storeOptions.minTime;
            return {
              success: true,
              wait: wait2,
              reservoir: this.storeOptions.reservoir
            };
          } else {
            return {
              success: false
            };
          }
        }
        strategyIsBlock() {
          return this.storeOptions.strategy === 3;
        }
        async __submit__(queueLength, weight) {
          var blocked, now, reachedHWM;
          await this.yieldLoop();
          if (this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent) {
            throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);
          }
          now = Date.now();
          reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now);
          blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));
          if (blocked) {
            this._unblockTime = now + this.computePenalty();
            this._nextRequest = this._unblockTime + this.storeOptions.minTime;
            this.instance._dropAllQueued();
          }
          return {
            reachedHWM,
            blocked,
            strategy: this.storeOptions.strategy
          };
        }
        async __free__(index2, weight) {
          await this.yieldLoop();
          this._running -= weight;
          this._done += weight;
          this.instance._drainAll(this.computeCapacity());
          return {
            running: this._running
          };
        }
      };
      var LocalDatastore_1 = LocalDatastore;
      var BottleneckError$3, States;
      BottleneckError$3 = BottleneckError_1;
      States = class States {
        constructor(status1) {
          this.status = status1;
          this._jobs = {};
          this.counts = this.status.map(function() {
            return 0;
          });
        }
        next(id) {
          var current, next;
          current = this._jobs[id];
          next = current + 1;
          if (current != null && next < this.status.length) {
            this.counts[current]--;
            this.counts[next]++;
            return this._jobs[id]++;
          } else if (current != null) {
            this.counts[current]--;
            return delete this._jobs[id];
          }
        }
        start(id) {
          var initial;
          initial = 0;
          this._jobs[id] = initial;
          return this.counts[initial]++;
        }
        remove(id) {
          var current;
          current = this._jobs[id];
          if (current != null) {
            this.counts[current]--;
            delete this._jobs[id];
          }
          return current != null;
        }
        jobStatus(id) {
          var ref;
          return (ref = this.status[this._jobs[id]]) != null ? ref : null;
        }
        statusJobs(status) {
          var k2, pos, ref, results, v2;
          if (status != null) {
            pos = this.status.indexOf(status);
            if (pos < 0) {
              throw new BottleneckError$3(`status must be one of ${this.status.join(", ")}`);
            }
            ref = this._jobs;
            results = [];
            for (k2 in ref) {
              v2 = ref[k2];
              if (v2 === pos) {
                results.push(k2);
              }
            }
            return results;
          } else {
            return Object.keys(this._jobs);
          }
        }
        statusCounts() {
          return this.counts.reduce((acc, v2, i4) => {
            acc[this.status[i4]] = v2;
            return acc;
          }, {});
        }
      };
      var States_1 = States;
      var DLList$2, Sync;
      DLList$2 = DLList_1;
      Sync = class Sync {
        constructor(name2, Promise2) {
          this.schedule = this.schedule.bind(this);
          this.name = name2;
          this.Promise = Promise2;
          this._running = 0;
          this._queue = new DLList$2();
        }
        isEmpty() {
          return this._queue.length === 0;
        }
        async _tryToRun() {
          var args, cb, error, reject, resolve, returned, task;
          if (this._running < 1 && this._queue.length > 0) {
            this._running++;
            ({ task, args, resolve, reject } = this._queue.shift());
            cb = await async function() {
              try {
                returned = await task(...args);
                return function() {
                  return resolve(returned);
                };
              } catch (error1) {
                error = error1;
                return function() {
                  return reject(error);
                };
              }
            }();
            this._running--;
            this._tryToRun();
            return cb();
          }
        }
        schedule(task, ...args) {
          var promise, reject, resolve;
          resolve = reject = null;
          promise = new this.Promise(function(_resolve, _reject) {
            resolve = _resolve;
            return reject = _reject;
          });
          this._queue.push({ task, args, resolve, reject });
          this._tryToRun();
          return promise;
        }
      };
      var Sync_1 = Sync;
      var version = "2.19.5";
      var version$1 = {
        version
      };
      var version$2 = /* @__PURE__ */ Object.freeze({
        version,
        default: version$1
      });
      var require$$2 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
      var require$$3 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
      var require$$4 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
      var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;
      parser$3 = parser;
      Events$2 = Events_1;
      RedisConnection$1 = require$$2;
      IORedisConnection$1 = require$$3;
      Scripts$1 = require$$4;
      Group = function() {
        class Group2 {
          constructor(limiterOptions = {}) {
            this.deleteKey = this.deleteKey.bind(this);
            this.limiterOptions = limiterOptions;
            parser$3.load(this.limiterOptions, this.defaults, this);
            this.Events = new Events$2(this);
            this.instances = {};
            this.Bottleneck = Bottleneck_1;
            this._startAutoCleanup();
            this.sharedConnection = this.connection != null;
            if (this.connection == null) {
              if (this.limiterOptions.datastore === "redis") {
                this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
              } else if (this.limiterOptions.datastore === "ioredis") {
                this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
              }
            }
          }
          key(key2 = "") {
            var ref;
            return (ref = this.instances[key2]) != null ? ref : (() => {
              var limiter;
              limiter = this.instances[key2] = new this.Bottleneck(Object.assign(this.limiterOptions, {
                id: `${this.id}-${key2}`,
                timeout: this.timeout,
                connection: this.connection
              }));
              this.Events.trigger("created", limiter, key2);
              return limiter;
            })();
          }
          async deleteKey(key2 = "") {
            var deleted, instance;
            instance = this.instances[key2];
            if (this.connection) {
              deleted = await this.connection.__runCommand__(["del", ...Scripts$1.allKeys(`${this.id}-${key2}`)]);
            }
            if (instance != null) {
              delete this.instances[key2];
              await instance.disconnect();
            }
            return instance != null || deleted > 0;
          }
          limiters() {
            var k2, ref, results, v2;
            ref = this.instances;
            results = [];
            for (k2 in ref) {
              v2 = ref[k2];
              results.push({
                key: k2,
                limiter: v2
              });
            }
            return results;
          }
          keys() {
            return Object.keys(this.instances);
          }
          async clusterKeys() {
            var cursor, end, found, i4, k2, keys, len, next, start;
            if (this.connection == null) {
              return this.Promise.resolve(this.keys());
            }
            keys = [];
            cursor = null;
            start = `b_${this.id}-`.length;
            end = "_settings".length;
            while (cursor !== 0) {
              [next, found] = await this.connection.__runCommand__(["scan", cursor != null ? cursor : 0, "match", `b_${this.id}-*_settings`, "count", 1e4]);
              cursor = ~~next;
              for (i4 = 0, len = found.length; i4 < len; i4++) {
                k2 = found[i4];
                keys.push(k2.slice(start, -end));
              }
            }
            return keys;
          }
          _startAutoCleanup() {
            var base;
            clearInterval(this.interval);
            return typeof (base = this.interval = setInterval(async () => {
              var e5, k2, ref, results, time2, v2;
              time2 = Date.now();
              ref = this.instances;
              results = [];
              for (k2 in ref) {
                v2 = ref[k2];
                try {
                  if (await v2._store.__groupCheck__(time2)) {
                    results.push(this.deleteKey(k2));
                  } else {
                    results.push(void 0);
                  }
                } catch (error) {
                  e5 = error;
                  results.push(v2.Events.trigger("error", e5));
                }
              }
              return results;
            }, this.timeout / 2)).unref === "function" ? base.unref() : void 0;
          }
          updateSettings(options = {}) {
            parser$3.overwrite(options, this.defaults, this);
            parser$3.overwrite(options, options, this.limiterOptions);
            if (options.timeout != null) {
              return this._startAutoCleanup();
            }
          }
          disconnect(flush = true) {
            var ref;
            if (!this.sharedConnection) {
              return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
            }
          }
        }
        Group2.prototype.defaults = {
          timeout: 1e3 * 60 * 5,
          connection: null,
          Promise,
          id: "group-key"
        };
        return Group2;
      }.call(commonjsGlobal);
      var Group_1 = Group;
      var Batcher, Events$3, parser$4;
      parser$4 = parser;
      Events$3 = Events_1;
      Batcher = function() {
        class Batcher2 {
          constructor(options = {}) {
            this.options = options;
            parser$4.load(this.options, this.defaults, this);
            this.Events = new Events$3(this);
            this._arr = [];
            this._resetPromise();
            this._lastFlush = Date.now();
          }
          _resetPromise() {
            return this._promise = new this.Promise((res, rej) => {
              return this._resolve = res;
            });
          }
          _flush() {
            clearTimeout(this._timeout);
            this._lastFlush = Date.now();
            this._resolve();
            this.Events.trigger("batch", this._arr);
            this._arr = [];
            return this._resetPromise();
          }
          add(data2) {
            var ret;
            this._arr.push(data2);
            ret = this._promise;
            if (this._arr.length === this.maxSize) {
              this._flush();
            } else if (this.maxTime != null && this._arr.length === 1) {
              this._timeout = setTimeout(() => {
                return this._flush();
              }, this.maxTime);
            }
            return ret;
          }
        }
        Batcher2.prototype.defaults = {
          maxTime: null,
          maxSize: null,
          Promise
        };
        return Batcher2;
      }.call(commonjsGlobal);
      var Batcher_1 = Batcher;
      var require$$4$1 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
      var require$$8 = getCjsExportFromNamespace(version$2);
      var Bottleneck2, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5, splice = [].splice;
      NUM_PRIORITIES$1 = 10;
      DEFAULT_PRIORITY$1 = 5;
      parser$5 = parser;
      Queues$1 = Queues_1;
      Job$1 = Job_1;
      LocalDatastore$1 = LocalDatastore_1;
      RedisDatastore$1 = require$$4$1;
      Events$4 = Events_1;
      States$1 = States_1;
      Sync$1 = Sync_1;
      Bottleneck2 = function() {
        class Bottleneck3 {
          constructor(options = {}, ...invalid) {
            var storeInstanceOptions, storeOptions;
            this._addToQueue = this._addToQueue.bind(this);
            this._validateOptions(options, invalid);
            parser$5.load(options, this.instanceDefaults, this);
            this._queues = new Queues$1(NUM_PRIORITIES$1);
            this._scheduled = {};
            this._states = new States$1(["RECEIVED", "QUEUED", "RUNNING", "EXECUTING"].concat(this.trackDoneStatus ? ["DONE"] : []));
            this._limiter = null;
            this.Events = new Events$4(this);
            this._submitLock = new Sync$1("submit", this.Promise);
            this._registerLock = new Sync$1("register", this.Promise);
            storeOptions = parser$5.load(options, this.storeDefaults, {});
            this._store = function() {
              if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
                storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});
                return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);
              } else if (this.datastore === "local") {
                storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});
                return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);
              } else {
                throw new Bottleneck3.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
              }
            }.call(this);
            this._queues.on("leftzero", () => {
              var ref;
              return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
            });
            this._queues.on("zero", () => {
              var ref;
              return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
            });
          }
          _validateOptions(options, invalid) {
            if (!(options != null && typeof options === "object" && invalid.length === 0)) {
              throw new Bottleneck3.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
            }
          }
          ready() {
            return this._store.ready;
          }
          clients() {
            return this._store.clients;
          }
          channel() {
            return `b_${this.id}`;
          }
          channel_client() {
            return `b_${this.id}_${this._store.clientId}`;
          }
          publish(message) {
            return this._store.__publish__(message);
          }
          disconnect(flush = true) {
            return this._store.__disconnect__(flush);
          }
          chain(_limiter) {
            this._limiter = _limiter;
            return this;
          }
          queued(priority) {
            return this._queues.queued(priority);
          }
          clusterQueued() {
            return this._store.__queued__();
          }
          empty() {
            return this.queued() === 0 && this._submitLock.isEmpty();
          }
          running() {
            return this._store.__running__();
          }
          done() {
            return this._store.__done__();
          }
          jobStatus(id) {
            return this._states.jobStatus(id);
          }
          jobs(status) {
            return this._states.statusJobs(status);
          }
          counts() {
            return this._states.statusCounts();
          }
          _randomIndex() {
            return Math.random().toString(36).slice(2);
          }
          check(weight = 1) {
            return this._store.__check__(weight);
          }
          _clearGlobalState(index2) {
            if (this._scheduled[index2] != null) {
              clearTimeout(this._scheduled[index2].expiration);
              delete this._scheduled[index2];
              return true;
            } else {
              return false;
            }
          }
          async _free(index2, job, options, eventInfo) {
            var e5, running;
            try {
              ({ running } = await this._store.__free__(index2, options.weight));
              this.Events.trigger("debug", `Freed ${options.id}`, eventInfo);
              if (running === 0 && this.empty()) {
                return this.Events.trigger("idle");
              }
            } catch (error1) {
              e5 = error1;
              return this.Events.trigger("error", e5);
            }
          }
          _run(index2, job, wait2) {
            var clearGlobalState, free, run;
            job.doRun();
            clearGlobalState = this._clearGlobalState.bind(this, index2);
            run = this._run.bind(this, index2, job);
            free = this._free.bind(this, index2, job);
            return this._scheduled[index2] = {
              timeout: setTimeout(() => {
                return job.doExecute(this._limiter, clearGlobalState, run, free);
              }, wait2),
              expiration: job.options.expiration != null ? setTimeout(function() {
                return job.doExpire(clearGlobalState, run, free);
              }, wait2 + job.options.expiration) : void 0,
              job
            };
          }
          _drainOne(capacity) {
            return this._registerLock.schedule(() => {
              var args, index2, next, options, queue;
              if (this.queued() === 0) {
                return this.Promise.resolve(null);
              }
              queue = this._queues.getFirst();
              ({ options, args } = next = queue.first());
              if (capacity != null && options.weight > capacity) {
                return this.Promise.resolve(null);
              }
              this.Events.trigger("debug", `Draining ${options.id}`, { args, options });
              index2 = this._randomIndex();
              return this._store.__register__(index2, options.weight, options.expiration).then(({ success, wait: wait2, reservoir }) => {
                var empty;
                this.Events.trigger("debug", `Drained ${options.id}`, { success, args, options });
                if (success) {
                  queue.shift();
                  empty = this.empty();
                  if (empty) {
                    this.Events.trigger("empty");
                  }
                  if (reservoir === 0) {
                    this.Events.trigger("depleted", empty);
                  }
                  this._run(index2, next, wait2);
                  return this.Promise.resolve(options.weight);
                } else {
                  return this.Promise.resolve(null);
                }
              });
            });
          }
          _drainAll(capacity, total = 0) {
            return this._drainOne(capacity).then((drained) => {
              var newCapacity;
              if (drained != null) {
                newCapacity = capacity != null ? capacity - drained : capacity;
                return this._drainAll(newCapacity, total + drained);
              } else {
                return this.Promise.resolve(total);
              }
            }).catch((e5) => {
              return this.Events.trigger("error", e5);
            });
          }
          _dropAllQueued(message) {
            return this._queues.shiftAll(function(job) {
              return job.doDrop({ message });
            });
          }
          stop(options = {}) {
            var done, waitForExecuting;
            options = parser$5.load(options, this.stopDefaults);
            waitForExecuting = (at) => {
              var finished;
              finished = () => {
                var counts;
                counts = this._states.counts;
                return counts[0] + counts[1] + counts[2] + counts[3] === at;
              };
              return new this.Promise((resolve, reject) => {
                if (finished()) {
                  return resolve();
                } else {
                  return this.on("done", () => {
                    if (finished()) {
                      this.removeAllListeners("done");
                      return resolve();
                    }
                  });
                }
              });
            };
            done = options.dropWaitingJobs ? (this._run = function(index2, next) {
              return next.doDrop({
                message: options.dropErrorMessage
              });
            }, this._drainOne = () => {
              return this.Promise.resolve(null);
            }, this._registerLock.schedule(() => {
              return this._submitLock.schedule(() => {
                var k2, ref, v2;
                ref = this._scheduled;
                for (k2 in ref) {
                  v2 = ref[k2];
                  if (this.jobStatus(v2.job.options.id) === "RUNNING") {
                    clearTimeout(v2.timeout);
                    clearTimeout(v2.expiration);
                    v2.job.doDrop({
                      message: options.dropErrorMessage
                    });
                  }
                }
                this._dropAllQueued(options.dropErrorMessage);
                return waitForExecuting(0);
              });
            })) : this.schedule({
              priority: NUM_PRIORITIES$1 - 1,
              weight: 0
            }, () => {
              return waitForExecuting(1);
            });
            this._receive = function(job) {
              return job._reject(new Bottleneck3.prototype.BottleneckError(options.enqueueErrorMessage));
            };
            this.stop = () => {
              return this.Promise.reject(new Bottleneck3.prototype.BottleneckError("stop() has already been called"));
            };
            return done;
          }
          async _addToQueue(job) {
            var args, blocked, error, options, reachedHWM, shifted, strategy;
            ({ args, options } = job);
            try {
              ({ reachedHWM, blocked, strategy } = await this._store.__submit__(this.queued(), options.weight));
            } catch (error1) {
              error = error1;
              this.Events.trigger("debug", `Could not queue ${options.id}`, { args, options, error });
              job.doDrop({ error });
              return false;
            }
            if (blocked) {
              job.doDrop();
              return true;
            } else if (reachedHWM) {
              shifted = strategy === Bottleneck3.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck3.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck3.prototype.strategy.OVERFLOW ? job : void 0;
              if (shifted != null) {
                shifted.doDrop();
              }
              if (shifted == null || strategy === Bottleneck3.prototype.strategy.OVERFLOW) {
                if (shifted == null) {
                  job.doDrop();
                }
                return reachedHWM;
              }
            }
            job.doQueue(reachedHWM, blocked);
            this._queues.push(job);
            await this._drainAll();
            return reachedHWM;
          }
          _receive(job) {
            if (this._states.jobStatus(job.options.id) != null) {
              job._reject(new Bottleneck3.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
              return false;
            } else {
              job.doReceive();
              return this._submitLock.schedule(this._addToQueue, job);
            }
          }
          submit(...args) {
            var cb, fn, job, options, ref, ref1, task;
            if (typeof args[0] === "function") {
              ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);
              options = parser$5.load({}, this.jobDefaults);
            } else {
              ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);
              options = parser$5.load(options, this.jobDefaults);
            }
            task = (...args2) => {
              return new this.Promise(function(resolve, reject) {
                return fn(...args2, function(...args3) {
                  return (args3[0] != null ? reject : resolve)(args3);
                });
              });
            };
            job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
            job.promise.then(function(args2) {
              return typeof cb === "function" ? cb(...args2) : void 0;
            }).catch(function(args2) {
              if (Array.isArray(args2)) {
                return typeof cb === "function" ? cb(...args2) : void 0;
              } else {
                return typeof cb === "function" ? cb(args2) : void 0;
              }
            });
            return this._receive(job);
          }
          schedule(...args) {
            var job, options, task;
            if (typeof args[0] === "function") {
              [task, ...args] = args;
              options = {};
            } else {
              [options, task, ...args] = args;
            }
            job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
            this._receive(job);
            return job.promise;
          }
          wrap(fn) {
            var schedule, wrapped;
            schedule = this.schedule.bind(this);
            wrapped = function(...args) {
              return schedule(fn.bind(this), ...args);
            };
            wrapped.withOptions = function(options, ...args) {
              return schedule(options, fn, ...args);
            };
            return wrapped;
          }
          async updateSettings(options = {}) {
            await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));
            parser$5.overwrite(options, this.instanceDefaults, this);
            return this;
          }
          currentReservoir() {
            return this._store.__currentReservoir__();
          }
          incrementReservoir(incr = 0) {
            return this._store.__incrementReservoir__(incr);
          }
        }
        Bottleneck3.default = Bottleneck3;
        Bottleneck3.Events = Events$4;
        Bottleneck3.version = Bottleneck3.prototype.version = require$$8.version;
        Bottleneck3.strategy = Bottleneck3.prototype.strategy = {
          LEAK: 1,
          OVERFLOW: 2,
          OVERFLOW_PRIORITY: 4,
          BLOCK: 3
        };
        Bottleneck3.BottleneckError = Bottleneck3.prototype.BottleneckError = BottleneckError_1;
        Bottleneck3.Group = Bottleneck3.prototype.Group = Group_1;
        Bottleneck3.RedisConnection = Bottleneck3.prototype.RedisConnection = require$$2;
        Bottleneck3.IORedisConnection = Bottleneck3.prototype.IORedisConnection = require$$3;
        Bottleneck3.Batcher = Bottleneck3.prototype.Batcher = Batcher_1;
        Bottleneck3.prototype.jobDefaults = {
          priority: DEFAULT_PRIORITY$1,
          weight: 1,
          expiration: null,
          id: "<no-id>"
        };
        Bottleneck3.prototype.storeDefaults = {
          maxConcurrent: null,
          minTime: 0,
          highWater: null,
          strategy: Bottleneck3.prototype.strategy.LEAK,
          penalty: null,
          reservoir: null,
          reservoirRefreshInterval: null,
          reservoirRefreshAmount: null,
          reservoirIncreaseInterval: null,
          reservoirIncreaseAmount: null,
          reservoirIncreaseMaximum: null
        };
        Bottleneck3.prototype.localStoreDefaults = {
          Promise,
          timeout: null,
          heartbeatInterval: 250
        };
        Bottleneck3.prototype.redisStoreDefaults = {
          Promise,
          timeout: null,
          heartbeatInterval: 5e3,
          clientTimeout: 1e4,
          Redis: null,
          clientOptions: {},
          clusterNodes: null,
          clearDatastore: false,
          connection: null
        };
        Bottleneck3.prototype.instanceDefaults = {
          datastore: "local",
          connection: null,
          id: "<no-id>",
          rejectOnDrop: true,
          trackDoneStatus: false,
          Promise
        };
        Bottleneck3.prototype.stopDefaults = {
          enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
          dropWaitingJobs: true,
          dropErrorMessage: "This limiter has been stopped."
        };
        return Bottleneck3;
      }.call(commonjsGlobal);
      var Bottleneck_1 = Bottleneck2;
      var lib = Bottleneck_1;
      return lib;
    });
  }
});

// node_modules/btoa-lite/btoa-browser.js
var require_btoa_browser = __commonJS({
  "node_modules/btoa-lite/btoa-browser.js"(exports2, module2) {
    module2.exports = function _btoa(str) {
      return btoa(str);
    };
  }
});

// node_modules/@octokit/oauth-authorization-url/dist-web/index.js
var dist_web_exports4 = {};
__export(dist_web_exports4, {
  oauthAuthorizationUrl: () => oauthAuthorizationUrl
});
function oauthAuthorizationUrl(options) {
  const clientType = options.clientType || "oauth-app";
  const baseUrl = options.baseUrl || "https://github.com";
  const result = {
    clientType,
    allowSignup: options.allowSignup === false ? false : true,
    clientId: options.clientId,
    login: options.login || null,
    redirectUrl: options.redirectUrl || null,
    state: options.state || Math.random().toString(36).substr(2),
    url: ""
  };
  if (clientType === "oauth-app") {
    const scopes = "scopes" in options ? options.scopes : [];
    result.scopes = typeof scopes === "string" ? scopes.split(/[,\s]+/).filter(Boolean) : scopes;
  }
  result.url = urlBuilderAuthorize(`${baseUrl}/login/oauth/authorize`, result);
  return result;
}
function urlBuilderAuthorize(base, options) {
  const map = {
    allowSignup: "allow_signup",
    clientId: "client_id",
    login: "login",
    redirectUrl: "redirect_uri",
    scopes: "scope",
    state: "state"
  };
  let url = base;
  Object.keys(map).filter((k2) => options[k2] !== null).filter((k2) => {
    if (k2 !== "scopes")
      return true;
    if (options.clientType === "github-app")
      return false;
    return !Array.isArray(options[k2]) || options[k2].length > 0;
  }).map((key2) => [map[key2], `${options[key2]}`]).forEach(([key2, value2], index2) => {
    url += index2 === 0 ? `?` : "&";
    url += `${key2}=${encodeURIComponent(value2)}`;
  });
  return url;
}
var init_dist_web5 = __esm({
  "node_modules/@octokit/oauth-authorization-url/dist-web/index.js"() {
  }
});

// node_modules/@octokit/oauth-methods/dist-node/index.js
var require_dist_node5 = __commonJS({
  "node_modules/@octokit/oauth-methods/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      VERSION: () => VERSION12,
      checkToken: () => checkToken2,
      createDeviceCode: () => createDeviceCode2,
      deleteAuthorization: () => deleteAuthorization2,
      deleteToken: () => deleteToken2,
      exchangeDeviceCode: () => exchangeDeviceCode2,
      exchangeWebFlowCode: () => exchangeWebFlowCode2,
      getWebFlowAuthorizationUrl: () => getWebFlowAuthorizationUrl,
      refreshToken: () => refreshToken2,
      resetToken: () => resetToken2,
      scopeToken: () => scopeToken
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var VERSION12 = "4.0.1";
    var import_oauth_authorization_url = (init_dist_web5(), __toCommonJS(dist_web_exports4));
    var import_request4 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_request_error3 = (init_dist_web2(), __toCommonJS(dist_web_exports));
    function requestToOAuthBaseUrl(request2) {
      const endpointDefaults = request2.endpoint.DEFAULTS;
      return /^https:\/\/(api\.)?github\.com$/.test(endpointDefaults.baseUrl) ? "https://github.com" : endpointDefaults.baseUrl.replace("/api/v3", "");
    }
    async function oauthRequest(request2, route, parameters) {
      const withOAuthParameters = {
        baseUrl: requestToOAuthBaseUrl(request2),
        headers: {
          accept: "application/json"
        },
        ...parameters
      };
      const response = await request2(route, withOAuthParameters);
      if ("error" in response.data) {
        const error = new import_request_error3.RequestError(
          `${response.data.error_description} (${response.data.error}, ${response.data.error_uri})`,
          400,
          {
            request: request2.endpoint.merge(
              route,
              withOAuthParameters
            ),
            headers: response.headers
          }
        );
        error.response = response;
        throw error;
      }
      return response;
    }
    function getWebFlowAuthorizationUrl({
      request: request2 = import_request4.request,
      ...options
    }) {
      const baseUrl = requestToOAuthBaseUrl(request2);
      return (0, import_oauth_authorization_url.oauthAuthorizationUrl)({
        ...options,
        baseUrl
      });
    }
    var import_request22 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    async function exchangeWebFlowCode2(options) {
      const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
      import_request22.request;
      const response = await oauthRequest(
        request2,
        "POST /login/oauth/access_token",
        {
          client_id: options.clientId,
          client_secret: options.clientSecret,
          code: options.code,
          redirect_uri: options.redirectUrl
        }
      );
      const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.access_token,
        scopes: response.data.scope.split(/\s+/).filter(Boolean)
      };
      if (options.clientType === "github-app") {
        if ("refresh_token" in response.data) {
          const apiTimeInMs = new Date(response.headers.date).getTime();
          authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp(
            apiTimeInMs,
            response.data.expires_in
          ), authentication.refreshTokenExpiresAt = toTimestamp(
            apiTimeInMs,
            response.data.refresh_token_expires_in
          );
        }
        delete authentication.scopes;
      }
      return { ...response, authentication };
    }
    function toTimestamp(apiTimeInMs, expirationInSeconds) {
      return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
    }
    var import_request32 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    async function createDeviceCode2(options) {
      const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
      import_request32.request;
      const parameters = {
        client_id: options.clientId
      };
      if ("scopes" in options && Array.isArray(options.scopes)) {
        parameters.scope = options.scopes.join(" ");
      }
      return oauthRequest(request2, "POST /login/device/code", parameters);
    }
    var import_request42 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    async function exchangeDeviceCode2(options) {
      const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
      import_request42.request;
      const response = await oauthRequest(
        request2,
        "POST /login/oauth/access_token",
        {
          client_id: options.clientId,
          device_code: options.code,
          grant_type: "urn:ietf:params:oauth:grant-type:device_code"
        }
      );
      const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        token: response.data.access_token,
        scopes: response.data.scope.split(/\s+/).filter(Boolean)
      };
      if ("clientSecret" in options) {
        authentication.clientSecret = options.clientSecret;
      }
      if (options.clientType === "github-app") {
        if ("refresh_token" in response.data) {
          const apiTimeInMs = new Date(response.headers.date).getTime();
          authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp2(
            apiTimeInMs,
            response.data.expires_in
          ), authentication.refreshTokenExpiresAt = toTimestamp2(
            apiTimeInMs,
            response.data.refresh_token_expires_in
          );
        }
        delete authentication.scopes;
      }
      return { ...response, authentication };
    }
    function toTimestamp2(apiTimeInMs, expirationInSeconds) {
      return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
    }
    var import_request5 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_btoa_lite4 = __toESM2(require_btoa_browser());
    async function checkToken2(options) {
      const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
      import_request5.request;
      const response = await request2("POST /applications/{client_id}/token", {
        headers: {
          authorization: `basic ${(0, import_btoa_lite4.default)(
            `${options.clientId}:${options.clientSecret}`
          )}`
        },
        client_id: options.clientId,
        access_token: options.token
      });
      const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: options.token,
        scopes: response.data.scopes
      };
      if (response.data.expires_at)
        authentication.expiresAt = response.data.expires_at;
      if (options.clientType === "github-app") {
        delete authentication.scopes;
      }
      return { ...response, authentication };
    }
    var import_request6 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    async function refreshToken2(options) {
      const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
      import_request6.request;
      const response = await oauthRequest(
        request2,
        "POST /login/oauth/access_token",
        {
          client_id: options.clientId,
          client_secret: options.clientSecret,
          grant_type: "refresh_token",
          refresh_token: options.refreshToken
        }
      );
      const apiTimeInMs = new Date(response.headers.date).getTime();
      const authentication = {
        clientType: "github-app",
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.access_token,
        refreshToken: response.data.refresh_token,
        expiresAt: toTimestamp3(apiTimeInMs, response.data.expires_in),
        refreshTokenExpiresAt: toTimestamp3(
          apiTimeInMs,
          response.data.refresh_token_expires_in
        )
      };
      return { ...response, authentication };
    }
    function toTimestamp3(apiTimeInMs, expirationInSeconds) {
      return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
    }
    var import_request7 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_btoa_lite22 = __toESM2(require_btoa_browser());
    async function scopeToken(options) {
      const {
        request: optionsRequest,
        clientType,
        clientId,
        clientSecret,
        token,
        ...requestOptions
      } = options;
      const request2 = optionsRequest || /* istanbul ignore next: we always pass a custom request in tests */
      import_request7.request;
      const response = await request2(
        "POST /applications/{client_id}/token/scoped",
        {
          headers: {
            authorization: `basic ${(0, import_btoa_lite22.default)(`${clientId}:${clientSecret}`)}`
          },
          client_id: clientId,
          access_token: token,
          ...requestOptions
        }
      );
      const authentication = Object.assign(
        {
          clientType,
          clientId,
          clientSecret,
          token: response.data.token
        },
        response.data.expires_at ? { expiresAt: response.data.expires_at } : {}
      );
      return { ...response, authentication };
    }
    var import_request8 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_btoa_lite32 = __toESM2(require_btoa_browser());
    async function resetToken2(options) {
      const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
      import_request8.request;
      const auth5 = (0, import_btoa_lite32.default)(`${options.clientId}:${options.clientSecret}`);
      const response = await request2(
        "PATCH /applications/{client_id}/token",
        {
          headers: {
            authorization: `basic ${auth5}`
          },
          client_id: options.clientId,
          access_token: options.token
        }
      );
      const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.token,
        scopes: response.data.scopes
      };
      if (response.data.expires_at)
        authentication.expiresAt = response.data.expires_at;
      if (options.clientType === "github-app") {
        delete authentication.scopes;
      }
      return { ...response, authentication };
    }
    var import_request9 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_btoa_lite42 = __toESM2(require_btoa_browser());
    async function deleteToken2(options) {
      const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
      import_request9.request;
      const auth5 = (0, import_btoa_lite42.default)(`${options.clientId}:${options.clientSecret}`);
      return request2(
        "DELETE /applications/{client_id}/token",
        {
          headers: {
            authorization: `basic ${auth5}`
          },
          client_id: options.clientId,
          access_token: options.token
        }
      );
    }
    var import_request10 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_btoa_lite5 = __toESM2(require_btoa_browser());
    async function deleteAuthorization2(options) {
      const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
      import_request10.request;
      const auth5 = (0, import_btoa_lite5.default)(`${options.clientId}:${options.clientSecret}`);
      return request2(
        "DELETE /applications/{client_id}/grant",
        {
          headers: {
            authorization: `basic ${auth5}`
          },
          client_id: options.clientId,
          access_token: options.token
        }
      );
    }
  }
});

// node_modules/@octokit/auth-oauth-device/dist-web/index.js
async function getOAuthAccessToken(state, options) {
  const cachedAuthentication = getCachedAuthentication(state, options.auth);
  if (cachedAuthentication)
    return cachedAuthentication;
  const { data: verification } = await (0, import_oauth_methods.createDeviceCode)({
    clientType: state.clientType,
    clientId: state.clientId,
    request: options.request || state.request,
    // @ts-expect-error the extra code to make TS happy is not worth it
    scopes: options.auth.scopes || state.scopes
  });
  await state.onVerification(verification);
  const authentication = await waitForAccessToken(
    options.request || state.request,
    state.clientId,
    state.clientType,
    verification
  );
  state.authentication = authentication;
  return authentication;
}
function getCachedAuthentication(state, auth22) {
  if (auth22.refresh === true)
    return false;
  if (!state.authentication)
    return false;
  if (state.clientType === "github-app") {
    return state.authentication;
  }
  const authentication = state.authentication;
  const newScope = ("scopes" in auth22 && auth22.scopes || state.scopes).join(
    " "
  );
  const currentScope = authentication.scopes.join(" ");
  return newScope === currentScope ? authentication : false;
}
async function wait(seconds) {
  await new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
}
async function waitForAccessToken(request2, clientId, clientType, verification) {
  try {
    const options = {
      clientId,
      request: request2,
      code: verification.device_code
    };
    const { authentication } = clientType === "oauth-app" ? await (0, import_oauth_methods.exchangeDeviceCode)({
      ...options,
      clientType: "oauth-app"
    }) : await (0, import_oauth_methods.exchangeDeviceCode)({
      ...options,
      clientType: "github-app"
    });
    return {
      type: "token",
      tokenType: "oauth",
      ...authentication
    };
  } catch (error) {
    if (!error.response)
      throw error;
    const errorType = error.response.data.error;
    if (errorType === "authorization_pending") {
      await wait(verification.interval);
      return waitForAccessToken(request2, clientId, clientType, verification);
    }
    if (errorType === "slow_down") {
      await wait(verification.interval + 5);
      return waitForAccessToken(request2, clientId, clientType, verification);
    }
    throw error;
  }
}
async function auth2(state, authOptions) {
  return getOAuthAccessToken(state, {
    auth: authOptions
  });
}
async function hook2(state, request2, route, parameters) {
  let endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint2.url)) {
    return request2(endpoint2);
  }
  const { token } = await getOAuthAccessToken(state, {
    request: request2,
    auth: { type: "oauth" }
  });
  endpoint2.headers.authorization = `token ${token}`;
  return request2(endpoint2);
}
function createOAuthDeviceAuth(options) {
  const requestWithDefaults = options.request || request.defaults({
    headers: {
      "user-agent": `octokit-auth-oauth-device.js/${VERSION7} ${(0, import_universal_user_agent3.getUserAgent)()}`
    }
  });
  const { request: request2 = requestWithDefaults, ...otherOptions } = options;
  const state = options.clientType === "github-app" ? {
    ...otherOptions,
    clientType: "github-app",
    request: request2
  } : {
    ...otherOptions,
    clientType: "oauth-app",
    request: request2,
    scopes: options.scopes || []
  };
  if (!options.clientId) {
    throw new Error(
      '[@octokit/auth-oauth-device] "clientId" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)'
    );
  }
  if (!options.onVerification) {
    throw new Error(
      '[@octokit/auth-oauth-device] "onVerification" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)'
    );
  }
  return Object.assign(auth2.bind(null, state), {
    hook: hook2.bind(null, state)
  });
}
var import_universal_user_agent3, import_oauth_methods, VERSION7;
var init_dist_web6 = __esm({
  "node_modules/@octokit/auth-oauth-device/dist-web/index.js"() {
    import_universal_user_agent3 = __toESM(require_dist_node());
    init_dist_web3();
    import_oauth_methods = __toESM(require_dist_node5());
    VERSION7 = "6.0.1";
  }
});

// node_modules/@octokit/auth-oauth-user/dist-web/index.js
var dist_web_exports5 = {};
__export(dist_web_exports5, {
  createOAuthUserAuth: () => createOAuthUserAuth2,
  requiresBasicAuth: () => requiresBasicAuth
});
async function getAuthentication(state) {
  if ("code" in state.strategyOptions) {
    const { authentication } = await (0, import_oauth_methods2.exchangeWebFlowCode)({
      clientId: state.clientId,
      clientSecret: state.clientSecret,
      clientType: state.clientType,
      onTokenCreated: state.onTokenCreated,
      ...state.strategyOptions,
      request: state.request
    });
    return {
      type: "token",
      tokenType: "oauth",
      ...authentication
    };
  }
  if ("onVerification" in state.strategyOptions) {
    const deviceAuth = createOAuthDeviceAuth({
      clientType: state.clientType,
      clientId: state.clientId,
      onTokenCreated: state.onTokenCreated,
      ...state.strategyOptions,
      request: state.request
    });
    const authentication = await deviceAuth({
      type: "oauth"
    });
    return {
      clientSecret: state.clientSecret,
      ...authentication
    };
  }
  if ("token" in state.strategyOptions) {
    return {
      type: "token",
      tokenType: "oauth",
      clientId: state.clientId,
      clientSecret: state.clientSecret,
      clientType: state.clientType,
      onTokenCreated: state.onTokenCreated,
      ...state.strategyOptions
    };
  }
  throw new Error("[@octokit/auth-oauth-user] Invalid strategy options");
}
async function auth3(state, options = {}) {
  var _a3, _b;
  if (!state.authentication) {
    state.authentication = state.clientType === "oauth-app" ? await getAuthentication(state) : await getAuthentication(state);
  }
  if (state.authentication.invalid) {
    throw new Error("[@octokit/auth-oauth-user] Token is invalid");
  }
  const currentAuthentication = state.authentication;
  if ("expiresAt" in currentAuthentication) {
    if (options.type === "refresh" || new Date(currentAuthentication.expiresAt) < /* @__PURE__ */ new Date()) {
      const { authentication } = await (0, import_oauth_methods3.refreshToken)({
        clientType: "github-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        refreshToken: currentAuthentication.refreshToken,
        request: state.request
      });
      state.authentication = {
        tokenType: "oauth",
        type: "token",
        ...authentication
      };
    }
  }
  if (options.type === "refresh") {
    if (state.clientType === "oauth-app") {
      throw new Error(
        "[@octokit/auth-oauth-user] OAuth Apps do not support expiring tokens"
      );
    }
    if (!currentAuthentication.hasOwnProperty("expiresAt")) {
      throw new Error("[@octokit/auth-oauth-user] Refresh token missing");
    }
    await ((_a3 = state.onTokenCreated) == null ? void 0 : _a3.call(state, state.authentication, {
      type: options.type
    }));
  }
  if (options.type === "check" || options.type === "reset") {
    const method = options.type === "check" ? import_oauth_methods3.checkToken : import_oauth_methods3.resetToken;
    try {
      const { authentication } = await method({
        // @ts-expect-error making TS happy would require unnecessary code so no
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: state.authentication.token,
        request: state.request
      });
      state.authentication = {
        tokenType: "oauth",
        type: "token",
        // @ts-expect-error TBD
        ...authentication
      };
      if (options.type === "reset") {
        await ((_b = state.onTokenCreated) == null ? void 0 : _b.call(state, state.authentication, {
          type: options.type
        }));
      }
      return state.authentication;
    } catch (error) {
      if (error.status === 404) {
        error.message = "[@octokit/auth-oauth-user] Token is invalid";
        state.authentication.invalid = true;
      }
      throw error;
    }
  }
  if (options.type === "delete" || options.type === "deleteAuthorization") {
    const method = options.type === "delete" ? import_oauth_methods3.deleteToken : import_oauth_methods3.deleteAuthorization;
    try {
      await method({
        // @ts-expect-error making TS happy would require unnecessary code so no
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: state.authentication.token,
        request: state.request
      });
    } catch (error) {
      if (error.status !== 404)
        throw error;
    }
    state.authentication.invalid = true;
    return state.authentication;
  }
  return state.authentication;
}
function requiresBasicAuth(url) {
  return url && ROUTES_REQUIRING_BASIC_AUTH.test(url);
}
async function hook3(state, request2, route, parameters = {}) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint2.url)) {
    return request2(endpoint2);
  }
  if (requiresBasicAuth(endpoint2.url)) {
    const credentials = (0, import_btoa_lite.default)(`${state.clientId}:${state.clientSecret}`);
    endpoint2.headers.authorization = `basic ${credentials}`;
    return request2(endpoint2);
  }
  const { token } = state.clientType === "oauth-app" ? await auth3({ ...state, request: request2 }) : await auth3({ ...state, request: request2 });
  endpoint2.headers.authorization = "token " + token;
  return request2(endpoint2);
}
function createOAuthUserAuth2({
  clientId,
  clientSecret,
  clientType = "oauth-app",
  request: request2 = request.defaults({
    headers: {
      "user-agent": `octokit-auth-oauth-app.js/${VERSION8} ${(0, import_universal_user_agent4.getUserAgent)()}`
    }
  }),
  onTokenCreated,
  ...strategyOptions
}) {
  const state = Object.assign({
    clientType,
    clientId,
    clientSecret,
    onTokenCreated,
    strategyOptions,
    request: request2
  });
  return Object.assign(auth3.bind(null, state), {
    // @ts-expect-error not worth the extra code needed to appease TS
    hook: hook3.bind(null, state)
  });
}
var import_universal_user_agent4, import_oauth_methods2, import_oauth_methods3, import_btoa_lite, VERSION8, ROUTES_REQUIRING_BASIC_AUTH;
var init_dist_web7 = __esm({
  "node_modules/@octokit/auth-oauth-user/dist-web/index.js"() {
    import_universal_user_agent4 = __toESM(require_dist_node());
    init_dist_web3();
    init_dist_web6();
    import_oauth_methods2 = __toESM(require_dist_node5());
    import_oauth_methods3 = __toESM(require_dist_node5());
    import_btoa_lite = __toESM(require_btoa_browser());
    VERSION8 = "4.0.1";
    ROUTES_REQUIRING_BASIC_AUTH = /\/applications\/[^/]+\/(token|grant)s?/;
    createOAuthUserAuth2.VERSION = VERSION8;
  }
});

// node_modules/@octokit/auth-oauth-app/dist-web/index.js
var dist_web_exports6 = {};
__export(dist_web_exports6, {
  createOAuthAppAuth: () => createOAuthAppAuth,
  createOAuthUserAuth: () => createOAuthUserAuth2
});
async function auth4(state, authOptions) {
  if (authOptions.type === "oauth-app") {
    return {
      type: "oauth-app",
      clientId: state.clientId,
      clientSecret: state.clientSecret,
      clientType: state.clientType,
      headers: {
        authorization: `basic ${(0, import_btoa_lite2.default)(
          `${state.clientId}:${state.clientSecret}`
        )}`
      }
    };
  }
  if ("factory" in authOptions) {
    const { type, ...options } = {
      ...authOptions,
      ...state
    };
    return authOptions.factory(options);
  }
  const common = {
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.request,
    ...authOptions
  };
  const userAuth = state.clientType === "oauth-app" ? await createOAuthUserAuth2({
    ...common,
    clientType: state.clientType
  }) : await createOAuthUserAuth2({
    ...common,
    clientType: state.clientType
  });
  return userAuth();
}
async function hook4(state, request2, route, parameters) {
  let endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint2.url)) {
    return request2(endpoint2);
  }
  if (state.clientType === "github-app" && !requiresBasicAuth(endpoint2.url)) {
    throw new Error(
      `[@octokit/auth-oauth-app] GitHub Apps cannot use their client ID/secret for basic authentication for endpoints other than "/applications/{client_id}/**". "${endpoint2.method} ${endpoint2.url}" is not supported.`
    );
  }
  const credentials = (0, import_btoa_lite3.default)(`${state.clientId}:${state.clientSecret}`);
  endpoint2.headers.authorization = `basic ${credentials}`;
  try {
    return await request2(endpoint2);
  } catch (error) {
    if (error.status !== 401)
      throw error;
    error.message = `[@octokit/auth-oauth-app] "${endpoint2.method} ${endpoint2.url}" does not support clientId/clientSecret basic authentication.`;
    throw error;
  }
}
function createOAuthAppAuth(options) {
  const state = Object.assign(
    {
      request: request.defaults({
        headers: {
          "user-agent": `octokit-auth-oauth-app.js/${VERSION9} ${(0, import_universal_user_agent5.getUserAgent)()}`
        }
      }),
      clientType: "oauth-app"
    },
    options
  );
  return Object.assign(auth4.bind(null, state), {
    hook: hook4.bind(null, state)
  });
}
var import_universal_user_agent5, import_btoa_lite2, import_btoa_lite3, VERSION9;
var init_dist_web8 = __esm({
  "node_modules/@octokit/auth-oauth-app/dist-web/index.js"() {
    import_universal_user_agent5 = __toESM(require_dist_node());
    init_dist_web3();
    import_btoa_lite2 = __toESM(require_btoa_browser());
    init_dist_web7();
    import_btoa_lite3 = __toESM(require_btoa_browser());
    init_dist_web7();
    init_dist_web7();
    VERSION9 = "7.0.1";
  }
});

// node_modules/universal-github-app-jwt/dist-web/index.bundled.js
var index_bundled_exports = {};
__export(index_bundled_exports, {
  githubAppJwt: () => o3
});
function t4(t5, n3, r3, e5, i4, a3, o4) {
  try {
    var u4 = t5[a3](o4), c2 = u4.value;
  } catch (t6) {
    return void r3(t6);
  }
  u4.done ? n3(c2) : Promise.resolve(c2).then(e5, i4);
}
function n2(n3) {
  return function() {
    var r3 = this, e5 = arguments;
    return new Promise(function(i4, a3) {
      var o4 = n3.apply(r3, e5);
      function u4(n4) {
        t4(o4, i4, a3, u4, c2, "next", n4);
      }
      function c2(n4) {
        t4(o4, i4, a3, u4, c2, "throw", n4);
      }
      u4(void 0);
    });
  };
}
function r2(t5) {
  for (var n3 = new ArrayBuffer(t5.length), r3 = new Uint8Array(n3), e5 = 0, i4 = t5.length; e5 < i4; e5++)
    r3[e5] = t5.charCodeAt(e5);
  return n3;
}
function e4(t5) {
  return t5.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function i3(t5) {
  return e4(btoa(JSON.stringify(t5)));
}
function o3(t5) {
  return u3.apply(this, arguments);
}
function u3() {
  return (u3 = n2(function* (t5) {
    var { id: n3, privateKey: r3, now: e5 = Math.floor(Date.now() / 1e3) } = t5, i4 = e5 - 30, o4 = i4 + 600, u4 = { iat: i4, exp: o4, iss: n3 };
    return { appId: n3, expiration: o4, token: yield a2({ privateKey: r3, payload: u4 }) };
  })).apply(this, arguments);
}
var a2;
var init_index_bundled = __esm({
  "node_modules/universal-github-app-jwt/dist-web/index.bundled.js"() {
    a2 = function() {
      var t5 = n2(function* (t6) {
        var { privateKey: n3, payload: a3 } = t6;
        if (/BEGIN RSA PRIVATE KEY/.test(n3))
          throw new Error("[universal-github-app-jwt] Private Key is in PKCS#1 format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#readme");
        var o4, u4 = { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, c2 = (o4 = n3.trim().split("\n").slice(1, -1).join(""), r2(atob(o4))), p2 = yield crypto.subtle.importKey("pkcs8", c2, u4, false, ["sign"]), f3 = function(t7, n4) {
          return "".concat(i3(t7), ".").concat(i3(n4));
        }({ alg: "RS256", typ: "JWT" }, a3), l3 = r2(f3), s2 = function(t7) {
          for (var n4 = "", r3 = new Uint8Array(t7), i4 = r3.byteLength, a4 = 0; a4 < i4; a4++)
            n4 += String.fromCharCode(r3[a4]);
          return e4(btoa(n4));
        }(yield crypto.subtle.sign(u4.name, p2, l3));
        return "".concat(f3, ".").concat(s2);
      });
      return function(n3) {
        return t5.apply(this, arguments);
      };
    }();
  }
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    var _a3;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        constructor() {
          __publicField(this, "onabort");
          __publicField(this, "_onabort", []);
          __publicField(this, "reason");
          __publicField(this, "aborted", false);
        }
        addEventListener(_2, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          __publicField(this, "signal", new AS());
          warnACPolyfill();
        }
        abort(reason) {
          var _a4, _b;
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          (_b = (_a4 = this.signal).onabort) == null ? void 0 : _b.call(_a4, reason);
        }
      };
      let printACPolyfillWarning = ((_a3 = PROCESS.env) == null ? void 0 : _a3.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n3) => n3 && n3 === Math.floor(n3) && n3 > 0 && isFinite(n3);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var _constructing;
    var _Stack = class _Stack {
      constructor(max, HeapCls) {
        __publicField(this, "heap");
        __publicField(this, "length");
        if (!__privateGet(_Stack, _constructing)) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        __privateSet(_Stack, _constructing, true);
        const s2 = new _Stack(max, HeapCls);
        __privateSet(_Stack, _constructing, false);
        return s2;
      }
      push(n3) {
        this.heap[this.length++] = n3;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    _constructing = new WeakMap();
    // private constructor
    __privateAdd(_Stack, _constructing, false);
    var Stack = _Stack;
    var _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _initializeTTLTracking, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, _initializeSizeTracking, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, _indexes, indexes_fn, _rindexes, rindexes_fn, _isValidIndex, isValidIndex_fn, _evict, evict_fn, _backgroundFetch, backgroundFetch_fn, _isBackgroundFetch, isBackgroundFetch_fn, _connect, connect_fn, _moveToTail, moveToTail_fn;
    var _LRUCache = class _LRUCache {
      constructor(options) {
        __privateAdd(this, _initializeTTLTracking);
        __privateAdd(this, _initializeSizeTracking);
        __privateAdd(this, _indexes);
        __privateAdd(this, _rindexes);
        __privateAdd(this, _isValidIndex);
        __privateAdd(this, _evict);
        __privateAdd(this, _backgroundFetch);
        __privateAdd(this, _isBackgroundFetch);
        __privateAdd(this, _connect);
        __privateAdd(this, _moveToTail);
        // properties coming in from the options of these, only max and maxSize
        // really *need* to be protected. The rest can be modified, as they just
        // set defaults for various methods.
        __privateAdd(this, _max, void 0);
        __privateAdd(this, _maxSize, void 0);
        __privateAdd(this, _dispose, void 0);
        __privateAdd(this, _disposeAfter, void 0);
        __privateAdd(this, _fetchMethod, void 0);
        /**
         * {@link LRUCache.OptionsBase.ttl}
         */
        __publicField(this, "ttl");
        /**
         * {@link LRUCache.OptionsBase.ttlResolution}
         */
        __publicField(this, "ttlResolution");
        /**
         * {@link LRUCache.OptionsBase.ttlAutopurge}
         */
        __publicField(this, "ttlAutopurge");
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnGet}
         */
        __publicField(this, "updateAgeOnGet");
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnHas}
         */
        __publicField(this, "updateAgeOnHas");
        /**
         * {@link LRUCache.OptionsBase.allowStale}
         */
        __publicField(this, "allowStale");
        /**
         * {@link LRUCache.OptionsBase.noDisposeOnSet}
         */
        __publicField(this, "noDisposeOnSet");
        /**
         * {@link LRUCache.OptionsBase.noUpdateTTL}
         */
        __publicField(this, "noUpdateTTL");
        /**
         * {@link LRUCache.OptionsBase.maxEntrySize}
         */
        __publicField(this, "maxEntrySize");
        /**
         * {@link LRUCache.OptionsBase.sizeCalculation}
         */
        __publicField(this, "sizeCalculation");
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
         */
        __publicField(this, "noDeleteOnFetchRejection");
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
         */
        __publicField(this, "noDeleteOnStaleGet");
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
         */
        __publicField(this, "allowStaleOnFetchAbort");
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
         */
        __publicField(this, "allowStaleOnFetchRejection");
        /**
         * {@link LRUCache.OptionsBase.ignoreFetchAbort}
         */
        __publicField(this, "ignoreFetchAbort");
        // computed properties
        __privateAdd(this, _size, void 0);
        __privateAdd(this, _calculatedSize, void 0);
        __privateAdd(this, _keyMap, void 0);
        __privateAdd(this, _keyList, void 0);
        __privateAdd(this, _valList, void 0);
        __privateAdd(this, _next, void 0);
        __privateAdd(this, _prev, void 0);
        __privateAdd(this, _head, void 0);
        __privateAdd(this, _tail, void 0);
        __privateAdd(this, _free, void 0);
        __privateAdd(this, _disposed, void 0);
        __privateAdd(this, _sizes, void 0);
        __privateAdd(this, _starts, void 0);
        __privateAdd(this, _ttls, void 0);
        __privateAdd(this, _hasDispose, void 0);
        __privateAdd(this, _hasFetchMethod, void 0);
        __privateAdd(this, _hasDisposeAfter, void 0);
        // conditionally set private methods related to TTL
        __privateAdd(this, _updateItemAge, () => {
        });
        __privateAdd(this, _statusTTL, () => {
        });
        __privateAdd(this, _setItemTTL, () => {
        });
        /* c8 ignore stop */
        __privateAdd(this, _isStale, () => false);
        __privateAdd(this, _removeItemSize, (_i) => {
        });
        __privateAdd(this, _addItemSize, (_i, _s, _st) => {
        });
        __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
          if (size || sizeCalculation) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          return 0;
        });
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        __privateSet(this, _max, max);
        __privateSet(this, _maxSize, maxSize);
        this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        __privateSet(this, _fetchMethod, fetchMethod);
        __privateSet(this, _hasFetchMethod, !!fetchMethod);
        __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
        __privateSet(this, _keyList, new Array(max).fill(void 0));
        __privateSet(this, _valList, new Array(max).fill(void 0));
        __privateSet(this, _next, new UintArray(max));
        __privateSet(this, _prev, new UintArray(max));
        __privateSet(this, _head, 0);
        __privateSet(this, _tail, 0);
        __privateSet(this, _free, Stack.create(max));
        __privateSet(this, _size, 0);
        __privateSet(this, _calculatedSize, 0);
        if (typeof dispose === "function") {
          __privateSet(this, _dispose, dispose);
        }
        if (typeof disposeAfter === "function") {
          __privateSet(this, _disposeAfter, disposeAfter);
          __privateSet(this, _disposed, []);
        } else {
          __privateSet(this, _disposeAfter, void 0);
          __privateSet(this, _disposed, void 0);
        }
        __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
        __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (__privateGet(this, _maxSize) !== 0) {
            if (!isPosInt(__privateGet(this, _maxSize))) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          __privateMethod(this, _initializeSizeTracking, initializeSizeTracking_fn).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c2) {
        return {
          // properties
          starts: __privateGet(c2, _starts),
          ttls: __privateGet(c2, _ttls),
          sizes: __privateGet(c2, _sizes),
          keyMap: __privateGet(c2, _keyMap),
          keyList: __privateGet(c2, _keyList),
          valList: __privateGet(c2, _valList),
          next: __privateGet(c2, _next),
          prev: __privateGet(c2, _prev),
          get head() {
            return __privateGet(c2, _head);
          },
          get tail() {
            return __privateGet(c2, _tail);
          },
          free: __privateGet(c2, _free),
          // methods
          isBackgroundFetch: (p2) => {
            var _a4;
            return __privateMethod(_a4 = c2, _isBackgroundFetch, isBackgroundFetch_fn).call(_a4, p2);
          },
          backgroundFetch: (k2, index2, options, context) => {
            var _a4;
            return __privateMethod(_a4 = c2, _backgroundFetch, backgroundFetch_fn).call(_a4, k2, index2, options, context);
          },
          moveToTail: (index2) => {
            var _a4;
            return __privateMethod(_a4 = c2, _moveToTail, moveToTail_fn).call(_a4, index2);
          },
          indexes: (options) => {
            var _a4;
            return __privateMethod(_a4 = c2, _indexes, indexes_fn).call(_a4, options);
          },
          rindexes: (options) => {
            var _a4;
            return __privateMethod(_a4 = c2, _rindexes, rindexes_fn).call(_a4, options);
          },
          isStale: (index2) => {
            var _a4;
            return __privateGet(_a4 = c2, _isStale).call(_a4, index2);
          }
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return __privateGet(this, _max);
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return __privateGet(this, _maxSize);
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return __privateGet(this, _calculatedSize);
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return __privateGet(this, _size);
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return __privateGet(this, _fetchMethod);
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return __privateGet(this, _dispose);
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return __privateGet(this, _disposeAfter);
      }
      /**
       * Return the remaining TTL time for a given entry key
       */
      getRemainingTTL(key2) {
        return __privateGet(this, _keyMap).has(key2) ? Infinity : 0;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i4] !== void 0 && __privateGet(this, _keyList)[i4] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
            yield [__privateGet(this, _keyList)[i4], __privateGet(this, _valList)[i4]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i4] !== void 0 && __privateGet(this, _keyList)[i4] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
            yield [__privateGet(this, _keyList)[i4], __privateGet(this, _valList)[i4]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const k2 = __privateGet(this, _keyList)[i4];
          if (k2 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
            yield k2;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const k2 = __privateGet(this, _keyList)[i4];
          if (k2 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
            yield k2;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v2 = __privateGet(this, _valList)[i4];
          if (v2 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
            yield __privateGet(this, _valList)[i4];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const v2 = __privateGet(this, _valList)[i4];
          if (v2 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
            yield __privateGet(this, _valList)[i4];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to Array.find().  fn is called as fn(value, key, cache).
       */
      find(fn, getOptions = {}) {
        for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v2 = __privateGet(this, _valList)[i4];
          const value2 = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
          if (value2 === void 0)
            continue;
          if (fn(value2, __privateGet(this, _keyList)[i4], this)) {
            return this.get(__privateGet(this, _keyList)[i4], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from
       * most recently used to least recently used.  fn is called as
       * fn(value, key, cache).  Does not update age or recenty of use.
       * Does not iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v2 = __privateGet(this, _valList)[i4];
          const value2 = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
          if (value2 === void 0)
            continue;
          fn.call(thisp, value2, __privateGet(this, _keyList)[i4], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const v2 = __privateGet(this, _valList)[i4];
          const value2 = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
          if (value2 === void 0)
            continue;
          fn.call(thisp, value2, __privateGet(this, _keyList)[i4], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
          if (__privateGet(this, _isStale).call(this, i4)) {
            this.delete(__privateGet(this, _keyList)[i4]);
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
       * single key. Always returns stale values, if their info is found in the
       * cache, so be sure to check for expired TTLs if relevant.
       */
      info(key2) {
        const i4 = __privateGet(this, _keyMap).get(key2);
        if (i4 === void 0)
          return void 0;
        const v2 = __privateGet(this, _valList)[i4];
        const value2 = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
        if (value2 === void 0)
          return void 0;
        const entry = { value: value2 };
        if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
          const ttl = __privateGet(this, _ttls)[i4];
          const start = __privateGet(this, _starts)[i4];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (__privateGet(this, _sizes)) {
          entry.size = __privateGet(this, _sizes)[i4];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to cache.load()
       */
      dump() {
        const arr = [];
        for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this, { allowStale: true })) {
          const key2 = __privateGet(this, _keyList)[i4];
          const v2 = __privateGet(this, _valList)[i4];
          const value2 = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
          if (value2 === void 0 || key2 === void 0)
            continue;
          const entry = { value: value2 };
          if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
            entry.ttl = __privateGet(this, _ttls)[i4];
            const age = perf.now() - __privateGet(this, _starts)[i4];
            entry.start = Math.floor(Date.now() - age);
          }
          if (__privateGet(this, _sizes)) {
            entry.size = __privateGet(this, _sizes)[i4];
          }
          arr.unshift([key2, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       * Note that the shape of the resulting cache may be different if the
       * same options are not used in both caches.
       */
      load(arr) {
        this.clear();
        for (const [key2, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key2, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       */
      set(k2, v2, setOptions = {}) {
        var _a4, _b, _c, _d, _e;
        if (v2 === void 0) {
          this.delete(k2);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = __privateGet(this, _requireSize).call(this, k2, v2, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k2);
          return this;
        }
        let index2 = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k2);
        if (index2 === void 0) {
          index2 = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _evict, evict_fn).call(this, false) : __privateGet(this, _size);
          __privateGet(this, _keyList)[index2] = k2;
          __privateGet(this, _valList)[index2] = v2;
          __privateGet(this, _keyMap).set(k2, index2);
          __privateGet(this, _next)[__privateGet(this, _tail)] = index2;
          __privateGet(this, _prev)[index2] = __privateGet(this, _tail);
          __privateSet(this, _tail, index2);
          __privateWrapper(this, _size)._++;
          __privateGet(this, _addItemSize).call(this, index2, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
          const oldVal = __privateGet(this, _valList)[index2];
          if (v2 !== oldVal) {
            if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s2 } = oldVal;
              if (s2 !== void 0 && !noDisposeOnSet) {
                if (__privateGet(this, _hasDispose)) {
                  (_a4 = __privateGet(this, _dispose)) == null ? void 0 : _a4.call(this, s2, k2, "set");
                }
                if (__privateGet(this, _hasDisposeAfter)) {
                  (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([s2, k2, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (__privateGet(this, _hasDispose)) {
                (_c = __privateGet(this, _dispose)) == null ? void 0 : _c.call(this, oldVal, k2, "set");
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                (_d = __privateGet(this, _disposed)) == null ? void 0 : _d.push([oldVal, k2, "set"]);
              }
            }
            __privateGet(this, _removeItemSize).call(this, index2);
            __privateGet(this, _addItemSize).call(this, index2, size, status);
            __privateGet(this, _valList)[index2] = v2;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !__privateGet(this, _ttls)) {
          __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _ttls)) {
          if (!noUpdateTTL) {
            __privateGet(this, _setItemTTL).call(this, index2, ttl, start);
          }
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index2);
        }
        if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt == null ? void 0 : dt.shift()) {
            (_e = __privateGet(this, _disposeAfter)) == null ? void 0 : _e.call(this, ...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        var _a4;
        try {
          while (__privateGet(this, _size)) {
            const val2 = __privateGet(this, _valList)[__privateGet(this, _head)];
            __privateMethod(this, _evict, evict_fn).call(this, true);
            if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, val2)) {
              if (val2.__staleWhileFetching) {
                return val2.__staleWhileFetching;
              }
            } else if (val2 !== void 0) {
              return val2;
            }
          }
        } finally {
          if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
            const dt = __privateGet(this, _disposed);
            let task;
            while (task = dt == null ? void 0 : dt.shift()) {
              (_a4 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a4.call(this, ...task);
            }
          }
        }
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k2, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index2 = __privateGet(this, _keyMap).get(k2);
        if (index2 !== void 0) {
          const v2 = __privateGet(this, _valList)[index2];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) && v2.__staleWhileFetching === void 0) {
            return false;
          }
          if (!__privateGet(this, _isStale).call(this, index2)) {
            if (updateAgeOnHas) {
              __privateGet(this, _updateItemAge).call(this, index2);
            }
            if (status) {
              status.has = "hit";
              __privateGet(this, _statusTTL).call(this, status, index2);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            __privateGet(this, _statusTTL).call(this, status, index2);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k2, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index2 = __privateGet(this, _keyMap).get(k2);
        if (index2 === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index2)) {
          return;
        }
        const v2 = __privateGet(this, _valList)[index2];
        return __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      }
      async fetch(k2, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!__privateGet(this, _hasFetchMethod)) {
          if (status)
            status.fetch = "get";
          return this.get(k2, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index2 = __privateGet(this, _keyMap).get(k2);
        if (index2 === void 0) {
          if (status)
            status.fetch = "miss";
          const p2 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k2, index2, options, context);
          return p2.__returned = p2;
        } else {
          const v2 = __privateGet(this, _valList)[index2];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
            const stale = allowStale && v2.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v2.__staleWhileFetching : v2.__returned = v2;
          }
          const isStale = __privateGet(this, _isStale).call(this, index2);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index2);
            }
            if (status)
              __privateGet(this, _statusTTL).call(this, status, index2);
            return v2;
          }
          const p2 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k2, index2, options, context);
          const hasStale = p2.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
        }
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k2, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index2 = __privateGet(this, _keyMap).get(k2);
        if (index2 !== void 0) {
          const value2 = __privateGet(this, _valList)[index2];
          const fetching = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, value2);
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index2);
          if (__privateGet(this, _isStale).call(this, index2)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k2);
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value2 : void 0;
            } else {
              if (status && allowStale && value2.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value2.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value2.__staleWhileFetching;
            }
            __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index2);
            }
            return value2;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      /**
       * Deletes a key out of the cache.
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k2) {
        var _a4, _b, _c, _d;
        let deleted = false;
        if (__privateGet(this, _size) !== 0) {
          const index2 = __privateGet(this, _keyMap).get(k2);
          if (index2 !== void 0) {
            deleted = true;
            if (__privateGet(this, _size) === 1) {
              this.clear();
            } else {
              __privateGet(this, _removeItemSize).call(this, index2);
              const v2 = __privateGet(this, _valList)[index2];
              if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
                v2.__abortController.abort(new Error("deleted"));
              } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
                if (__privateGet(this, _hasDispose)) {
                  (_a4 = __privateGet(this, _dispose)) == null ? void 0 : _a4.call(this, v2, k2, "delete");
                }
                if (__privateGet(this, _hasDisposeAfter)) {
                  (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v2, k2, "delete"]);
                }
              }
              __privateGet(this, _keyMap).delete(k2);
              __privateGet(this, _keyList)[index2] = void 0;
              __privateGet(this, _valList)[index2] = void 0;
              if (index2 === __privateGet(this, _tail)) {
                __privateSet(this, _tail, __privateGet(this, _prev)[index2]);
              } else if (index2 === __privateGet(this, _head)) {
                __privateSet(this, _head, __privateGet(this, _next)[index2]);
              } else {
                const pi = __privateGet(this, _prev)[index2];
                __privateGet(this, _next)[pi] = __privateGet(this, _next)[index2];
                const ni = __privateGet(this, _next)[index2];
                __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index2];
              }
              __privateWrapper(this, _size)._--;
              __privateGet(this, _free).push(index2);
            }
          }
        }
        if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) == null ? void 0 : _c.length)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt == null ? void 0 : dt.shift()) {
            (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        var _a4, _b, _c;
        for (const index2 of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
          const v2 = __privateGet(this, _valList)[index2];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else {
            const k2 = __privateGet(this, _keyList)[index2];
            if (__privateGet(this, _hasDispose)) {
              (_a4 = __privateGet(this, _dispose)) == null ? void 0 : _a4.call(this, v2, k2, "delete");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v2, k2, "delete"]);
            }
          }
        }
        __privateGet(this, _keyMap).clear();
        __privateGet(this, _valList).fill(void 0);
        __privateGet(this, _keyList).fill(void 0);
        if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
          __privateGet(this, _ttls).fill(0);
          __privateGet(this, _starts).fill(0);
        }
        if (__privateGet(this, _sizes)) {
          __privateGet(this, _sizes).fill(0);
        }
        __privateSet(this, _head, 0);
        __privateSet(this, _tail, 0);
        __privateGet(this, _free).length = 0;
        __privateSet(this, _calculatedSize, 0);
        __privateSet(this, _size, 0);
        if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt == null ? void 0 : dt.shift()) {
            (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
          }
        }
      }
    };
    _max = new WeakMap();
    _maxSize = new WeakMap();
    _dispose = new WeakMap();
    _disposeAfter = new WeakMap();
    _fetchMethod = new WeakMap();
    _size = new WeakMap();
    _calculatedSize = new WeakMap();
    _keyMap = new WeakMap();
    _keyList = new WeakMap();
    _valList = new WeakMap();
    _next = new WeakMap();
    _prev = new WeakMap();
    _head = new WeakMap();
    _tail = new WeakMap();
    _free = new WeakMap();
    _disposed = new WeakMap();
    _sizes = new WeakMap();
    _starts = new WeakMap();
    _ttls = new WeakMap();
    _hasDispose = new WeakMap();
    _hasFetchMethod = new WeakMap();
    _hasDisposeAfter = new WeakMap();
    _initializeTTLTracking = new WeakSet();
    initializeTTLTracking_fn = function() {
      const ttls = new ZeroArray(__privateGet(this, _max));
      const starts = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _ttls, ttls);
      __privateSet(this, _starts, starts);
      __privateSet(this, _setItemTTL, (index2, ttl, start = perf.now()) => {
        starts[index2] = ttl !== 0 ? start : 0;
        ttls[index2] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t5 = setTimeout(() => {
            if (__privateGet(this, _isStale).call(this, index2)) {
              this.delete(__privateGet(this, _keyList)[index2]);
            }
          }, ttl + 1);
          if (t5.unref) {
            t5.unref();
          }
        }
      });
      __privateSet(this, _updateItemAge, (index2) => {
        starts[index2] = ttls[index2] !== 0 ? perf.now() : 0;
      });
      __privateSet(this, _statusTTL, (status, index2) => {
        if (ttls[index2]) {
          const ttl = ttls[index2];
          const start = starts[index2];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      });
      let cachedNow = 0;
      const getNow = () => {
        const n3 = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n3;
          const t5 = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t5.unref) {
            t5.unref();
          }
        }
        return n3;
      };
      this.getRemainingTTL = (key2) => {
        const index2 = __privateGet(this, _keyMap).get(key2);
        if (index2 === void 0) {
          return 0;
        }
        const ttl = ttls[index2];
        const start = starts[index2];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      __privateSet(this, _isStale, (index2) => {
        const s2 = starts[index2];
        const t5 = ttls[index2];
        return !!t5 && !!s2 && (cachedNow || getNow()) - s2 > t5;
      });
    };
    _updateItemAge = new WeakMap();
    _statusTTL = new WeakMap();
    _setItemTTL = new WeakMap();
    _isStale = new WeakMap();
    _initializeSizeTracking = new WeakSet();
    initializeSizeTracking_fn = function() {
      const sizes = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _sizes, sizes);
      __privateSet(this, _removeItemSize, (index2) => {
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index2]);
        sizes[index2] = 0;
      });
      __privateSet(this, _requireSize, (k2, v2, size, sizeCalculation) => {
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v2, k2);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      });
      __privateSet(this, _addItemSize, (index2, size, status) => {
        sizes[index2] = size;
        if (__privateGet(this, _maxSize)) {
          const maxSize = __privateGet(this, _maxSize) - sizes[index2];
          while (__privateGet(this, _calculatedSize) > maxSize) {
            __privateMethod(this, _evict, evict_fn).call(this, true);
          }
        }
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index2]);
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = __privateGet(this, _calculatedSize);
        }
      });
    };
    _removeItemSize = new WeakMap();
    _addItemSize = new WeakMap();
    _requireSize = new WeakMap();
    _indexes = new WeakSet();
    indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i4 = __privateGet(this, _tail); true; ) {
          if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i4)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i4)) {
            yield i4;
          }
          if (i4 === __privateGet(this, _head)) {
            break;
          } else {
            i4 = __privateGet(this, _prev)[i4];
          }
        }
      }
    };
    _rindexes = new WeakSet();
    rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i4 = __privateGet(this, _head); true; ) {
          if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i4)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i4)) {
            yield i4;
          }
          if (i4 === __privateGet(this, _tail)) {
            break;
          } else {
            i4 = __privateGet(this, _next)[i4];
          }
        }
      }
    };
    _isValidIndex = new WeakSet();
    isValidIndex_fn = function(index2) {
      return index2 !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index2]) === index2;
    };
    _evict = new WeakSet();
    evict_fn = function(free) {
      var _a4, _b;
      const head = __privateGet(this, _head);
      const k2 = __privateGet(this, _keyList)[head];
      const v2 = __privateGet(this, _valList)[head];
      if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
        v2.__abortController.abort(new Error("evicted"));
      } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
        if (__privateGet(this, _hasDispose)) {
          (_a4 = __privateGet(this, _dispose)) == null ? void 0 : _a4.call(this, v2, k2, "evict");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v2, k2, "evict"]);
        }
      }
      __privateGet(this, _removeItemSize).call(this, head);
      if (free) {
        __privateGet(this, _keyList)[head] = void 0;
        __privateGet(this, _valList)[head] = void 0;
        __privateGet(this, _free).push(head);
      }
      if (__privateGet(this, _size) === 1) {
        __privateSet(this, _head, __privateSet(this, _tail, 0));
        __privateGet(this, _free).length = 0;
      } else {
        __privateSet(this, _head, __privateGet(this, _next)[head]);
      }
      __privateGet(this, _keyMap).delete(k2);
      __privateWrapper(this, _size)._--;
      return head;
    };
    _backgroundFetch = new WeakSet();
    backgroundFetch_fn = function(k2, index2, options, context) {
      const v2 = index2 === void 0 ? void 0 : __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
        return v2;
      }
      const ac = new AC();
      const { signal } = options;
      signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v3, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v3 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p2;
        if (__privateGet(this, _valList)[index2] === p2) {
          if (v3 === void 0) {
            if (bf2.__staleWhileFetching) {
              __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
            } else {
              this.delete(k2);
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k2, v3, fetchOpts.options);
          }
        }
        return v3;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p2;
        if (__privateGet(this, _valList)[index2] === p2) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            this.delete(k2);
          } else if (!allowStaleAborted) {
            __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        var _a4;
        const fmp = (_a4 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a4.call(this, k2, v2, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v3) => res(v3 === void 0 ? void 0 : v3), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v3) => cb(v3, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p2 = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p2, {
        __abortController: ac,
        __staleWhileFetching: v2,
        __returned: void 0
      });
      if (index2 === void 0) {
        this.set(k2, bf, { ...fetchOpts.options, status: void 0 });
        index2 = __privateGet(this, _keyMap).get(k2);
      } else {
        __privateGet(this, _valList)[index2] = bf;
      }
      return bf;
    };
    _isBackgroundFetch = new WeakSet();
    isBackgroundFetch_fn = function(p2) {
      if (!__privateGet(this, _hasFetchMethod))
        return false;
      const b2 = p2;
      return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
    };
    _connect = new WeakSet();
    connect_fn = function(p2, n3) {
      __privateGet(this, _prev)[n3] = p2;
      __privateGet(this, _next)[p2] = n3;
    };
    _moveToTail = new WeakSet();
    moveToTail_fn = function(index2) {
      if (index2 !== __privateGet(this, _tail)) {
        if (index2 === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index2]);
        } else {
          __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _prev)[index2], __privateGet(this, _next)[index2]);
        }
        __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _tail), index2);
        __privateSet(this, _tail, index2);
      }
    };
    var LRUCache = _LRUCache;
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/@octokit/auth-app/dist-node/index.js
var require_dist_node6 = __commonJS({
  "node_modules/@octokit/auth-app/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      createAppAuth: () => createAppAuth4,
      createOAuthUserAuth: () => import_auth_oauth_user22.createOAuthUserAuth
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_universal_user_agent6 = require_dist_node();
    var import_request4 = (init_dist_web3(), __toCommonJS(dist_web_exports2));
    var import_auth_oauth_app = (init_dist_web8(), __toCommonJS(dist_web_exports6));
    var import_deprecation2 = require_dist_node2();
    var OAuthAppAuth = __toESM2((init_dist_web8(), __toCommonJS(dist_web_exports6)));
    var import_universal_github_app_jwt = (init_index_bundled(), __toCommonJS(index_bundled_exports));
    async function getAppAuthentication({
      appId,
      privateKey,
      timeDifference
    }) {
      try {
        const appAuthentication = await (0, import_universal_github_app_jwt.githubAppJwt)({
          id: +appId,
          privateKey,
          now: timeDifference && Math.floor(Date.now() / 1e3) + timeDifference
        });
        return {
          type: "app",
          token: appAuthentication.token,
          appId: appAuthentication.appId,
          expiresAt: new Date(appAuthentication.expiration * 1e3).toISOString()
        };
      } catch (error) {
        if (privateKey === "-----BEGIN RSA PRIVATE KEY-----") {
          throw new Error(
            "The 'privateKey` option contains only the first line '-----BEGIN RSA PRIVATE KEY-----'. If you are setting it using a `.env` file, make sure it is set on a single line with newlines replaced by '\n'"
          );
        } else {
          throw error;
        }
      }
    }
    var import_lru_cache = require_commonjs();
    function getCache() {
      return new import_lru_cache.LRUCache({
        // cache max. 15000 tokens, that will use less than 10mb memory
        max: 15e3,
        // Cache for 1 minute less than GitHub expiry
        ttl: 1e3 * 60 * 59
      });
    }
    async function get2(cache, options) {
      const cacheKey = optionsToCacheKey(options);
      const result = await cache.get(cacheKey);
      if (!result) {
        return;
      }
      const [
        token,
        createdAt,
        expiresAt,
        repositorySelection,
        permissionsString,
        singleFileName
      ] = result.split("|");
      const permissions = options.permissions || permissionsString.split(/,/).reduce((permissions2, string) => {
        if (/!$/.test(string)) {
          permissions2[string.slice(0, -1)] = "write";
        } else {
          permissions2[string] = "read";
        }
        return permissions2;
      }, {});
      return {
        token,
        createdAt,
        expiresAt,
        permissions,
        repositoryIds: options.repositoryIds,
        repositoryNames: options.repositoryNames,
        singleFileName,
        repositorySelection
      };
    }
    async function set2(cache, options, data2) {
      const key2 = optionsToCacheKey(options);
      const permissionsString = options.permissions ? "" : Object.keys(data2.permissions).map(
        (name2) => `${name2}${data2.permissions[name2] === "write" ? "!" : ""}`
      ).join(",");
      const value2 = [
        data2.token,
        data2.createdAt,
        data2.expiresAt,
        data2.repositorySelection,
        permissionsString,
        data2.singleFileName
      ].join("|");
      await cache.set(key2, value2);
    }
    function optionsToCacheKey({
      installationId,
      permissions = {},
      repositoryIds = [],
      repositoryNames = []
    }) {
      const permissionsString = Object.keys(permissions).sort().map((name2) => permissions[name2] === "read" ? name2 : `${name2}!`).join(",");
      const repositoryIdsString = repositoryIds.sort().join(",");
      const repositoryNamesString = repositoryNames.join(",");
      return [
        installationId,
        repositoryIdsString,
        repositoryNamesString,
        permissionsString
      ].filter(Boolean).join("|");
    }
    function toTokenAuthentication({
      installationId,
      token,
      createdAt,
      expiresAt,
      repositorySelection,
      permissions,
      repositoryIds,
      repositoryNames,
      singleFileName
    }) {
      return Object.assign(
        {
          type: "token",
          tokenType: "installation",
          token,
          installationId,
          permissions,
          createdAt,
          expiresAt,
          repositorySelection
        },
        repositoryIds ? { repositoryIds } : null,
        repositoryNames ? { repositoryNames } : null,
        singleFileName ? { singleFileName } : null
      );
    }
    async function getInstallationAuthentication(state, options, customRequest) {
      const installationId = Number(options.installationId || state.installationId);
      if (!installationId) {
        throw new Error(
          "[@octokit/auth-app] installationId option is required for installation authentication."
        );
      }
      if (options.factory) {
        const { type, factory, oauthApp, ...factoryAuthOptions } = {
          ...state,
          ...options
        };
        return factory(factoryAuthOptions);
      }
      const optionsWithInstallationTokenFromState = Object.assign(
        { installationId },
        options
      );
      if (!options.refresh) {
        const result = await get2(
          state.cache,
          optionsWithInstallationTokenFromState
        );
        if (result) {
          const {
            token: token2,
            createdAt: createdAt2,
            expiresAt: expiresAt2,
            permissions: permissions2,
            repositoryIds: repositoryIds2,
            repositoryNames: repositoryNames2,
            singleFileName: singleFileName2,
            repositorySelection: repositorySelection2
          } = result;
          return toTokenAuthentication({
            installationId,
            token: token2,
            createdAt: createdAt2,
            expiresAt: expiresAt2,
            permissions: permissions2,
            repositorySelection: repositorySelection2,
            repositoryIds: repositoryIds2,
            repositoryNames: repositoryNames2,
            singleFileName: singleFileName2
          });
        }
      }
      const appAuthentication = await getAppAuthentication(state);
      const request2 = customRequest || state.request;
      const {
        data: {
          token,
          expires_at: expiresAt,
          repositories,
          permissions: permissionsOptional,
          repository_selection: repositorySelectionOptional,
          single_file: singleFileName
        }
      } = await request2("POST /app/installations/{installation_id}/access_tokens", {
        installation_id: installationId,
        repository_ids: options.repositoryIds,
        repositories: options.repositoryNames,
        permissions: options.permissions,
        mediaType: {
          previews: ["machine-man"]
        },
        headers: {
          authorization: `bearer ${appAuthentication.token}`
        }
      });
      const permissions = permissionsOptional || {};
      const repositorySelection = repositorySelectionOptional || "all";
      const repositoryIds = repositories ? repositories.map((r3) => r3.id) : void 0;
      const repositoryNames = repositories ? repositories.map((repo) => repo.name) : void 0;
      const createdAt = (/* @__PURE__ */ new Date()).toISOString();
      await set2(state.cache, optionsWithInstallationTokenFromState, {
        token,
        createdAt,
        expiresAt,
        repositorySelection,
        permissions,
        repositoryIds,
        repositoryNames,
        singleFileName
      });
      return toTokenAuthentication({
        installationId,
        token,
        createdAt,
        expiresAt,
        repositorySelection,
        permissions,
        repositoryIds,
        repositoryNames,
        singleFileName
      });
    }
    async function auth5(state, authOptions) {
      switch (authOptions.type) {
        case "app":
          return getAppAuthentication(state);
        case "oauth":
          state.log.warn(
            // @ts-expect-error `log.warn()` expects string
            new import_deprecation2.Deprecation(
              `[@octokit/auth-app] {type: "oauth"} is deprecated. Use {type: "oauth-app"} instead`
            )
          );
        case "oauth-app":
          return state.oauthApp({ type: "oauth-app" });
        case "installation":
          authOptions;
          return getInstallationAuthentication(state, {
            ...authOptions,
            type: "installation"
          });
        case "oauth-user":
          return state.oauthApp(authOptions);
        default:
          throw new Error(`Invalid auth type: ${authOptions.type}`);
      }
    }
    var import_auth_oauth_user4 = (init_dist_web7(), __toCommonJS(dist_web_exports5));
    var import_request_error3 = (init_dist_web2(), __toCommonJS(dist_web_exports));
    var PATHS = [
      "/app",
      "/app/hook/config",
      "/app/hook/deliveries",
      "/app/hook/deliveries/{delivery_id}",
      "/app/hook/deliveries/{delivery_id}/attempts",
      "/app/installations",
      "/app/installations/{installation_id}",
      "/app/installations/{installation_id}/access_tokens",
      "/app/installations/{installation_id}/suspended",
      "/marketplace_listing/accounts/{account_id}",
      "/marketplace_listing/plan",
      "/marketplace_listing/plans",
      "/marketplace_listing/plans/{plan_id}/accounts",
      "/marketplace_listing/stubbed/accounts/{account_id}",
      "/marketplace_listing/stubbed/plan",
      "/marketplace_listing/stubbed/plans",
      "/marketplace_listing/stubbed/plans/{plan_id}/accounts",
      "/orgs/{org}/installation",
      "/repos/{owner}/{repo}/installation",
      "/users/{username}/installation"
    ];
    function routeMatcher2(paths) {
      const regexes = paths.map(
        (p2) => p2.split("/").map((c2) => c2.startsWith("{") ? "(?:.+?)" : c2).join("/")
      );
      const regex2 = `^(?:${regexes.map((r3) => `(?:${r3})`).join("|")})$`;
      return new RegExp(regex2, "i");
    }
    var REGEX = routeMatcher2(PATHS);
    function requiresAppAuth(url) {
      return !!url && REGEX.test(url.split("?")[0]);
    }
    var FIVE_SECONDS_IN_MS = 5 * 1e3;
    function isNotTimeSkewError(error) {
      return !(error.message.match(
        /'Expiration time' claim \('exp'\) must be a numeric value representing the future time at which the assertion expires/
      ) || error.message.match(
        /'Issued at' claim \('iat'\) must be an Integer representing the time that the assertion was issued/
      ));
    }
    async function hook5(state, request2, route, parameters) {
      const endpoint2 = request2.endpoint.merge(route, parameters);
      const url = endpoint2.url;
      if (/\/login\/oauth\/access_token$/.test(url)) {
        return request2(endpoint2);
      }
      if (requiresAppAuth(url.replace(request2.endpoint.DEFAULTS.baseUrl, ""))) {
        const { token: token2 } = await getAppAuthentication(state);
        endpoint2.headers.authorization = `bearer ${token2}`;
        let response;
        try {
          response = await request2(endpoint2);
        } catch (error) {
          if (isNotTimeSkewError(error)) {
            throw error;
          }
          if (typeof error.response.headers.date === "undefined") {
            throw error;
          }
          const diff = Math.floor(
            (Date.parse(error.response.headers.date) - Date.parse((/* @__PURE__ */ new Date()).toString())) / 1e3
          );
          state.log.warn(error.message);
          state.log.warn(
            `[@octokit/auth-app] GitHub API time and system time are different by ${diff} seconds. Retrying request with the difference accounted for.`
          );
          const { token: token3 } = await getAppAuthentication({
            ...state,
            timeDifference: diff
          });
          endpoint2.headers.authorization = `bearer ${token3}`;
          return request2(endpoint2);
        }
        return response;
      }
      if ((0, import_auth_oauth_user4.requiresBasicAuth)(url)) {
        const authentication = await state.oauthApp({ type: "oauth-app" });
        endpoint2.headers.authorization = authentication.headers.authorization;
        return request2(endpoint2);
      }
      const { token, createdAt } = await getInstallationAuthentication(
        state,
        // @ts-expect-error TBD
        {},
        request2
      );
      endpoint2.headers.authorization = `token ${token}`;
      return sendRequestWithRetries(
        state,
        request2,
        endpoint2,
        createdAt
      );
    }
    async function sendRequestWithRetries(state, request2, options, createdAt, retries = 0) {
      const timeSinceTokenCreationInMs = +/* @__PURE__ */ new Date() - +new Date(createdAt);
      try {
        return await request2(options);
      } catch (error) {
        if (error.status !== 401) {
          throw error;
        }
        if (timeSinceTokenCreationInMs >= FIVE_SECONDS_IN_MS) {
          if (retries > 0) {
            error.message = `After ${retries} retries within ${timeSinceTokenCreationInMs / 1e3}s of creating the installation access token, the response remains 401. At this point, the cause may be an authentication problem or a system outage. Please check https://www.githubstatus.com for status information`;
          }
          throw error;
        }
        ++retries;
        const awaitTime = retries * 1e3;
        state.log.warn(
          `[@octokit/auth-app] Retrying after 401 response to account for token replication delay (retry: ${retries}, wait: ${awaitTime / 1e3}s)`
        );
        await new Promise((resolve) => setTimeout(resolve, awaitTime));
        return sendRequestWithRetries(state, request2, options, createdAt, retries);
      }
    }
    var VERSION12 = "6.0.3";
    var import_auth_oauth_user22 = (init_dist_web7(), __toCommonJS(dist_web_exports5));
    function createAppAuth4(options) {
      if (!options.appId) {
        throw new Error("[@octokit/auth-app] appId option is required");
      }
      if (!Number.isFinite(+options.appId)) {
        throw new Error(
          "[@octokit/auth-app] appId option must be a number or numeric string"
        );
      }
      if (!options.privateKey) {
        throw new Error("[@octokit/auth-app] privateKey option is required");
      }
      if ("installationId" in options && !options.installationId) {
        throw new Error(
          "[@octokit/auth-app] installationId is set to a falsy value"
        );
      }
      const log = Object.assign(
        {
          warn: console.warn.bind(console)
        },
        options.log
      );
      const request2 = options.request || import_request4.request.defaults({
        headers: {
          "user-agent": `octokit-auth-app.js/${VERSION12} ${(0, import_universal_user_agent6.getUserAgent)()}`
        }
      });
      const state = Object.assign(
        {
          request: request2,
          cache: getCache()
        },
        options,
        options.installationId ? { installationId: Number(options.installationId) } : {},
        {
          log,
          oauthApp: (0, import_auth_oauth_app.createOAuthAppAuth)({
            clientType: "github-app",
            clientId: options.clientId || "",
            clientSecret: options.clientSecret || "",
            request: request2
          })
        }
      );
      return Object.assign(auth5.bind(null, state), {
        hook: hook5.bind(null, state)
      });
    }
  }
});

// node_modules/@octokit/auth-unauthenticated/dist-node/index.js
var require_dist_node7 = __commonJS({
  "node_modules/@octokit/auth-unauthenticated/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      createUnauthenticatedAuth: () => createUnauthenticatedAuth2
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    async function auth5(reason) {
      return {
        type: "unauthenticated",
        reason
      };
    }
    var import_request_error3 = (init_dist_web2(), __toCommonJS(dist_web_exports));
    function isRateLimitError(error) {
      if (error.status !== 403) {
        return false;
      }
      if (!error.response) {
        return false;
      }
      return error.response.headers["x-ratelimit-remaining"] === "0";
    }
    var import_request_error22 = (init_dist_web2(), __toCommonJS(dist_web_exports));
    var REGEX_ABUSE_LIMIT_MESSAGE = /\babuse\b/i;
    function isAbuseLimitError(error) {
      if (error.status !== 403) {
        return false;
      }
      return REGEX_ABUSE_LIMIT_MESSAGE.test(error.message);
    }
    async function hook5(reason, request2, route, parameters) {
      const endpoint2 = request2.endpoint.merge(
        route,
        parameters
      );
      return request2(endpoint2).catch((error) => {
        if (error.status === 404) {
          error.message = `Not found. May be due to lack of authentication. Reason: ${reason}`;
          throw error;
        }
        if (isRateLimitError(error)) {
          error.message = `API rate limit exceeded. This maybe caused by the lack of authentication. Reason: ${reason}`;
          throw error;
        }
        if (isAbuseLimitError(error)) {
          error.message = `You have triggered an abuse detection mechanism. This maybe caused by the lack of authentication. Reason: ${reason}`;
          throw error;
        }
        if (error.status === 401) {
          error.message = `Unauthorized. "${endpoint2.method} ${endpoint2.url}" failed most likely due to lack of authentication. Reason: ${reason}`;
          throw error;
        }
        if (error.status >= 400 && error.status < 500) {
          error.message = error.message.replace(
            /\.?$/,
            `. May be caused by lack of authentication (${reason}).`
          );
        }
        throw error;
      });
    }
    var createUnauthenticatedAuth2 = function createUnauthenticatedAuth22(options) {
      if (!options || !options.reason) {
        throw new Error(
          "[@octokit/auth-unauthenticated] No reason passed to createUnauthenticatedAuth"
        );
      }
      return Object.assign(auth5.bind(null, options.reason), {
        hook: hook5.bind(null, options.reason)
      });
    };
  }
});

// node_modules/@octokit/oauth-app/dist-node/index.js
var require_dist_node8 = __commonJS({
  "node_modules/@octokit/oauth-app/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      OAuthApp: () => OAuthApp3,
      createAWSLambdaAPIGatewayV2Handler: () => createAWSLambdaAPIGatewayV2Handler,
      createNodeMiddleware: () => createNodeMiddleware,
      createWebWorkerHandler: () => createWebWorkerHandler,
      handleRequest: () => handleRequest,
      sendNodeResponse: () => sendResponse,
      unknownRouteResponse: () => unknownRouteResponse
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_auth_oauth_app = (init_dist_web8(), __toCommonJS(dist_web_exports6));
    var VERSION12 = "6.0.0";
    function addEventHandler(state, eventName, eventHandler) {
      if (Array.isArray(eventName)) {
        for (const singleEventName of eventName) {
          addEventHandler(state, singleEventName, eventHandler);
        }
        return;
      }
      if (!state.eventHandlers[eventName]) {
        state.eventHandlers[eventName] = [];
      }
      state.eventHandlers[eventName].push(eventHandler);
    }
    var import_core3 = require_dist_node4();
    var import_universal_user_agent6 = require_dist_node();
    var OAuthAppOctokit = import_core3.Octokit.defaults({
      userAgent: `octokit-oauth-app.js/${VERSION12} ${(0, import_universal_user_agent6.getUserAgent)()}`
    });
    var import_auth_oauth_user4 = (init_dist_web7(), __toCommonJS(dist_web_exports5));
    async function emitEvent(state, context) {
      const { name: name2, action } = context;
      if (state.eventHandlers[`${name2}.${action}`]) {
        for (const eventHandler of state.eventHandlers[`${name2}.${action}`]) {
          await eventHandler(context);
        }
      }
      if (state.eventHandlers[name2]) {
        for (const eventHandler of state.eventHandlers[name2]) {
          await eventHandler(context);
        }
      }
    }
    async function getUserOctokitWithState(state, options) {
      return state.octokit.auth({
        type: "oauth-user",
        ...options,
        async factory(options2) {
          const octokit = new state.Octokit({
            authStrategy: import_auth_oauth_user4.createOAuthUserAuth,
            auth: options2
          });
          const authentication = await octokit.auth({
            type: "get"
          });
          await emitEvent(state, {
            name: "token",
            action: "created",
            token: authentication.token,
            scopes: authentication.scopes,
            authentication,
            octokit
          });
          return octokit;
        }
      });
    }
    var OAuthMethods = __toESM2(require_dist_node5());
    function getWebFlowAuthorizationUrlWithState(state, options) {
      var _a4, _b, _c;
      const optionsWithDefaults = {
        clientId: state.clientId,
        request: state.octokit.request,
        ...options,
        allowSignup: (_a4 = state.allowSignup) != null ? _a4 : options.allowSignup,
        redirectUrl: (_b = options.redirectUrl) != null ? _b : state.redirectUrl,
        scopes: (_c = options.scopes) != null ? _c : state.defaultScopes
      };
      return OAuthMethods.getWebFlowAuthorizationUrl({
        clientType: state.clientType,
        ...optionsWithDefaults
      });
    }
    var OAuthAppAuth = __toESM2((init_dist_web8(), __toCommonJS(dist_web_exports6)));
    async function createTokenWithState(state, options) {
      const authentication = await state.octokit.auth({
        type: "oauth-user",
        ...options
      });
      await emitEvent(state, {
        name: "token",
        action: "created",
        token: authentication.token,
        scopes: authentication.scopes,
        authentication,
        octokit: new state.Octokit({
          authStrategy: OAuthAppAuth.createOAuthUserAuth,
          auth: {
            clientType: state.clientType,
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            token: authentication.token,
            scopes: authentication.scopes,
            refreshToken: authentication.refreshToken,
            expiresAt: authentication.expiresAt,
            refreshTokenExpiresAt: authentication.refreshTokenExpiresAt
          }
        })
      });
      return { authentication };
    }
    var OAuthMethods2 = __toESM2(require_dist_node5());
    async function checkTokenWithState(state, options) {
      const result = await OAuthMethods2.checkToken({
        // @ts-expect-error not worth the extra code to appease TS
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
      });
      Object.assign(result.authentication, { type: "token", tokenType: "oauth" });
      return result;
    }
    var OAuthMethods3 = __toESM2(require_dist_node5());
    var import_auth_oauth_user22 = (init_dist_web7(), __toCommonJS(dist_web_exports5));
    async function resetTokenWithState(state, options) {
      const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
      };
      if (state.clientType === "oauth-app") {
        const response2 = await OAuthMethods3.resetToken({
          clientType: "oauth-app",
          ...optionsWithDefaults
        });
        const authentication2 = Object.assign(response2.authentication, {
          type: "token",
          tokenType: "oauth"
        });
        await emitEvent(state, {
          name: "token",
          action: "reset",
          token: response2.authentication.token,
          scopes: response2.authentication.scopes || void 0,
          authentication: authentication2,
          octokit: new state.Octokit({
            authStrategy: import_auth_oauth_user22.createOAuthUserAuth,
            auth: {
              clientType: state.clientType,
              clientId: state.clientId,
              clientSecret: state.clientSecret,
              token: response2.authentication.token,
              scopes: response2.authentication.scopes
            }
          })
        });
        return { ...response2, authentication: authentication2 };
      }
      const response = await OAuthMethods3.resetToken({
        clientType: "github-app",
        ...optionsWithDefaults
      });
      const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
      });
      await emitEvent(state, {
        name: "token",
        action: "reset",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
          authStrategy: import_auth_oauth_user22.createOAuthUserAuth,
          auth: {
            clientType: state.clientType,
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            token: response.authentication.token
          }
        })
      });
      return { ...response, authentication };
    }
    var OAuthMethods4 = __toESM2(require_dist_node5());
    var import_auth_oauth_user32 = (init_dist_web7(), __toCommonJS(dist_web_exports5));
    async function refreshTokenWithState(state, options) {
      if (state.clientType === "oauth-app") {
        throw new Error(
          "[@octokit/oauth-app] app.refreshToken() is not supported for OAuth Apps"
        );
      }
      const response = await OAuthMethods4.refreshToken({
        clientType: "github-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        refreshToken: options.refreshToken
      });
      const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
      });
      await emitEvent(state, {
        name: "token",
        action: "refreshed",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
          authStrategy: import_auth_oauth_user32.createOAuthUserAuth,
          auth: {
            clientType: state.clientType,
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            token: response.authentication.token
          }
        })
      });
      return { ...response, authentication };
    }
    var OAuthMethods5 = __toESM2(require_dist_node5());
    var import_auth_oauth_user42 = (init_dist_web7(), __toCommonJS(dist_web_exports5));
    async function scopeTokenWithState(state, options) {
      if (state.clientType === "oauth-app") {
        throw new Error(
          "[@octokit/oauth-app] app.scopeToken() is not supported for OAuth Apps"
        );
      }
      const response = await OAuthMethods5.scopeToken({
        clientType: "github-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
      });
      const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
      });
      await emitEvent(state, {
        name: "token",
        action: "scoped",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
          authStrategy: import_auth_oauth_user42.createOAuthUserAuth,
          auth: {
            clientType: state.clientType,
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            token: response.authentication.token
          }
        })
      });
      return { ...response, authentication };
    }
    var OAuthMethods6 = __toESM2(require_dist_node5());
    var import_auth_unauthenticated2 = require_dist_node7();
    async function deleteTokenWithState(state, options) {
      const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
      };
      const response = state.clientType === "oauth-app" ? await OAuthMethods6.deleteToken({
        clientType: "oauth-app",
        ...optionsWithDefaults
      }) : (
        // istanbul ignore next
        await OAuthMethods6.deleteToken({
          clientType: "github-app",
          ...optionsWithDefaults
        })
      );
      await emitEvent(state, {
        name: "token",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
          authStrategy: import_auth_unauthenticated2.createUnauthenticatedAuth,
          auth: {
            reason: `Handling "token.deleted" event. The access for the token has been revoked.`
          }
        })
      });
      return response;
    }
    var OAuthMethods7 = __toESM2(require_dist_node5());
    var import_auth_unauthenticated22 = require_dist_node7();
    async function deleteAuthorizationWithState(state, options) {
      const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
      };
      const response = state.clientType === "oauth-app" ? await OAuthMethods7.deleteAuthorization({
        clientType: "oauth-app",
        ...optionsWithDefaults
      }) : (
        // istanbul ignore next
        await OAuthMethods7.deleteAuthorization({
          clientType: "github-app",
          ...optionsWithDefaults
        })
      );
      await emitEvent(state, {
        name: "token",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
          authStrategy: import_auth_unauthenticated22.createUnauthenticatedAuth,
          auth: {
            reason: `Handling "token.deleted" event. The access for the token has been revoked.`
          }
        })
      });
      await emitEvent(state, {
        name: "authorization",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
          authStrategy: import_auth_unauthenticated22.createUnauthenticatedAuth,
          auth: {
            reason: `Handling "authorization.deleted" event. The access for the app has been revoked.`
          }
        })
      });
      return response;
    }
    function unknownRouteResponse(request2) {
      return {
        status: 404,
        headers: { "content-type": "application/json" },
        text: JSON.stringify({
          error: `Unknown route: ${request2.method} ${request2.url}`
        })
      };
    }
    async function handleRequest(app, { pathPrefix = "/api/github/oauth" }, request2) {
      var _a4, _b, _c, _d, _e, _f;
      if (request2.method === "OPTIONS") {
        return {
          status: 200,
          headers: {
            "access-control-allow-origin": "*",
            "access-control-allow-methods": "*",
            "access-control-allow-headers": "Content-Type, User-Agent, Authorization"
          }
        };
      }
      let { pathname } = new URL(request2.url, "http://localhost");
      if (!pathname.startsWith(`${pathPrefix}/`)) {
        return void 0;
      }
      pathname = pathname.slice(pathPrefix.length + 1);
      const route = [request2.method, pathname].join(" ");
      const routes = {
        getLogin: `GET login`,
        getCallback: `GET callback`,
        createToken: `POST token`,
        getToken: `GET token`,
        patchToken: `PATCH token`,
        patchRefreshToken: `PATCH refresh-token`,
        scopeToken: `POST token/scoped`,
        deleteToken: `DELETE token`,
        deleteGrant: `DELETE grant`
      };
      if (!Object.values(routes).includes(route)) {
        return unknownRouteResponse(request2);
      }
      let json;
      try {
        const text2 = await request2.text();
        json = text2 ? JSON.parse(text2) : {};
      } catch (error) {
        return {
          status: 400,
          headers: {
            "content-type": "application/json",
            "access-control-allow-origin": "*"
          },
          text: JSON.stringify({
            error: "[@octokit/oauth-app] request error"
          })
        };
      }
      const { searchParams } = new URL(request2.url, "http://localhost");
      const query = Object.fromEntries(searchParams);
      const headers = request2.headers;
      try {
        if (route === routes.getLogin) {
          const { url } = app.getWebFlowAuthorizationUrl({
            state: query.state,
            scopes: query.scopes ? query.scopes.split(",") : void 0,
            allowSignup: query.allowSignup ? query.allowSignup === "true" : void 0,
            redirectUrl: query.redirectUrl
          });
          return { status: 302, headers: { location: url } };
        }
        if (route === routes.getCallback) {
          if (query.error) {
            throw new Error(
              `[@octokit/oauth-app] ${query.error} ${query.error_description}`
            );
          }
          if (!query.code) {
            throw new Error('[@octokit/oauth-app] "code" parameter is required');
          }
          const {
            authentication: { token: token2 }
          } = await app.createToken({
            code: query.code
          });
          return {
            status: 200,
            headers: {
              "content-type": "text/html"
            },
            text: `<h1>Token created successfully</h1>

<p>Your token is: <strong>${token2}</strong>. Copy it now as it cannot be shown again.</p>`
          };
        }
        if (route === routes.createToken) {
          const { code, redirectUrl } = json;
          if (!code) {
            throw new Error('[@octokit/oauth-app] "code" parameter is required');
          }
          const result = await app.createToken({
            code,
            redirectUrl
          });
          delete result.authentication.clientSecret;
          return {
            status: 201,
            headers: {
              "content-type": "application/json",
              "access-control-allow-origin": "*"
            },
            text: JSON.stringify(result)
          };
        }
        if (route === routes.getToken) {
          const token2 = (_a4 = headers.authorization) == null ? void 0 : _a4.substr("token ".length);
          if (!token2) {
            throw new Error(
              '[@octokit/oauth-app] "Authorization" header is required'
            );
          }
          const result = await app.checkToken({
            token: token2
          });
          delete result.authentication.clientSecret;
          return {
            status: 200,
            headers: {
              "content-type": "application/json",
              "access-control-allow-origin": "*"
            },
            text: JSON.stringify(result)
          };
        }
        if (route === routes.patchToken) {
          const token2 = (_b = headers.authorization) == null ? void 0 : _b.substr("token ".length);
          if (!token2) {
            throw new Error(
              '[@octokit/oauth-app] "Authorization" header is required'
            );
          }
          const result = await app.resetToken({ token: token2 });
          delete result.authentication.clientSecret;
          return {
            status: 200,
            headers: {
              "content-type": "application/json",
              "access-control-allow-origin": "*"
            },
            text: JSON.stringify(result)
          };
        }
        if (route === routes.patchRefreshToken) {
          const token2 = (_c = headers.authorization) == null ? void 0 : _c.substr("token ".length);
          if (!token2) {
            throw new Error(
              '[@octokit/oauth-app] "Authorization" header is required'
            );
          }
          const { refreshToken: refreshToken2 } = json;
          if (!refreshToken2) {
            throw new Error(
              "[@octokit/oauth-app] refreshToken must be sent in request body"
            );
          }
          const result = await app.refreshToken({ refreshToken: refreshToken2 });
          delete result.authentication.clientSecret;
          return {
            status: 200,
            headers: {
              "content-type": "application/json",
              "access-control-allow-origin": "*"
            },
            text: JSON.stringify(result)
          };
        }
        if (route === routes.scopeToken) {
          const token2 = (_d = headers.authorization) == null ? void 0 : _d.substr("token ".length);
          if (!token2) {
            throw new Error(
              '[@octokit/oauth-app] "Authorization" header is required'
            );
          }
          const result = await app.scopeToken({
            token: token2,
            ...json
          });
          delete result.authentication.clientSecret;
          return {
            status: 200,
            headers: {
              "content-type": "application/json",
              "access-control-allow-origin": "*"
            },
            text: JSON.stringify(result)
          };
        }
        if (route === routes.deleteToken) {
          const token2 = (_e = headers.authorization) == null ? void 0 : _e.substr("token ".length);
          if (!token2) {
            throw new Error(
              '[@octokit/oauth-app] "Authorization" header is required'
            );
          }
          await app.deleteToken({
            token: token2
          });
          return {
            status: 204,
            headers: { "access-control-allow-origin": "*" }
          };
        }
        const token = (_f = headers.authorization) == null ? void 0 : _f.substr("token ".length);
        if (!token) {
          throw new Error(
            '[@octokit/oauth-app] "Authorization" header is required'
          );
        }
        await app.deleteAuthorization({
          token
        });
        return {
          status: 204,
          headers: { "access-control-allow-origin": "*" }
        };
      } catch (error) {
        return {
          status: 400,
          headers: {
            "content-type": "application/json",
            "access-control-allow-origin": "*"
          },
          text: JSON.stringify({ error: error.message })
        };
      }
    }
    function parseRequest(request2) {
      const { method, url, headers } = request2;
      async function text2() {
        const text22 = await new Promise((resolve, reject) => {
          let bodyChunks = [];
          request2.on("error", reject).on("data", (chunk) => bodyChunks.push(chunk)).on("end", () => resolve(Buffer.concat(bodyChunks).toString()));
        });
        return text22;
      }
      return { method, url, headers, text: text2 };
    }
    function sendResponse(octokitResponse, response) {
      response.writeHead(octokitResponse.status, octokitResponse.headers);
      response.end(octokitResponse.text);
    }
    function createNodeMiddleware(app, options = {}) {
      return async function(request2, response, next) {
        const octokitRequest = await parseRequest(request2);
        const octokitResponse = await handleRequest(app, options, octokitRequest);
        if (octokitResponse) {
          sendResponse(octokitResponse, response);
          return true;
        } else {
          next == null ? void 0 : next();
          return false;
        }
      };
    }
    function parseRequest2(request2) {
      const headers = Object.fromEntries(request2.headers.entries());
      return {
        method: request2.method,
        url: request2.url,
        headers,
        text: () => request2.text()
      };
    }
    function sendResponse2(octokitResponse) {
      return new Response(octokitResponse.text, {
        status: octokitResponse.status,
        headers: octokitResponse.headers
      });
    }
    function createWebWorkerHandler(app, options = {}) {
      return async function(request2) {
        const octokitRequest = await parseRequest2(request2);
        const octokitResponse = await handleRequest(app, options, octokitRequest);
        return octokitResponse ? sendResponse2(octokitResponse) : void 0;
      };
    }
    function parseRequest3(request2) {
      const { method } = request2.requestContext.http;
      let url = request2.rawPath;
      const { stage } = request2.requestContext;
      if (url.startsWith("/" + stage))
        url = url.substring(stage.length + 1);
      if (request2.rawQueryString)
        url += "?" + request2.rawQueryString;
      const headers = request2.headers;
      const text2 = async () => request2.body || "";
      return { method, url, headers, text: text2 };
    }
    function sendResponse3(octokitResponse) {
      return {
        statusCode: octokitResponse.status,
        headers: octokitResponse.headers,
        body: octokitResponse.text
      };
    }
    function createAWSLambdaAPIGatewayV2Handler(app, options = {}) {
      return async function(event) {
        const request2 = parseRequest3(event);
        const response = await handleRequest(app, options, request2);
        return response ? sendResponse3(response) : void 0;
      };
    }
    var _a3;
    var OAuthApp3 = (_a3 = class {
      static defaults(defaults) {
        const OAuthAppWithDefaults = class extends this {
          constructor(...args) {
            super({
              ...defaults,
              ...args[0]
            });
          }
        };
        return OAuthAppWithDefaults;
      }
      constructor(options) {
        const Octokit2 = options.Octokit || OAuthAppOctokit;
        this.type = options.clientType || "oauth-app";
        const octokit = new Octokit2({
          authStrategy: import_auth_oauth_app.createOAuthAppAuth,
          auth: {
            clientType: this.type,
            clientId: options.clientId,
            clientSecret: options.clientSecret
          }
        });
        const state = {
          clientType: this.type,
          clientId: options.clientId,
          clientSecret: options.clientSecret,
          // @ts-expect-error defaultScopes not permitted for GitHub Apps
          defaultScopes: options.defaultScopes || [],
          allowSignup: options.allowSignup,
          baseUrl: options.baseUrl,
          redirectUrl: options.redirectUrl,
          log: options.log,
          Octokit: Octokit2,
          octokit,
          eventHandlers: {}
        };
        this.on = addEventHandler.bind(null, state);
        this.octokit = octokit;
        this.getUserOctokit = getUserOctokitWithState.bind(null, state);
        this.getWebFlowAuthorizationUrl = getWebFlowAuthorizationUrlWithState.bind(
          null,
          state
        );
        this.createToken = createTokenWithState.bind(
          null,
          state
        );
        this.checkToken = checkTokenWithState.bind(
          null,
          state
        );
        this.resetToken = resetTokenWithState.bind(
          null,
          state
        );
        this.refreshToken = refreshTokenWithState.bind(
          null,
          state
        );
        this.scopeToken = scopeTokenWithState.bind(
          null,
          state
        );
        this.deleteToken = deleteTokenWithState.bind(null, state);
        this.deleteAuthorization = deleteAuthorizationWithState.bind(null, state);
      }
    }, _a3.VERSION = VERSION12, _a3);
  }
});

// node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "node_modules/indent-string/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string, count = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string !== "string") {
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
        );
      }
      if (typeof count !== "number") {
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
        );
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
        );
      }
      if (count === 0) {
        return string;
      }
      const regex2 = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex2, options.indent.repeat(count));
    };
  }
});

// (disabled):os
var require_os = __commonJS({
  "(disabled):os"() {
  }
});

// node_modules/clean-stack/index.js
var require_clean_stack = __commonJS({
  "node_modules/clean-stack/index.js"(exports2, module2) {
    "use strict";
    var os = require_os();
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
    module2.exports = (stack, options) => {
      options = Object.assign({ pretty: false }, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m3, p1) => m3.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  }
});

// node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS({
  "node_modules/aggregate-error/index.js"(exports2, module2) {
    "use strict";
    var indentString = require_indent_string();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError4 = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        errors = [...errors].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", { value: errors });
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module2.exports = AggregateError4;
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex.push((i4 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset + i4] = rnds[i4];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/shared/MessageBus.ts
var import_polyfill_crypto = __toESM(require_polyfill_crypto());
var rnds82 = new Uint8Array(16);
function rng2() {
  return (0, import_polyfill_crypto.default)(rnds82);
}
var MessageBus = class {
  constructor(ctx, executors) {
    this.queue = /* @__PURE__ */ new Map();
    this.ctx = ctx;
    this.executors = executors;
    this.id = v4_default({ rng: rng2 });
    if (this.ctx.hasOwnProperty("ui")) {
      this.env = "plugin";
      this.ctx.ui.on("message", (pluginMessage, props) => this._messageHandler(pluginMessage, props));
    } else {
      this.env = "ui";
      this.ctx.addEventListener("message", (pluginMessage, props) => this._messageHandler(pluginMessage, props));
    }
  }
  async _messageHandler(event, props) {
    const pluginMessage = "data" in event ? event.data.pluginMessage : event;
    if (pluginMessage.type === "execute") {
      await this._executeMessage(pluginMessage);
    } else if (pluginMessage.type === "result") {
      this._resolveMessage(pluginMessage);
    } else {
      throw `ERROR: Unrecognized message type [${pluginMessage.type}]`;
    }
  }
  async _executeMessage(message) {
    for (const executor of this.executors) {
      if (message.fn in executor && typeof executor[message.fn] === "function") {
        const result = await executor[message.fn](message.args);
        this._postMessage({
          id: message.id,
          type: "result",
          result
        });
        return;
      }
    }
    throw `ERROR: No executor can handle the fn [${message.fn}]`;
  }
  _resolveMessage(message) {
    if (this.queue.has(message.id)) {
      const entry = this.queue.get(message.id);
      this.queue.delete(message.id);
      entry.resolve(message.result);
      return;
    }
    throw `ERROR: Unrecognized queue entry ID [${message.id}]`;
  }
  _postMessage(pluginMessage) {
    if (this.env === "ui") {
      this.ctx.parent.postMessage({ pluginMessage }, "*");
    } else {
      this.ctx.ui.postMessage(pluginMessage, { origin: "*" });
    }
  }
  async execute(fn, args) {
    return new Promise((resolve, reject) => {
      const id = v4_default({ rng: rng2 });
      this.queue.set(id, { id, resolve, reject });
      this._postMessage({ id, fn, args, type: "execute" });
    });
  }
};

// src/ui/screens/Screen.ts
var Screen = class {
  constructor(manager) {
    this._manager = manager;
  }
  renderComplete(_parent) {
    const main2 = _parent.querySelector("main");
    if (main2) {
      const style = getComputedStyle(main2);
      this._manager.bus.execute("resizeUi", { height: main2.scrollHeight + 8 });
    }
  }
};

// node_modules/lit-html/lit-html.js
var t = globalThis;
var i = t.trustedTypes;
var s = i ? i.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
var e = "$lit$";
var h = `lit$${(Math.random() + "").slice(9)}$`;
var o = "?" + h;
var n = `<${o}>`;
var r = document;
var l = () => r.createComment("");
var c = (t5) => null === t5 || "object" != typeof t5 && "function" != typeof t5;
var a = Array.isArray;
var u = (t5) => a(t5) || "function" == typeof (t5 == null ? void 0 : t5[Symbol.iterator]);
var d = "[ 	\n\f\r]";
var f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var _ = />/g;
var m = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var p = /'/g;
var g = /"/g;
var $ = /^(?:script|style|textarea|title)$/i;
var y = (t5) => (i4, ...s2) => ({ _$litType$: t5, strings: i4, values: s2 });
var x = y(1);
var b = y(2);
var w = Symbol.for("lit-noChange");
var T = Symbol.for("lit-nothing");
var A = /* @__PURE__ */ new WeakMap();
var E = r.createTreeWalker(r, 129);
function C(t5, i4) {
  if (!Array.isArray(t5) || !t5.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s ? s.createHTML(i4) : i4;
}
var P = (t5, i4) => {
  const s2 = t5.length - 1, o4 = [];
  let r3, l3 = 2 === i4 ? "<svg>" : "", c2 = f;
  for (let i5 = 0; i5 < s2; i5++) {
    const s3 = t5[i5];
    let a3, u4, d2 = -1, y2 = 0;
    for (; y2 < s3.length && (c2.lastIndex = y2, u4 = c2.exec(s3), null !== u4); )
      y2 = c2.lastIndex, c2 === f ? "!--" === u4[1] ? c2 = v : void 0 !== u4[1] ? c2 = _ : void 0 !== u4[2] ? ($.test(u4[2]) && (r3 = RegExp("</" + u4[2], "g")), c2 = m) : void 0 !== u4[3] && (c2 = m) : c2 === m ? ">" === u4[0] ? (c2 = r3 != null ? r3 : f, d2 = -1) : void 0 === u4[1] ? d2 = -2 : (d2 = c2.lastIndex - u4[2].length, a3 = u4[1], c2 = void 0 === u4[3] ? m : '"' === u4[3] ? g : p) : c2 === g || c2 === p ? c2 = m : c2 === v || c2 === _ ? c2 = f : (c2 = m, r3 = void 0);
    const x2 = c2 === m && t5[i5 + 1].startsWith("/>") ? " " : "";
    l3 += c2 === f ? s3 + n : d2 >= 0 ? (o4.push(a3), s3.slice(0, d2) + e + s3.slice(d2) + h + x2) : s3 + h + (-2 === d2 ? i5 : x2);
  }
  return [C(t5, l3 + (t5[s2] || "<?>") + (2 === i4 ? "</svg>" : "")), o4];
};
var V = class _V {
  constructor({ strings: t5, _$litType$: s2 }, n3) {
    let r3;
    this.parts = [];
    let c2 = 0, a3 = 0;
    const u4 = t5.length - 1, d2 = this.parts, [f3, v2] = P(t5, s2);
    if (this.el = _V.createElement(f3, n3), E.currentNode = this.el.content, 2 === s2) {
      const t6 = this.el.content.firstChild;
      t6.replaceWith(...t6.childNodes);
    }
    for (; null !== (r3 = E.nextNode()) && d2.length < u4; ) {
      if (1 === r3.nodeType) {
        if (r3.hasAttributes())
          for (const t6 of r3.getAttributeNames())
            if (t6.endsWith(e)) {
              const i4 = v2[a3++], s3 = r3.getAttribute(t6).split(h), e5 = /([.?@])?(.*)/.exec(i4);
              d2.push({ type: 1, index: c2, name: e5[2], strings: s3, ctor: "." === e5[1] ? k : "?" === e5[1] ? H : "@" === e5[1] ? I : R }), r3.removeAttribute(t6);
            } else
              t6.startsWith(h) && (d2.push({ type: 6, index: c2 }), r3.removeAttribute(t6));
        if ($.test(r3.tagName)) {
          const t6 = r3.textContent.split(h), s3 = t6.length - 1;
          if (s3 > 0) {
            r3.textContent = i ? i.emptyScript : "";
            for (let i4 = 0; i4 < s3; i4++)
              r3.append(t6[i4], l()), E.nextNode(), d2.push({ type: 2, index: ++c2 });
            r3.append(t6[s3], l());
          }
        }
      } else if (8 === r3.nodeType)
        if (r3.data === o)
          d2.push({ type: 2, index: c2 });
        else {
          let t6 = -1;
          for (; -1 !== (t6 = r3.data.indexOf(h, t6 + 1)); )
            d2.push({ type: 7, index: c2 }), t6 += h.length - 1;
        }
      c2++;
    }
  }
  static createElement(t5, i4) {
    const s2 = r.createElement("template");
    return s2.innerHTML = t5, s2;
  }
};
function N(t5, i4, s2 = t5, e5) {
  var _a3, _b, _c;
  if (i4 === w)
    return i4;
  let h2 = void 0 !== e5 ? (_a3 = s2._$Co) == null ? void 0 : _a3[e5] : s2._$Cl;
  const o4 = c(i4) ? void 0 : i4._$litDirective$;
  return (h2 == null ? void 0 : h2.constructor) !== o4 && ((_b = h2 == null ? void 0 : h2._$AO) == null ? void 0 : _b.call(h2, false), void 0 === o4 ? h2 = void 0 : (h2 = new o4(t5), h2._$AT(t5, s2, e5)), void 0 !== e5 ? ((_c = s2._$Co) != null ? _c : s2._$Co = [])[e5] = h2 : s2._$Cl = h2), void 0 !== h2 && (i4 = N(t5, h2._$AS(t5, i4.values), h2, e5)), i4;
}
var S = class {
  constructor(t5, i4) {
    this._$AV = [], this._$AN = void 0, this._$AD = t5, this._$AM = i4;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t5) {
    var _a3;
    const { el: { content: i4 }, parts: s2 } = this._$AD, e5 = ((_a3 = t5 == null ? void 0 : t5.creationScope) != null ? _a3 : r).importNode(i4, true);
    E.currentNode = e5;
    let h2 = E.nextNode(), o4 = 0, n3 = 0, l3 = s2[0];
    for (; void 0 !== l3; ) {
      if (o4 === l3.index) {
        let i5;
        2 === l3.type ? i5 = new M(h2, h2.nextSibling, this, t5) : 1 === l3.type ? i5 = new l3.ctor(h2, l3.name, l3.strings, this, t5) : 6 === l3.type && (i5 = new L(h2, this, t5)), this._$AV.push(i5), l3 = s2[++n3];
      }
      o4 !== (l3 == null ? void 0 : l3.index) && (h2 = E.nextNode(), o4++);
    }
    return E.currentNode = r, e5;
  }
  p(t5) {
    let i4 = 0;
    for (const s2 of this._$AV)
      void 0 !== s2 && (void 0 !== s2.strings ? (s2._$AI(t5, s2, i4), i4 += s2.strings.length - 2) : s2._$AI(t5[i4])), i4++;
  }
};
var M = class _M {
  get _$AU() {
    var _a3, _b;
    return (_b = (_a3 = this._$AM) == null ? void 0 : _a3._$AU) != null ? _b : this._$Cv;
  }
  constructor(t5, i4, s2, e5) {
    var _a3;
    this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = t5, this._$AB = i4, this._$AM = s2, this.options = e5, this._$Cv = (_a3 = e5 == null ? void 0 : e5.isConnected) != null ? _a3 : true;
  }
  get parentNode() {
    let t5 = this._$AA.parentNode;
    const i4 = this._$AM;
    return void 0 !== i4 && 11 === (t5 == null ? void 0 : t5.nodeType) && (t5 = i4.parentNode), t5;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t5, i4 = this) {
    t5 = N(this, t5, i4), c(t5) ? t5 === T || null == t5 || "" === t5 ? (this._$AH !== T && this._$AR(), this._$AH = T) : t5 !== this._$AH && t5 !== w && this._(t5) : void 0 !== t5._$litType$ ? this.g(t5) : void 0 !== t5.nodeType ? this.$(t5) : u(t5) ? this.T(t5) : this._(t5);
  }
  k(t5) {
    return this._$AA.parentNode.insertBefore(t5, this._$AB);
  }
  $(t5) {
    this._$AH !== t5 && (this._$AR(), this._$AH = this.k(t5));
  }
  _(t5) {
    this._$AH !== T && c(this._$AH) ? this._$AA.nextSibling.data = t5 : this.$(r.createTextNode(t5)), this._$AH = t5;
  }
  g(t5) {
    var _a3;
    const { values: i4, _$litType$: s2 } = t5, e5 = "number" == typeof s2 ? this._$AC(t5) : (void 0 === s2.el && (s2.el = V.createElement(C(s2.h, s2.h[0]), this.options)), s2);
    if (((_a3 = this._$AH) == null ? void 0 : _a3._$AD) === e5)
      this._$AH.p(i4);
    else {
      const t6 = new S(e5, this), s3 = t6.u(this.options);
      t6.p(i4), this.$(s3), this._$AH = t6;
    }
  }
  _$AC(t5) {
    let i4 = A.get(t5.strings);
    return void 0 === i4 && A.set(t5.strings, i4 = new V(t5)), i4;
  }
  T(t5) {
    a(this._$AH) || (this._$AH = [], this._$AR());
    const i4 = this._$AH;
    let s2, e5 = 0;
    for (const h2 of t5)
      e5 === i4.length ? i4.push(s2 = new _M(this.k(l()), this.k(l()), this, this.options)) : s2 = i4[e5], s2._$AI(h2), e5++;
    e5 < i4.length && (this._$AR(s2 && s2._$AB.nextSibling, e5), i4.length = e5);
  }
  _$AR(t5 = this._$AA.nextSibling, i4) {
    var _a3;
    for ((_a3 = this._$AP) == null ? void 0 : _a3.call(this, false, true, i4); t5 && t5 !== this._$AB; ) {
      const i5 = t5.nextSibling;
      t5.remove(), t5 = i5;
    }
  }
  setConnected(t5) {
    var _a3;
    void 0 === this._$AM && (this._$Cv = t5, (_a3 = this._$AP) == null ? void 0 : _a3.call(this, t5));
  }
};
var R = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t5, i4, s2, e5, h2) {
    this.type = 1, this._$AH = T, this._$AN = void 0, this.element = t5, this.name = i4, this._$AM = e5, this.options = h2, s2.length > 2 || "" !== s2[0] || "" !== s2[1] ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = T;
  }
  _$AI(t5, i4 = this, s2, e5) {
    const h2 = this.strings;
    let o4 = false;
    if (void 0 === h2)
      t5 = N(this, t5, i4, 0), o4 = !c(t5) || t5 !== this._$AH && t5 !== w, o4 && (this._$AH = t5);
    else {
      const e6 = t5;
      let n3, r3;
      for (t5 = h2[0], n3 = 0; n3 < h2.length - 1; n3++)
        r3 = N(this, e6[s2 + n3], i4, n3), r3 === w && (r3 = this._$AH[n3]), o4 || (o4 = !c(r3) || r3 !== this._$AH[n3]), r3 === T ? t5 = T : t5 !== T && (t5 += (r3 != null ? r3 : "") + h2[n3 + 1]), this._$AH[n3] = r3;
    }
    o4 && !e5 && this.O(t5);
  }
  O(t5) {
    t5 === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t5 != null ? t5 : "");
  }
};
var k = class extends R {
  constructor() {
    super(...arguments), this.type = 3;
  }
  O(t5) {
    this.element[this.name] = t5 === T ? void 0 : t5;
  }
};
var H = class extends R {
  constructor() {
    super(...arguments), this.type = 4;
  }
  O(t5) {
    this.element.toggleAttribute(this.name, !!t5 && t5 !== T);
  }
};
var I = class extends R {
  constructor(t5, i4, s2, e5, h2) {
    super(t5, i4, s2, e5, h2), this.type = 5;
  }
  _$AI(t5, i4 = this) {
    var _a3;
    if ((t5 = (_a3 = N(this, t5, i4, 0)) != null ? _a3 : T) === w)
      return;
    const s2 = this._$AH, e5 = t5 === T && s2 !== T || t5.capture !== s2.capture || t5.once !== s2.once || t5.passive !== s2.passive, h2 = t5 !== T && (s2 === T || e5);
    e5 && this.element.removeEventListener(this.name, this, s2), h2 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
  }
  handleEvent(t5) {
    var _a3, _b;
    "function" == typeof this._$AH ? this._$AH.call((_b = (_a3 = this.options) == null ? void 0 : _a3.host) != null ? _b : this.element, t5) : this._$AH.handleEvent(t5);
  }
};
var L = class {
  constructor(t5, i4, s2) {
    this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t5) {
    N(this, t5);
  }
};
var z = { j: e, P: h, A: o, C: 1, M: P, L: S, R: u, V: N, D: M, I: R, H, N: I, U: k, B: L };
var Z = t.litHtmlPolyfillSupport;
var _a;
Z == null ? void 0 : Z(V, M), ((_a = t.litHtmlVersions) != null ? _a : t.litHtmlVersions = []).push("3.0.2");
var j = (t5, i4, s2) => {
  var _a3, _b;
  const e5 = (_a3 = s2 == null ? void 0 : s2.renderBefore) != null ? _a3 : i4;
  let h2 = e5._$litPart$;
  if (void 0 === h2) {
    const t6 = (_b = s2 == null ? void 0 : s2.renderBefore) != null ? _b : null;
    e5._$litPart$ = h2 = new M(i4.insertBefore(l(), t6), t6, void 0, s2 != null ? s2 : {});
  }
  return h2._$AI(t5), h2;
};

// src/shared/Metadata.ts
var MetadataDefaults = {
  ["com.phenoui.strapi.auth.server" /* strapiServer */]: "http://localhost:1337"
};

// node_modules/lit-html/directive.js
var t2 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e2 = (t5) => (...e5) => ({ _$litDirective$: t5, values: e5 });
var i2 = class {
  constructor(t5) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t5, e5, i4) {
    this._$Ct = t5, this._$AM = e5, this._$Ci = i4;
  }
  _$AS(t5, e5) {
    return this.update(t5, e5);
  }
  update(t5, e5) {
    return this.render(...e5);
  }
};

// node_modules/lit-html/directive-helpers.js
var { D: t3 } = z;
var f2 = (o4) => void 0 === o4.strings;
var u2 = {};
var m2 = (o4, t5 = u2) => o4._$AH = t5;

// node_modules/lit-html/directives/live.js
var l2 = e2(class extends i2 {
  constructor(r3) {
    if (super(r3), r3.type !== t2.PROPERTY && r3.type !== t2.ATTRIBUTE && r3.type !== t2.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!f2(r3))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(r3) {
    return r3;
  }
  update(i4, [t5]) {
    if (t5 === w || t5 === T)
      return t5;
    const o4 = i4.element, l3 = i4.name;
    if (i4.type === t2.PROPERTY) {
      if (t5 === o4[l3])
        return w;
    } else if (i4.type === t2.BOOLEAN_ATTRIBUTE) {
      if (!!t5 === o4.hasAttribute(l3))
        return w;
    } else if (i4.type === t2.ATTRIBUTE && o4.getAttribute(l3) === t5 + "")
      return w;
    return m2(i4), t5;
  }
});

// src/ui/widgets/icons.ts
var flutter = x`
    <svg width="100%" height="100%" viewBox="0 0 138 170" version="1.1" xmlns="http://www.w3.org/2000/svg" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <path d="M137.3,78.46L91.54,124.23L137.3,170L85,170L39.23,124.23L85,78.46L137.3,78.46ZM85,0L0,85L26.16,111.16L137.3,0L85,0Z" style="fill-rule:nonzero;"/>
    </svg>
`;
var github = x`
    <svg width="100%" height="100%" viewBox="0 0 98 96" version="1.1" xmlns="http://www.w3.org/2000/svg" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <path d="M48.854,0C21.839,0 0,22 0,49.217C0,70.973 13.993,89.389 33.405,95.907C35.832,96.397 36.721,94.848 36.721,93.545C36.721,92.404 36.641,88.493 36.641,84.418C23.051,87.352 20.221,78.551 20.221,78.551C18.037,72.847 14.801,71.381 14.801,71.381C10.353,68.366 15.125,68.366 15.125,68.366C20.059,68.692 22.648,73.418 22.648,73.418C27.015,80.914 34.052,78.796 36.883,77.492C37.287,74.314 38.582,72.114 39.957,70.892C29.118,69.751 17.714,65.514 17.714,46.609C17.714,41.231 19.654,36.831 22.728,33.409C22.243,32.187 20.544,27.134 23.214,20.371C23.214,20.371 27.339,19.067 36.64,25.423C40.622,24.346 44.729,23.798 48.854,23.793C52.979,23.793 57.184,24.364 61.067,25.423C70.369,19.067 74.494,20.371 74.494,20.371C77.164,27.134 75.464,32.187 74.979,33.409C78.134,36.831 79.994,41.231 79.994,46.609C79.994,65.514 68.59,69.669 57.67,70.892C59.45,72.44 60.986,75.373 60.986,80.018C60.986,86.618 60.906,91.915 60.906,93.544C60.906,94.848 61.796,96.397 64.222,95.908C83.634,89.388 97.627,70.973 97.627,49.217C97.707,22 75.788,0 48.854,0Z" style="fill:var(--figma-color-text);"/>
    </svg>
`;
var strapi = x`
    <svg width="100%" height="100%" viewBox="0 0 600 600" version="1.1" xmlns="http://www.w3.org/2000/svg" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <path d="M0,208C0,109.948 0,60.922 30.461,30.461C60.922,0 109.948,0 208,0L392,0C490.052,0 539.078,0 569.539,30.461C600,60.922 600,109.948 600,208L600,392C600,490.052 600,539.078 569.539,569.539C539.078,600 490.052,600 392,600L208,600C109.948,600 60.922,600 30.461,569.539C0,539.078 0,490.052 0,392L0,208Z" style="fill:var(--figma-color-text);fill-rule:nonzero;"/>
        <path d="M414,182L212,182L212,285L315,285L315,388L418,388L418,186C418,183.791 416.209,182 414,182Z" style="fill:var(--figma-color-bg-disabled);"/>
        <rect x="311" y="285" width="4" height="4" style="fill:var(--figma-color-bg-disabled);"/>
        <path d="M212,285L311,285C313.209,285 315,286.791 315,289L315,388L216,388C213.791,388 212,386.209 212,384L212,285Z" style="fill:var(--figma-color-bg-disabled-secondary);fill-rule:nonzero;"/>
        <path d="M315,388L418,388L318.414,487.586C317.154,488.846 315,487.953 315,486.172L315,388Z" style="fill:var(--figma-color-bg-disabled-secondary);fill-rule:nonzero;"/>
        <path d="M212,285L113.828,285C112.046,285 111.154,282.846 112.414,281.586L212,182L212,285Z" style="fill:var(--figma-color-bg-disabled-secondary);fill-rule:nonzero;"/>
    </svg>
`;
var figma2 = x`
    <svg width="100%" height="100%" viewBox="0 0 475 686" version="1.1" xmlns="http://www.w3.org/2000/svg" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-162.669,-55.9995)">
            <path d="M373.336,109.333L294.669,109.333C251.223,109.333 216.003,144.553 216.003,187.999C216.003,231.446 251.223,266.666 294.669,266.666L373.336,266.666L373.336,109.333ZM294.669,55.999L505.336,55.999C578.24,55.999 637.333,115.098 637.333,187.999C637.333,231.02 616.757,269.235 584.901,293.333C616.757,317.431 637.333,355.646 637.333,398.667C637.333,471.568 578.24,530.667 505.336,530.667C475.859,530.667 448.639,521.005 426.669,504.675L426.669,609.333C426.669,682.235 367.571,741.333 294.669,741.333C221.767,741.333 162.669,682.235 162.669,609.333C162.669,566.309 183.25,528.098 215.102,503.999C183.25,479.901 162.669,441.687 162.669,398.667C162.669,355.646 183.25,317.431 215.103,293.333C183.25,269.235 162.669,231.02 162.669,187.999C162.669,115.098 221.767,55.999 294.669,55.999ZM426.669,109.333L426.669,266.666L505.336,266.666C548.784,266.666 584,231.446 584,187.999C584,144.553 548.784,109.333 505.336,109.333L426.669,109.333ZM294.669,477.332L373.336,477.332L373.336,320L294.669,320C251.223,320 216.003,355.22 216.003,398.667C216.003,442.009 251.054,477.165 294.357,477.333L294.669,477.332ZM216.003,609.333C216.003,565.989 251.054,530.835 294.357,530.666L294.669,530.667L373.336,530.667L373.336,609.333C373.336,652.779 338.116,688 294.669,688C251.223,688 216.003,652.779 216.003,609.333ZM426.669,398.51C426.754,355.135 461.942,320 505.336,320C548.784,320 584,355.22 584,398.667C584,442.113 548.784,477.333 505.336,477.333C461.942,477.333 426.754,442.198 426.669,398.823L426.669,398.51Z" style="fill:var(--figma-color-text);"/>
        </g>
    </svg>
`;
var linkProperty = x`
    <svg class="svg" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 16 16">
        <path d="m5.68 10.823.353.354 2.701 2.7c.195.196.512.196.707 0l5.401-5.4c.195-.196.195-.513 0-.708l-5.4-5.4c-.196-.196-.513-.196-.708 0l-2.7 2.7-.354.353-.707-.707.353-.353 2.7-2.701c.587-.586 1.536-.586 2.122 0l5.401 5.401c.586.586.586 1.536 0 2.121l-5.4 5.402c-.587.585-1.536.585-2.122 0l-2.7-2.701-.354-.354.707-.707zm3.407-.996c.941 0 1.704-.763 1.704-1.704 0-.941-.763-1.704-1.704-1.704-.767 0-1.416.507-1.63 1.204H0v1h7.458c.213.697.862 1.204 1.63 1.204z" />
    </svg>
`;
var unlinkProperty = x`
    <svg class="svg" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 14 14">
        <path d="M4 0v3h1V0H4zm9.103.896c-1.162-1.161-3.045-1.161-4.207 0l-2.75 2.75.707.708 2.75-2.75c.771-.772 2.022-.772 2.793 0 .771.77.771 2.021 0 2.792l-2.75 2.75.707.708 2.75-2.75c1.162-1.162 1.162-3.046 0-4.208zM.896 13.103c-1.162-1.161-1.162-3.045 0-4.207l2.75-2.75.707.708-2.75 2.75c-.771.77-.771 2.021 0 2.792.771.772 2.022.772 2.793 0l2.75-2.75.707.707-2.75 2.75c-1.162 1.162-3.045 1.162-4.207 0zM14 10h-3V9h3v1zm-4 1v3H9v-3h1zM3 4H0v1h3V4z" />
    </svg>
`;
var plusSign = x`
    <svg class="svg" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 12 12">
        <path fill-rule="nonzero" stroke="none" d="M5 5V0h1v5h5v1H6v5H5V6H0V5h5z" />
    </svg>
`;
var minusSign = x`
    <svg class="svg" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 12 6">
        <path fill-rule="evenodd" stroke="none" d="M11 3H0V2h11v1z" />
    </svg>
`;
var playButton = x`
    <svg width="100%" height="100%" viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 2.692v11.618l11.618-5.837-11.618-5.781zM4 4.308l8.382 4.17-8.382 4.211v-8.381z" />
    </svg>
`;
var pauseButton = x`
    <svg width="100%" height="100%" viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 15h4v-13h-4v13zM4 3h2v11h-2v-11zM10 2v13h4v-13h-4zM13 14h-2v-11h2v11z" />
    </svg>
`;
var placeButton = x`
    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 16 16">
        <path fill-opacity="1" fill-rule="evenodd" stroke="none" d="M1.646 13.646 4.293 11H2v-1h4v4H5v-2.293l-2.646 2.647-.708-.707zm12.708 0L11.707 11H14v-1h-4v4h1v-2.293l2.646 2.647.708-.707zM1.646 2.354 4.293 5H2v1h4V2H5v2.293L2.354 1.646l-.708.708zm12.708 0L11.707 5H14v1h-4V2h1v2.293l2.646-2.647.708.708z" />
    </svg>
`;

// src/ui/widgets/input.ts
async function autocompleteFocus(el, event, state, provider) {
  const parent2 = el.parentElement;
  const container = parent2.querySelector(".autocomplete-container");
  if (event.type === "focus") {
    state.input = el;
    state.container = container;
    container.style.display = "block";
    const itemElements = parent2.querySelectorAll(".autocomplete-item");
    itemElements.forEach((e5) => e5.style.display = "none");
  } else {
    container.style.display = "none";
    state.input = void 0;
    state.container = void 0;
  }
}
async function autocompleteInput(el, state, provider) {
  if (!state.debounce) {
    state.debounce = true;
    const items = await provider(el.value);
    const parent2 = el.parentElement;
    const itemElements = Array.from(parent2.querySelectorAll(".autocomplete-item"));
    for (let i4 = 0, n3 = itemElements.length; i4 < n3; ++i4) {
      if (i4 < items.length) {
        itemElements[i4].style.display = "flex";
        itemElements[i4].innerText = items[i4];
      } else {
        itemElements[i4].style.display = "none";
      }
    }
    state.debounce = false;
    if (state.queuedChange) {
      state.queuedChange = false;
      await autocompleteInput(el, state, provider);
    }
  } else {
    state.queuedChange = true;
  }
}
function autocompleteSelection(el, state) {
  if (state.input) {
    state.input.value = el.innerText;
    state.input.blur();
  }
}
function _makeLinkProperty(data2) {
  if (data2.properties && data2.properties.length > 0) {
    return x`
            <div class="input-icon">
                ${linkProperty}
            </div>
            <select
                    id="${data2.id}"
                    class="select-link-property"
                    @change="${function(_e) {
      if (this.value && data2.onUpdatePropertyBinding) {
        data2.onUpdatePropertyBinding(data2.id, this.value);
      }
    }}"
            >
                <option value=""></option>
                ${data2.properties.map((p2) => x`<option id="${p2}" value="${p2}">${p2.split(/#(?!.*#)/)[0]}</option>`)}
            </select>
        `;
  }
  return null;
}
function _input(type, data2) {
  const state = {
    debounce: false,
    queuedChange: false
  };
  async function handleFocus(e5) {
    if (e5.type === "focus") {
      this.select();
    }
    if (data2.provider) {
      await autocompleteFocus(this, e5, state, data2.provider);
    }
  }
  async function handleInput(_e) {
    await autocompleteInput(this, state, data2.provider);
  }
  function handleMouseDown(e5) {
    e5.stopPropagation();
    e5.stopImmediatePropagation();
    e5.preventDefault();
    autocompleteSelection(this, state);
  }
  return x`
        <div class="input-container" title="${data2.label}" aria-label="${data2.label}">
            ${data2.icon ? x`<div class="input-icon">${data2.icon}</div>` : null}
            <input
                id="${data2.id}"
                class="text-input"
                type="${type}"
                aria-label = "${data2.label}, ${data2.placeholder}"
                placeholder="${data2.placeholder}"
                .value="${l2(data2.value || "")}"
                @focus="${handleFocus}"
                @blur="${data2.provider ? handleFocus : null}"
                @input="${data2.provider ? handleInput : null}"
                @change="${function(_e) {
    if (data2.onUpdate) {
      data2.onUpdate(data2.id, this.value, false);
    }
  }}"
                @keypress="${function(e5) {
    if (e5.target && e5.code === "Enter") {
      this.blur();
    }
  }}"
            / >
            ${_makeLinkProperty(data2)}
            <div class="autocomplete-container" style="display:none;">
                <div class="autocomplete-item" @mousedown="${handleMouseDown}">text</div>
                <div class="autocomplete-item" @mousedown="${handleMouseDown}">text</div>
                <div class="autocomplete-item" @mousedown="${handleMouseDown}">text</div>
                <div class="autocomplete-item" @mousedown="${handleMouseDown}">text</div>
            </div>
        </div>
    `;
}
function passwordInput(data2) {
  return _input("password", data2);
}
function textInput(data2) {
  return _input("text", data2);
}
function numberInput(data2) {
  return _input("number", data2);
}
function groupInput(data2) {
  var _a3;
  const props = data2.value.properties;
  return x`
        <div class="group-input-container">
            <div class="group-property-container" title="${data2.label}" aria-label="${data2.label}">
                <div class="group-property-container">
                    <div class="group-icon">${data2.icon}</div>
                    <span class="group-title">${data2.name.charAt(0).toUpperCase()}${(_a3 = data2.name) == null ? void 0 : _a3.slice(1)}</span>
                </div>
                <div 
                    class="icon-button"
                    @click="${function(_e) {
    if (data2.onUpdate) {
      props.push({ type: "string", description: "", value: "" });
      data2.onUpdate(data2.id, { type: "group", properties: props }, true);
    }
  }}"
                >
                    ${plusSign}
                </div>
            </div>
                
            ${props.map((p2) => x`
                <div class="group-property-container" title="${p2.description}" aria-label="${p2.description}">
                    ${textInput({
    id: `key:${p2.description}`,
    label: "Key",
    icon: "K",
    placeholder: "key",
    value: p2.description,
    onUpdate: (_2, value2) => {
      if (data2.onUpdate) {
        p2.description = value2;
        data2.onUpdate(data2.id, { type: "group", properties: props }, false);
      }
    }
  })}
                    ${(() => {
    return textInput({
      id: `value:${p2.description}`,
      label: "Value",
      icon: "V",
      placeholder: "value",
      value: p2.value || p2.default,
      onUpdate: (_2, value2) => {
        if (data2.onUpdate) {
          p2.value = value2;
          data2.onUpdate(data2.id, { type: "group", properties: props }, false);
        }
      }
    });
  })()}
                    <div
                        class="icon-button"
                        @click="${function(_e) {
    if (data2.onUpdate) {
      props.splice(props.indexOf(p2), 1);
      data2.onUpdate(data2.id, { type: "group", properties: props }, true);
    }
  }}"
                    >
                        ${minusSign}
                    </div>
                </div>
            `)}
        </div>
    `;
}
function boundedPropertyInput(data2) {
  return x`
        <div class="input-container" title="${data2.placeholder}" aria-label="${data2.placeholder}">
            ${data2.icon ? x`<div class="input-icon">${data2.icon}</div>` : x`<div class="text-container">${data2.label}</div>`}
            <div class="bound-property-pill-container">
                <div class="bound-property-pill">
                    <div class="input-icon bound-icon">${linkProperty}</div>
                    ${data2.value.id.split(/#(?!.*#)/)[0]}
                </div>
            </div>
            <div 
                    class="input-icon unlink-icon"
                    @click="${function(_e) {
    var _a3, _b;
    if (data2.onUpdate) {
      data2.onUpdate(data2.id, (_b = (_a3 = data2.value) == null ? void 0 : _a3.value) != null ? _b : null, true);
    }
  }}"
            >
                ${unlinkProperty}
            </div>
        </div>
    `;
}
function selectInput(data2) {
  return x`
        <div class="input-container" title="${data2.label}" aria-label="${data2.label}">
            <div class="input-icon">
                ${data2.icon}
            </div>
            <select
                id="${data2.id}"
                class="select-input"
                .value="${l2(data2.value)}"
                @change="${function(_e) {
    if (data2.onUpdate) {
      data2.onUpdate(data2.id, this.value, false);
    }
  }}"
            >
                ${data2.options.map(
    (o4) => x`<option id="${o4.value}-${data2.value}" value="${o4.value}" ?selected="${o4.value === data2.value}">${o4.label}</option>`
  )}
            </select>
        </div>
    `;
}
function booleanInput(data2) {
  return x`
        <div class="input-container" title="${data2.placeholder}" aria-label="${data2.placeholder}">
            ${data2.icon ? x`<div class="input-icon">${data2.icon}</div>` : x`<div class="text-container">${data2.label}</div>`}
            <div class="bool-input-container">
                <input
                    id="${data2.id}"
                    class="bool-input"
                    type="checkbox"
                    .checked="${Boolean(data2.value)}"
                    @change="${function(_e) {
    if (data2.onUpdate) {
      data2.onUpdate(data2.id, this.checked, false);
    }
  }}"
                / >
                <label for="${data2.id}">${data2.label}</label>
            </div>
            ${_makeLinkProperty(data2)}
        </div>
    `;
}

// src/ui/widgets/button.ts
function button(data2) {
  return x`
        <button
            id="${data2.id}" 
            type="button" 
            class="button"
            @click="${() => data2.onClick ? data2.onClick(data2.id) : null}"
            ?disabled="${data2.disabled}"
        >
            <span class="button-label">${data2.label}</span>
        </button>
    `;
}

// src/ui/widgets/header.ts
function getHeader(title, selection, bus) {
  return x`
        <section>
            <div class="row" style="height: 16px;">
                <div class="title">${title}</div>
            </div>
            <div class="row-full">
                <div class="tab-container ${selection === 0 /* figma */ ? "tab-selected" : ""}"
                    @click="${async () => await bus.execute("setTab", { tab: 0 /* figma */ })}"
                >
                    <div class="tab-icon">${figma2}</div>
                    <div class="tab-title">figma</div>
                </div>
                <div class="tab-container ${selection === 1 /* strapi */ ? "tab-selected" : ""}"
                     @click="${async () => await bus.execute("setTab", { tab: 1 /* strapi */ })}"
                >
                    <div class="tab-icon">${strapi}</div>
                    <div class="tab-title">strapi</div>
                </div>
                <div class="tab-container ${selection === 2 /* github */ ? "tab-selected" : ""}"
                     @click="${async () => await bus.execute("setTab", { tab: 2 /* github */ })}"
                >
                    <div class="tab-icon">${github}</div>
                    <div class="tab-title">github</div>
                </div>
            </div>
        </section>
    `;
}

// src/plugin/Strapi.ts
var import_qs = __toESM(require_lib());

// src/ui/tools/export/strapi.ts
var import_qs2 = __toESM(require_lib());
async function _strapiAssetExists(bus, name2, jwt) {
  const query = import_qs2.default.stringify({
    filters: {
      name: {
        $eq: name2
      }
    }
  });
  const url = await bus.execute("getStrapiUrlForEndpoint", { collection: "/api/upload/files" /* files */, options: { query } });
  const response = await fetch(url, {
    headers: {
      Authorization: `Bearer ${jwt}`
    }
  });
  const result = await response.json();
  if (result.length > 0) {
    return result[0];
  }
  return null;
}
async function _uploadAssetsToStrapi(bus, assets, callbacks) {
  const jwt = await bus.execute("getStrapiJwt", void 0);
  const server = await bus.execute("getStrapiServer", void 0);
  const url = await bus.execute("getStrapiUrlForEndpoint", { collection: "/api/upload" /* upload */ });
  for (const asset of assets) {
    const uploadMethod = callbacks.getUploadMethod(asset);
    if (uploadMethod === "embed") {
      continue;
    }
    const filename = callbacks.getAssetName(asset);
    const existing = await _strapiAssetExists(bus, filename, jwt);
    if (uploadMethod == "link" && existing) {
      callbacks.setAssetData(asset, new URL(existing.url, server).href);
      continue;
    }
    const query = existing ? `?id=${existing.id}` : "";
    const form = new FormData();
    const blob = callbacks.getAssetBlob(asset);
    form.append("files", blob, filename);
    const response = await fetch(`${url}${query}`, {
      method: "post",
      headers: {
        Authorization: `Bearer ${jwt}`
      },
      body: form
    });
    const result = await response.json();
    const assetResult = Array.isArray(result) ? result[0] : result;
    if (assetResult) {
      callbacks.setAssetData(asset, new URL(assetResult.url, server).href);
    }
  }
}
async function _uploadImagesToStrapi(bus, images) {
  await _uploadAssetsToStrapi(bus, images, {
    getUploadMethod: (image) => {
      var _a3, _b;
      return (_b = (_a3 = image.__userData.method) != null ? _a3 : image.uploadMethod) != null ? _b : "embed";
    },
    getAssetName: (image) => `${image.__info.name}.${image.format}`,
    setAssetData: (image, data2) => image.data = data2,
    getAssetBlob: (image) => {
      if (image.format === "svg") {
        return new Blob([image.data], { type: "image/svg+xml" });
      } else {
        const bytes = Uint8Array.from(atob(image.data), (c2) => c2.charCodeAt(0));
        return new Blob([bytes], { type: `image/${image.format}` });
      }
    }
  });
}
async function _uploadAnimationsToStrapi(bus, animations) {
  await _uploadAssetsToStrapi(bus, animations, {
    getUploadMethod: (animation) => {
      var _a3;
      const method = (_a3 = animation.__userData.method) != null ? _a3 : "embed";
      console.log(method);
      return method;
    },
    getAssetName: (animation) => `${animation.__info.name}.json`,
    setAssetData: (animation, data2) => animation.__userData.animation.fields.data = data2,
    getAssetBlob: (animation) => new Blob([animation.__userData.animation.fields.data], { type: "application/json" })
  });
}
async function uploadToStrapi(bus, name2, payload) {
  const collection = payload.type === "figma-component" ? "/api/figma-widgets" /* widgets */ : "/api/screens" /* screens */;
  const categoryCollection = payload.type === "figma-component" ? "/api/figma-widget-categories" /* widgetCategories */ : "/api/screen-categories" /* screenCategories */;
  const categoryUid = await bus.execute("getLocalData", "com.phenoui.strapi.auth.user" /* strapiUser */);
  const categoryData = await bus.execute("getCategory", { collection: categoryCollection, uid: categoryUid });
  const category = categoryData ? categoryData.id : (await bus.execute("createCategory", { collection: categoryCollection, uid: categoryUid })).id;
  const slug = `${categoryUid.toLowerCase().replace(/ /g, "-")}-${name2.toLowerCase().replace(/ /g, "-")}`;
  const images = extractImages(payload);
  await _uploadImagesToStrapi(bus, images);
  const animations = extractAnimations(payload);
  await _uploadAnimationsToStrapi(bus, animations);
  if (payload.type !== "figma-image") {
    let data2;
    if (payload.type === "figma-component") {
      data2 = {
        name: name2,
        category,
        slug,
        defaultVariant: payload.defaultVariant,
        variants: payload.variants
      };
      if ("__userData" in payload) {
        data2["arguments"] = payload.__userData;
      }
    } else {
      data2 = {
        name: name2,
        category,
        slug,
        spec: payload
      };
    }
    await bus.execute("uploadToStrapi", { collection, payload: data2 });
  }
}

// src/ui/tools/export/github.ts
async function commitToGithub(bus, name2, payload, github2) {
  var _a3, _b;
  if (!await github2.isLoggedIn) {
    console.log("not logged in");
    return;
  }
  const [type, folder] = (() => {
    switch (payload.type) {
      case "figma-component":
        return ["WIDGET", "widgets"];
      case "figma-image":
        return ["IMAGE", null];
      default:
        return ["SCREEN", "screens"];
    }
  })();
  const files = [];
  const images = extractImages(payload);
  for (const image of images) {
    const uploadMethod = (_b = (_a3 = image.__userData.method) != null ? _a3 : image.uploadMethod) != null ? _b : "embed";
    if (uploadMethod === "embed") {
      continue;
    }
    const filename = `${image.__info.name}.${image.format}`;
    const path = `assets/images/${filename}`;
    const exists = await github2.fileExists(path);
    if (uploadMethod === "link" && exists) {
      image.data = path;
      continue;
    }
    files.push({
      path,
      content: image.data,
      isBinary: image.format !== "svg"
    });
    image.data = path;
  }
  if (folder) {
    files.push({
      path: `${folder}/${name2}.json`,
      content: JSON.stringify(payload, null, 2)
    });
  }
  const message = `[${type.toUpperCase()}] ${name2}`;
  while (true) {
    try {
      await github2.commitFiles(files, message);
      break;
    } catch (e5) {
      if (e5.status === 422) {
        await new Promise((resolve) => setTimeout(resolve, 1e4));
      }
    }
  }
}

// src/ui/tools/export/export.ts
var _exporting = false;
async function _downloadExport(name2, payload) {
  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
  const blobURL = window.URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = blobURL;
  link.download = `${name2}.json`;
  link.click();
  link.setAttribute("download", `${name2},json`);
  await new Promise((resolve) => setTimeout(resolve, 1e3));
}
function _extractNodesOfType(payload, type) {
  const nodes = [];
  if (payload.type === type) {
    nodes.push(payload);
  }
  if ("children" in payload) {
    for (const child of payload.children) {
      nodes.push(..._extractNodesOfType(child, type));
    }
  } else if ("child" in payload) {
    nodes.push(..._extractNodesOfType(payload.child, type));
  }
  if ("variants" in payload) {
    for (const key2 of Object.keys(payload.variants)) {
      nodes.push(..._extractNodesOfType(payload.variants[key2], type));
    }
  }
  return nodes;
}
function extractImages(payload) {
  return _extractNodesOfType(payload, "figma-image");
}
function extractAnimations(payload) {
  return _extractNodesOfType(payload, "figma-lottie-animation");
}
async function exportLayer(manager, bus, id, name2, mode, from) {
  if (!_exporting) {
    const loading = manager._getScreen(7 /* loading */);
    manager.renderScreen(loading, manager.root);
    _exporting = true;
    const payload = await bus.execute("exportToFlutter", { id });
    if (payload) {
      switch (mode) {
        case 0 /* json */:
          await _downloadExport(name2, payload);
          break;
        case 1 /* strapiUpload */:
          await uploadToStrapi(bus, name2, payload);
          break;
        case 2 /* githubCommit */:
          await commitToGithub(bus, name2, payload, from._manager.github);
          break;
        default:
          throw "not implemented";
      }
    }
    manager.renderScreen(from, manager.root);
    _exporting = false;
  }
}

// src/ui/widgets/lottie.ts
var import_lottie_web = __toESM(require_lottie());

// node_modules/lit-html/directives/unsafe-html.js
var e3 = class extends i2 {
  constructor(i4) {
    if (super(i4), this.et = T, i4.type !== t2.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(r3) {
    if (r3 === T || null == r3)
      return this.vt = void 0, this.et = r3;
    if (r3 === w)
      return r3;
    if ("string" != typeof r3)
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (r3 === this.et)
      return this.vt;
    this.et = r3;
    const s2 = [r3];
    return s2.raw = s2, this.vt = { _$litType$: this.constructor.resultType, strings: s2, values: [] };
  }
};
e3.directiveName = "unsafeHTML", e3.resultType = 1;
var o2 = e2(e3);

// src/ui/widgets/lottie.ts
function lottiePlayer(bus, data2) {
  var _a3, _b, _c, _d;
  const container = document.createElement("div");
  container.classList.add("lottie-animation");
  const animationData2 = data2.fields.data.value;
  const animation = import_lottie_web.default.loadAnimation({
    container,
    renderer: "svg",
    loop: true,
    autoplay: false,
    animationData: JSON.parse(animationData2)
  });
  const animationTotalFrames = animation.totalFrames - 1;
  let fromFrame = (_b = (_a3 = data2.fields.from.value) != null ? _a3 : data2.fields.from.default) != null ? _b : 0;
  let toFrame = (_d = (_c = data2.fields.to.value) != null ? _c : data2.fields.to.default) != null ? _d : 0;
  const progress = document.createElement("div");
  progress.classList.add("lottie-play-progress");
  progress.style.width = "0";
  const inputRow = document.createElement("div");
  inputRow.classList.add("row-full");
  const inputTemplate = x`
        ${numberInput({
    id: `${data2.type}_${data2.name}_from`,
    label: data2.fields.from.description,
    icon: "F",
    value: fromFrame,
    onUpdate: async (id, value2) => {
      const frame = Math.max(0, Math.min(animationTotalFrames, value2));
      updateFrom(frame);
      animation.goToAndStop(0, true);
    }
  })}

        ${numberInput({
    id: `${data2.type}_${data2.name}_to`,
    label: data2.fields.to.description,
    icon: "T",
    value: toFrame,
    onUpdate: async (id, value2) => {
      const frame = Math.max(0, Math.min(animationTotalFrames, value2));
      updateTo(frame);
      animation.goToAndStop(frame - fromFrame, true);
    }
  })}
    `;
  j(inputTemplate, inputRow);
  const fromInput = inputRow.querySelector(`#${data2.type}_${data2.name}_from`);
  const from = document.createElement("div");
  from.classList.add("lottie-play-from");
  from.style.left = `${fromFrame / animationTotalFrames * 100}%`;
  from.addEventListener("mousedown", handleMouseDown);
  const fromArea = document.createElement("div");
  fromArea.classList.add("lottie-play-from-area");
  fromArea.style.width = from.style.left;
  const toInput = inputRow.querySelector(`#${data2.type}_${data2.name}_to`);
  const to = document.createElement("div");
  to.classList.add("lottie-play-to");
  to.style.left = `${toFrame / animationTotalFrames * 100}%`;
  to.addEventListener("mousedown", handleMouseDown);
  const toArea = document.createElement("div");
  toArea.classList.add("lottie-play-to-area");
  toArea.style.width = `${100 - parseFloat(to.style.left)}%`;
  animation.addEventListener("enterFrame", (e5) => {
    progress.style.width = `${Math.round((animation.currentFrame + fromFrame) / animationTotalFrames * 100)}%`;
  });
  const controlButton = document.createElement("div");
  controlButton.classList.add("icon-button");
  j(playButton, controlButton);
  controlButton.addEventListener("click", () => {
    if (animation.isPaused) {
      animation.play();
      j(pauseButton, controlButton);
    } else {
      animation.pause();
      j(playButton, controlButton);
    }
  });
  let barElement = null;
  let fromElement = null;
  let toElement = null;
  let mouseDown = false;
  function percentToFrame(percent) {
    return Math.floor(percent * animationTotalFrames);
  }
  function getTargetFrame(el, evt) {
    const rect = el.getBoundingClientRect();
    const x2 = evt.clientX - rect.left;
    const percent = Math.min(1, Math.max(0, x2 / rect.width));
    return percentToFrame(percent) - fromFrame;
  }
  function handleMouseDown(evt) {
    if (this === from) {
      fromElement = this;
      return;
    } else if (this === to) {
      toElement = this;
      return;
    }
    mouseDown = true;
    barElement = this;
    let targetFrame = getTargetFrame(barElement, evt);
    if (!fromElement && !toElement) {
      targetFrame = Math.max(0, Math.min(animation.totalFrames, targetFrame));
    }
    animation.goToAndStop(targetFrame, true);
    j(playButton, controlButton);
  }
  function handleMouseUp() {
    mouseDown = false;
    barElement = null;
    fromElement = null;
    toElement = null;
  }
  let timeout = null;
  function updateSegment() {
    animation.setSegment(fromFrame, toFrame);
    fromInput.value = `${fromFrame}`;
    toInput.value = `${toFrame}`;
    if (timeout) {
      window.clearTimeout(timeout);
    }
    timeout = window.setTimeout(() => {
      if (data2.onUpdate) {
        data2.onUpdate(data2.id, fromFrame, false, `${data2.type}_${data2.name}_from`);
        data2.onUpdate(data2.id, toFrame, false, `${data2.type}_${data2.name}_to`);
        timeout = null;
      }
    }, 500);
  }
  updateSegment();
  animation.goToAndStop(0, true);
  function updateFrom(value2) {
    const frame = value2 != null ? value2 : percentToFrame(parseFloat(progress.style.width) / 100);
    const percent = frame / animationTotalFrames * 100;
    from.style.left = `${percent}%`;
    fromArea.style.width = `${percent}%`;
    fromFrame = frame;
    if (fromFrame > toFrame) {
      updateTo(value2);
    } else {
      updateSegment();
    }
  }
  function updateTo(value2) {
    const frame = value2 != null ? value2 : percentToFrame(parseFloat(progress.style.width) / 100);
    const percent = frame / animationTotalFrames * 100;
    to.style.left = `${percent}%`;
    toArea.style.width = `${100 - percent}%`;
    toFrame = frame;
    if (toFrame < fromFrame) {
      updateFrom(value2);
    } else {
      updateSegment();
    }
  }
  function handleMouseMove(evt) {
    if (mouseDown && barElement) {
      let targetFrame = getTargetFrame(barElement, evt);
      if (!fromElement && !toElement) {
        targetFrame = Math.max(0, Math.min(animation.totalFrames, targetFrame));
      }
      animation.goToAndStop(targetFrame, true);
      j(playButton, controlButton);
      if (fromElement) {
        updateFrom();
      }
      if (toElement) {
        updateTo();
      }
    }
  }
  document.addEventListener("mouseup", handleMouseUp);
  document.body.addEventListener("mouseleave", handleMouseUp);
  document.addEventListener("mousemove", handleMouseMove);
  return x`
        <div class="lottie-player">
            ${container}
            <div class="lottie-controls">
                ${controlButton}
                <div 
                    class="lottie-play-bar"
                    @mousedown=${handleMouseDown}
                >
                    ${[fromArea, from, toArea, to, progress]}
                </div>
                <div 
                    class="icon-button"
                    @click="${async function() {
    const originalSvg = container.innerHTML;
    const c2 = document.createElement("div");
    j(x`${o2(originalSvg)}`, c2);
    const layerSize = await bus.execute("getLayerSize", data2.id);
    const svgEl = c2.children[0];
    svgEl.setAttribute("width", `${layerSize.width}`);
    svgEl.setAttribute("height", `${layerSize.height}`);
    const svgStr = svgEl.outerHTML;
    await bus.execute("replaceContentsWithSvg", {
      id: data2.id,
      svg: svgStr
    });
  }}"
                >
                    ${placeButton}
                </div>
            </div>
            ${inputRow}
        </div>
    `;
}
function loadFile(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e5) => {
      var _a3;
      resolve((_a3 = e5.target) == null ? void 0 : _a3.result);
    };
    reader.readAsText(file);
  });
}
function lottieInput(bus, data2) {
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = ".json";
  fileInput.style.display = "none";
  fileInput.addEventListener("change", async (e5) => {
    var _a3;
    const file = (_a3 = e5.target.files) == null ? void 0 : _a3[0];
    if (file) {
      const content2 = await loadFile(file);
      if (content2) {
        try {
          const json = JSON.parse(content2);
          const animation = import_lottie_web.default.loadAnimation(
            {
              container: document.createElement("div"),
              renderer: "svg",
              loop: true,
              autoplay: false,
              animationData: json
            }
          );
          const totalFrames = animation.totalFrames;
          animation.destroy();
          if (data2.onUpdate) {
            await data2.onUpdate(data2.id, 0, false, `${data2.type}_${data2.name}_from`);
            await data2.onUpdate(data2.id, totalFrames - 1, false, `${data2.type}_${data2.name}_to`);
            await data2.onUpdate(data2.id, content2, true, `${data2.type}_${data2.name}_data`);
          }
        } catch (_2) {
          console.error("Invalid JSON loaded for lottie animation.");
        }
      }
    }
  });
  return x`
        ${data2.fields.data.value ? x`<div class="row-full">${lottiePlayer(bus, data2)}</div>` : null}
        <div class="row-full">
            <div class="container padding-top-8">
                ${button({
    id: data2.id,
    label: "Load",
    onClick: (id) => fileInput.click()
  })}
            </div>
        </div>
    `;
}

// src/ui/screens/figma/LayerScreen.ts
var LayerScreen = class extends Screen {
  updateTemplate(data2, bus) {
    const template = x`
            ${getHeader(data2.layer.name, 0 /* figma */, bus)}
            <section>
                <div class="row">
                    <div class="text-container bold">Properties</div>
                </div>
                <div class="row">
                    ${textInput({
      id: data2.layer.id,
      label: "Flutter Widget Class Name",
      icon: flutter,
      placeholder: data2.layer.widgetDefault,
      value: data2.layer.widgetOverride,
      onUpdate: async (id, value2) => {
        await bus.execute("updateMetadata", {
          id,
          key: "com.phenoui.layer.widget_override" /* widgetOverride */,
          value: value2
        });
        await bus.execute("updateLayerView", void 0);
      },
      provider: async (value2) => {
        return await bus.execute("getTypeList", {
          search: value2,
          limit: 4
        });
      }
    })}
                </div>
                ${this.getCustomDataFields(bus, data2)}
            </section>
            ${data2.layer.exportable && data2.layer.widgetDefault == "Frame" ? this.resizeButtons(bus, data2.layer.id) : void 0}
            <section>
                <div class="row-full">
                    <div class="container">
                        ${button({
      id: data2.layer.id,
      label: "Export to JSON",
      onClick: async (id) => await exportLayer(this._manager, bus, id, data2.layer.name, 0 /* json */, this)
    })}
                    </div>
                </div>
            </section>
        `;
    this.template = [template];
    return this.template;
  }
  _makeRow(bus, layerId, layerType, name2, content2) {
    if (Array.isArray(content2)) {
      return x`
                <div class="row">
                    ${content2.map((item) => this._getUserField(bus, layerId, layerType, item.key, item.value))}
                </div>
            `;
    }
    switch (content2.type) {
      case "group":
        return x`
                    <div class="group-container">
                        <div class="row-full">
                            ${this._getUserField(bus, layerId, layerType, name2, content2)}
                        </div>
                    </div>
                `;
      case "union":
        return this._getUserField(bus, layerId, layerType, name2, content2);
      default:
        return x`
                    <div class="row">
                        ${this._getUserField(bus, layerId, layerType, name2, content2)}
                    </div>
                `;
    }
  }
  getCustomDataFields(bus, data2) {
    if (data2.layer.typeData && data2.layer.typeData.userData) {
      const userData = data2.layer.typeData.userData;
      const rows = [];
      const layerType = data2.layer.widgetOverride || data2.layer.widgetDefault;
      const keys = Object.keys(userData);
      if ("__layout__" in userData) {
        for (const row of userData["__layout__"]) {
          if (Array.isArray(row)) {
            const items = row.map((key2) => ({ key: key2, value: userData[key2] }));
            rows.push(this._makeRow(bus, data2.layer.id, layerType, "", items));
          } else {
            rows.push(this._makeRow(bus, data2.layer.id, layerType, row, userData[row]));
          }
        }
      } else {
        keys.sort((a3, b2) => {
          const aV = userData[a3];
          const bV = userData[b2];
          if (aV.type === "group") {
            return 1;
          } else if (bV.type === "group") {
            return -1;
          } else if (aV.type === "componentProperty" && bV.type !== "componentProperty") {
            return 1;
          } else if (aV.type !== "componentProperty" && bV.type === "componentProperty") {
            return -1;
          } else if (aV.type !== "componentProperty" && bV.type !== "componentProperty") {
            return 0;
          } else {
            return aV.propertyId > bV.propertyId ? 1 : -1;
          }
        });
        for (const key2 of keys) {
          rows.push(this._makeRow(bus, data2.layer.id, layerType, key2, userData[key2]));
        }
      }
      return rows;
    }
    return T;
  }
  _getUserField(bus, layerID, widgetType, name2, data2) {
    var _a3, _b, _c, _d;
    const key2 = `${widgetType}_${name2}`;
    const onUpdate = async (_id, value2, refreshLayerView, keyOverride) => {
      await bus.execute("updateMetadata", {
        id: layerID,
        key: keyOverride != null ? keyOverride : key2,
        value: value2
      });
      if (refreshLayerView) {
        await bus.execute("updateLayerView", void 0);
      }
    };
    const onUpdateComponentProperty = async (_id, value2) => {
      await bus.execute("updateComponentProperty", {
        id: layerID,
        key: data2.key,
        value: value2
      });
    };
    const onUpdatePropertyBinding = async (_id, value2) => {
      await bus.execute("updateMetadata", {
        id: layerID,
        key: key2,
        value: {
          type: "binding",
          id: value2
        }
      });
      await bus.execute("updateLayerView", void 0);
    };
    const type = data2.type === "union" ? data2.handler : data2.type;
    const anyData = data2;
    switch (type) {
      case "string": {
        const inputData = {
          id: key2,
          label: data2.description,
          icon: name2.charAt(0).toUpperCase(),
          placeholder: anyData.default || data2.description,
          value: data2.value,
          properties: anyData.properties,
          onUpdate,
          onUpdatePropertyBinding
        };
        if (data2.value !== null && typeof data2.value === "object" && !Array.isArray(data2.value)) {
          return boundedPropertyInput(inputData);
        }
        return textInput(inputData);
      }
      case "boolean": {
        const inputData = {
          id: key2,
          label: data2.description,
          icon: name2.charAt(0).toUpperCase(),
          placeholder: data2.description,
          value: (_b = (_a3 = data2.value) != null ? _a3 : anyData.default) != null ? _b : void 0,
          properties: anyData.properties,
          onUpdate,
          onUpdatePropertyBinding
        };
        if (data2.value !== null && typeof data2.value === "object" && !Array.isArray(data2.value)) {
          return boundedPropertyInput(inputData);
        }
        return booleanInput(inputData);
      }
      case "number":
        return numberInput({
          id: key2,
          label: data2.description,
          icon: name2.charAt(0).toUpperCase(),
          value: (_d = (_c = data2.value) != null ? _c : anyData.default) != null ? _d : void 0,
          onUpdate
        });
      case "select":
        return selectInput({
          id: key2,
          label: data2.description,
          icon: name2.charAt(0).toUpperCase(),
          value: data2.value || anyData.default || void 0,
          options: anyData.options,
          onUpdate
        });
      case "group":
        return groupInput({
          id: key2,
          name: name2,
          label: data2.description,
          icon: "{;}",
          value: data2.value || { type: "group", properties: anyData.default || [] },
          onUpdate,
          onUpdatePropertyBinding
        });
      case "componentProperty":
        if (anyData.valueType === "TEXT") {
          return textInput({
            id: key2,
            label: data2.description,
            icon: name2.charAt(0).toUpperCase(),
            placeholder: data2.description,
            value: data2.value,
            onUpdate: onUpdateComponentProperty
          });
        } else if (anyData.valueType === "BOOLEAN") {
          return booleanInput({
            id: key2,
            label: data2.description,
            icon: name2.charAt(0).toUpperCase(),
            placeholder: data2.description,
            value: data2.value,
            onUpdate: onUpdateComponentProperty
          });
        } else if (anyData.valueType === "VARIANT") {
          return selectInput({
            id: key2,
            label: data2.description,
            icon: name2.charAt(0).toUpperCase(),
            value: data2.value || anyData.default || void 0,
            options: anyData.options,
            onUpdate: onUpdateComponentProperty
          });
        }
        return x`<div class="error-description">ERROR: Unknown component [${data2.type}] valueType [${anyData.valueType}]</div>`;
      case "lottie":
        return lottieInput(bus, {
          id: layerID,
          name: name2,
          type: widgetType,
          description: data2.description,
          fields: anyData.fields,
          onUpdate
        });
      default:
        return x`
                    <div class="error-description">ERROR: Unknown type [${data2.type}]</div>
                `;
    }
  }
  resizeButtons(bus, id) {
    return x`
            <section>
                <div class="row">
                    <div class="text-container bold">Resize</div>
                </div>
                <div class="row">
                    ${selectInput({
      id,
      label: "Resize Frame",
      icon: "R",
      value: void 0,
      options: [
        { value: "", label: "" },
        { value: "iPhone", label: "iPhone" },
        { value: "iPhonePlus", label: "iPhone Plus" },
        { value: "iPad", label: "iPad" },
        { value: "iPadPro", label: "iPad Pro" },
        { value: "iPadMini", label: "iPad Mini" },
        { value: "iPadLS", label: "iPad Landscape" },
        { value: "iPadProLS", label: "iPad Pro Landscape" },
        { value: "iPadMiniLS", label: "iPad Mini Landscape" }
      ],
      onUpdate: async (id2, value2) => await this.resizeFrame(bus, id2, value2)
    })}
                </div>
            </section>
        `;
  }
  async resizeFrame(bus, id, key2) {
    const sizeMap = {
      iPhone: { width: 393, height: 852 },
      iPhonePlus: { width: 430, height: 932 },
      iPad: { width: 834, height: 1194 },
      iPadPro: { width: 1024, height: 1366 },
      iPadMini: { width: 744, height: 1133 },
      iPadLS: { width: 1194, height: 834 },
      iPadProLS: { width: 1366, height: 1024 },
      iPadMiniLS: { width: 1133, height: 744 }
    };
    if (key2 && key2 in sizeMap) {
      await bus.execute("resizeLayer", {
        id,
        width: sizeMap[key2].width,
        height: sizeMap[key2].height
      });
    }
  }
};

// src/ui/screens/strapi/LayerScreen.ts
var LayerScreen2 = class extends Screen {
  async updateTemplate(data2, bus) {
    const template = x`
            ${getHeader(data2.layer.name, 1 /* strapi */, bus)}
            <section>
                <div class="row-full">
                    <div class="container">
                        ${button({
      id: data2.layer.id,
      label: "Upload to strapi",
      onClick: async (id) => await exportLayer(this._manager, bus, id, data2.layer.name, 1 /* strapiUpload */, this),
      disabled: !Boolean(data2.layer.exportable)
    })}
                    </div>
                </div>
            </section>
            <section>
                <div class="row-full">
                    <div class="container">
                        ${button({
      id: data2.layer.id,
      label: "Log out of strapi",
      onClick: async (id) => await bus.execute("strapiLogout", void 0)
    })}
                    </div>
                </div>
                <div class="row-full">
                    <div class="text-container">${await bus.execute("getStrapiServer", void 0)}</div>
                </div>
            </section>
        `;
    this.template = [template];
    return this.template;
  }
};

// src/ui/screens/github/LayerScreen.ts
var LayerScreen3 = class extends Screen {
  constructor() {
    super(...arguments);
    this.exporting = false;
  }
  async updateTemplate(data2, bus) {
    var _a3;
    const template = x`
            ${getHeader(data2.layer.name, 2 /* github */, bus)}
            <section>
                <div class="row-full">
                    <div class="container">
                        ${button({
      id: data2.layer.id,
      label: "Commit to github",
      onClick: async (id) => await exportLayer(this._manager, bus, id, data2.layer.name, 2 /* githubCommit */, this),
      disabled: !Boolean(data2.layer.exportable)
    })}
                    </div>
                </div>
            </section>
            <section>
                <div class="row-full">
                    <div class="container">
                        ${button({
      id: data2.layer.id,
      label: "PR all changes",
      onClick: async () => await this.makeGithubPR()
    })}
                    </div>
                </div>
            </section>
            <section>
                <div class="row-full">
                    <div class="container">
                        ${button({
      id: data2.layer.id,
      label: "Log out of github",
      onClick: async () => {
        await this._manager.github.logout();
        this._manager.updateScreen({
          screen: 2 /* github_login */,
          credentials: {
            id: data2.layer.id,
            layerName: data2.layer.name
          }
        });
      }
    })}
                    </div>
                </div>
                <div class="row-full">
                    <div class="text-container bold">Logged in as:</div><div class="text-container">${(_a3 = await this._manager.github.user) == null ? void 0 : _a3.login}</div>
                </div>
            </section>
        `;
    this.template = [template];
    return this.template;
  }
  async makeGithubPR() {
    var _a3;
    if (!this.exporting) {
      const loading = this._manager._getScreen(7 /* loading */);
      this._manager.renderScreen(loading, this._manager.root);
      this.exporting = true;
      const github2 = this._manager.github;
      await github2.createPullRequest(`[${(_a3 = github2._user) == null ? void 0 : _a3.login.toUpperCase()}] ${Date()}`);
      this._manager.renderScreen(this, this._manager.root);
      this.exporting = false;
    }
  }
};

// src/ui/styles.ts
function getStyles() {
  return [x`
        <style>
            html, body {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                background-color: var(--figma-color-bg);
                color: var(--figma-color-text);
                font-family: Inter, sans-serif;
                font-size: 11px;
                overflow-x: hidden;
                overflow-y: auto
                --webkit-user-drag: none;
                user-select: none;
            }
            
            body {
                scrollbar-gutter: both-edges;
            }

            ::-webkit-scrollbar {
                height: 12px;
                width: 8px;
                background: transparent;
            }

            ::-webkit-scrollbar-thumb {
                background: var(--figma-color-icon-onwarning-secondary);
                /*-webkit-border-radius: 1ex;*/
                border-radius: 1ex;
                border: 1px solid var(--figma-color-border-disabled-strong);
            }

            ::-webkit-scrollbar-corner{
                display: none;
            }
            
            main {
                width: 100%;
                /*height: 100%;*/
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }

            textarea:focus, input:focus{
                outline: none;
            }
            
            section {
                display: flex;
                flex-direction: column;
                align-items: stretch;
                padding: 8px 0;
            }
            
            section + section {
                border-top: 1px solid var(--figma-color-border);
            }
            
            option {
                background-color: var(--figma-color-bg);
                color: var(--figma-color-text);
            }
            
            label {
                user-select: none;
            }
            
            /*svg {*/
            /*    max-width: 14px;*/
            /*    max-height: 14px;*/
            /*}*/
            
            .centered {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                flex-grow: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            
            .container {
                display: flex;
                flex-grow: 1;
                padding: 0 8px;
            }
            
            .padding-top-8 {
                padding-top: 8px;
            }
            
            .logo {
                width: 160px;
                height: auto;
            }
            
            .error-title {
                display: flex;
                justify-content: center;
                flex-grow: 1;
                font-size: 13px;
                font-weight: 600;
                color: var(--figma-color-text-danger);
            }
            
            .error-description {
                font-weight: 400;
                color: var(--figma-color-text-danger-secondary);
            }
            
            .row {
                min-height: 32px;
                display: flex;
                flex-direction: row;
                align-items: center;
                padding: 0 32px 0 8px;
                margin: 2px 0;
            }
            
            .row-full {
                min-height: 32px;
                display: flex;
                flex-direction: row;
                align-items: center;
                padding: 0 8px;
                margin: 2px 0;
            }
            
            .flex-center {
                justify-content: center;
            }
            
            .title {
                text-align: center;
                font-weight: 600;
                flex-grow: 1;
                padding: 0 8px;
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
            }
            
            .label {
                user-select: none;
                font-weight: 600;
            }
            
            .text-container {
                padding: 0 8px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .bold {
                font-weight: 600;
            }
            
            .input-container {
                min-height: 30px;
                position: relative;
                outline: 1px solid transparent;
                display: flex;
                flex-grow: 1;
                align-items: center;
            }
            
            .input-container:hover {
                outline-offset: -1px;
                outline: 1px solid var(--figma-color-border);
            }

            .input-container .unlink-icon {
                visibility: hidden;
            }

            .input-container:hover .unlink-icon {
                visibility: visible;
            }
            
            .input-container:focus-within {
                outline-offset: -2px;
                outline: 2px solid var(--figma-color-border-selected);
            }
            
            .input-icon {
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                fill: var(--figma-color-text-secondary);
                color: var(--figma-color-text-secondary);
                font-weight: 200;
                
                > svg {
                    max-width: 14px;
                    max-height: 14px;
                }
            }

            .text-input {
                width: 100%;
                height: 26px;
                flex-grow: 1;
                border: none;
                background-color: transparent;
                font-family: Inter, sans-serif;
                font-size: 11px;
                color: var(--figma-color-text);
                z-index: 1;
            }
            
            .text-input::placeholder {
                color: var(--figma-color-text-disabled);
            }

            input::-webkit-outer-spin-button,
            input::-webkit-inner-spin-button {
                /* display: none; <- Crashes Chrome on hover */
                -webkit-appearance: none;
                margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
            }
            
            .autocomplete-container {
                position: absolute;
                width: 100%;
                top: 100%;
                left: 0;
                outline-offset: -1px;
                outline: 1px solid var(--figma-color-border);
                margin-top: 4px;
                z-index: 2;
                background-color: var(--figma-color-bg);
            }

            .autocomplete-item + .autocomplete-item {
                border-top: 1px solid var(--figma-color-border);
            }
            
            .autocomplete-item {
                display: flex;
                height: 32px;
                align-items: center;
                padding-left: 33px;
                color: var(--figma-color-text-secondary);
                user-select: none;
            }

            .autocomplete-item:hover {
                color: var(--figma-color-text-hover);
                background-color: var(--figma-color-bg-hover);
            }
            
            .select-input {
                width: 100%;
                height: 26px;
                flex-grow: 1;
                border: none;
                background-color: transparent;
                font-family: Inter, sans-serif;
                font-size: 11px;
                color: var(--figma-color-text);
            }
            
            .select-input:focus {
                outline: none;
            }
            
            .select-link-property {
                position: absolute;
                bottom: -1px;
                right: 0;
                min-width: 23px;
                max-width: 23px;
                height: 100%;
                border: none;
                opacity: 0;
                z-index: 0;
            }

            .select-link-property:focus-within {
                outline: none;
                left: 23px;
                max-width: 100%;
                /*height: 1px;*/
            }

            .bool-input-container {
                display: flex;
                flex-grow: 1;
                width: 100%;
                align-items: center;
                z-index: 1;
            }

            .bool-input {
                margin-right: 6px;
            }
            
            .group-container {
                border-top: 1px solid var(--figma-color-border);
            }
            
            .group-container + :not(.group-container) {
                border-top: 1px solid var(--figma-color-border);
            }
            
            .group-input-container {
                flex-grow: 1;
                display: flex;
                flex-direction: column;
            }

            .group-icon {
                width: 14px;
                height: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
                fill: var(--figma-color-text-secondary);
                color: var(--figma-color-text-secondary);
                font-weight: 200;
                letter-spacing: 1.5px;

                > svg {
                    max-width: 14px;
                    max-height: 14px;
                }
            }
            
            .group-title {
                font-weight: 600;
                margin-left: 6px;
            }
            
            .group-property-container {
                min-height: 32px;
                position: relative;
                border: 1px solid transparent;
                display: flex;
                flex-grow: 1;
                align-items: center;
            }
            
            .icon-button {
                width: 32px;
                height: 32px;
                min-width: 32px;
                min-height: 32px;
                max-width: 32px;
                max-height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                fill: var(--figma-color-icon-secondary);
                background-color: transparent;
                > svg {
                    width: 12px;
                    height: 12px;
                }
            }
            
            .icon-button:hover {
                fill: var(--figma-color-icon-secondary-hover);
                background-color: var(--figma-color-bg-hover);
            }
            
            .button {
                display: flex;
                align-items: center;
                justify-content: center;
                flex-grow: 1;
                background-color: transparent;
                border: none;
                outline: 1px solid var(--figma-color-border-strong);
                outline-offset: -1px;
                border-radius: 6px;
                padding: 0 12px;
            }
            
            .button:focus {
                outline-offset: -2px;
                outline: 2px solid var(--figma-color-border-selected);
            }
            
            .button:enabled:active {
                background-color: var(--figma-color-bg-pressed);
            }
            
            .button:disabled {
                opacity: 0.5;
            }
            
            
            
            .button-label {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 32px;
                color: var(--figma-color-text);
                font-family: Inter, sans-serif;
                font-size: 11px;
                user-select: none;
            }
            
            .loading-animation {
                width: 200px;
                height: 200px;
                
                > svg {
                    max-width: 100%;
                    max-height: 100%;
                }
            }
            
            .lottie-player {
                min-height: 32px;
                position: relative;
                border: 1px solid transparent;
                flex-grow: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 8px;
                margin-bottom: 8px;
            }

            .lottie-player:hover {
                outline-offset: -1px;
                outline: 1px solid var(--figma-color-border);
            }

            .lottie-player:focus-within {
                outline-offset: -2px;
                outline: 2px solid var(--figma-color-border-selected);
            }

            .lottie-animation {
                width: 100px;
                height: 100px;

                > svg {
                    max-width: 100%;
                    max-height: 100%;
                }
            }
            
            .lottie-controls {
                display: flex;
                width: 100%;
                align-items: center;
                justify-content: center;
                height: 32px;
                font-size: 11px;
                font-weight: 600;
            }
            
            .lottie-play-bar {
                position: relative;
                flex-grow: 1;
                height: 100%;
                background-color: var(--figma-color-bg-secondary);
            }
            
            .lottie-play-progress {
                height: 100%;
                background-color: var(--figma-color-bg-selected);
            }
            
            .lottie-play-from {
                position: absolute;
                top: 0;
                height: 100%;
                width: 3px;
                border-right: 1px solid var(--figma-color-bg-component);
                background-color: var(--figma-color-icon);
                transform: translate(-100%, 0);
                cursor: ew-resize;
            }
            
            .lottie-play-from-area {
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                background: repeating-linear-gradient(
                        45deg,
                        var(--figma-color-bg),
                        var(--figma-color-bg) 10px,
                        var(--figma-color-bg-component-tertiary) 10px,
                        var(--figma-color-bg-component-tertiary) 20px
                );
            }

            .lottie-play-to-area {
                position: absolute;
                right: 0;
                top: 0;
                height: 100%;
                background: repeating-linear-gradient(
                        45deg,
                        var(--figma-color-bg),
                        var(--figma-color-bg) 10px,
                        var(--figma-color-bg-component-tertiary) 10px,
                        var(--figma-color-bg-component-tertiary) 20px
                );
                transform: rotate(180deg);
            }
            

            .lottie-play-to {
                position: absolute;
                top: 0;
                height: 100%;
                width: 3px;
                border-left: 1px solid var(--figma-color-bg-component);
                background-color: var(--figma-color-icon);
                cursor: ew-resize;
            }
            
            .tab-container {
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: center;
                height: 32px;
                padding: 0 4px;
            }
            
            .tab-container:hover {
                outline-offset: -1px;
                outline: 1px solid var(--figma-color-border);
            }
            
            .tab-icon {
                width: 18px;
                height: 18px;
                margin: 0 4px;
            }
            
            .tab-title {
                margin: 0 4px;
                user-select: none;
            }
            
            .tab-selected {
                background-color: var(--figma-color-bg-tertiary);
            }
            
            .bound-property-pill-container {
                display: flex;
                flex-grow: 1;
            }
            
            .bound-property-pill {
                height: 100%;
                font-weight: 400;
                box-sizing: border-box;
                margin: 0;
                border: 1px solid transparent;
                border-radius: 14px;
                display: flex;
                align-items: center;
                padding: 4px 8px 4px 2px;
                background-color: var(--figma-color-bg-component-tertiary);
                user-select: none;
            }
            
            .bound-icon {
                height: unset;
                width: 22px;
                fill: var(--figma-color-icon-component);
            }
            
            .unlink-icon:hover {
                background-color: var(--figma-color-bg-hover);
            }
        </style>
    `];
}

// src/ui/widgets/logoPhenoML.ts
var logoPhenoML = x`
    <svg width="100%" height="100%" viewBox="0 0 301 56" xmlns="http://www.w3.org/2000/svg" style="max-width: 100%; max-height: 100%;">
        <g transform="matrix(0.999332,0,0,0.999332,-361.236,-227.047)">
            <g style="fill: var(--figma-color-icon-secondary)">
                <g transform="matrix(0.146711,0,0,0.128088,420.172,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,420.172,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,420.172,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,420.172,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,375.562,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,375.562,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,375.562,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,375.562,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,375.562,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,375.562,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,375.562,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,375.562,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,381.138,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,381.138,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,381.138,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,381.138,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,381.138,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,381.138,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,381.138,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,381.138,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,392.291,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,392.291,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,392.291,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,392.291,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,392.291,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,392.291,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,397.867,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,397.867,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,397.867,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,397.867,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,397.867,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,397.867,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,397.867,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,397.867,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,403.443,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,403.443,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,403.443,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,403.443,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,403.443,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,403.443,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,409.019,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,409.019,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,409.019,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,409.019,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,409.019,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,409.019,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,414.595,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,414.595,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,414.595,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,414.595,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,353.257,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,319.8,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,325.376,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,330.952,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,336.529,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,353.257,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,319.8,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,325.376,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,330.952,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,336.529,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,342.105,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,353.257,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,319.8,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,336.529,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,342.105,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,353.257,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,319.8,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,325.376,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,330.952,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,336.529,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,342.105,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,353.257,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,319.8,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,353.257,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,319.8,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,353.257,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,319.8,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,353.257,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,358.833,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,358.833,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,358.833,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,358.833,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,358.833,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,358.833,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,358.833,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,358.833,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,364.41,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,364.41,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,369.986,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,369.986,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,319.8,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,314.224,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,314.224,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,314.224,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,314.224,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,314.224,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,314.224,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,314.224,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,314.224,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,325.376,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,330.952,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,336.529,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,431.324,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,431.324,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,431.324,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,431.324,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,431.324,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,431.324,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,431.324,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,436.9,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,436.9,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,436.9,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,436.9,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,436.9,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,436.9,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,436.9,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,436.9,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,442.476,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,442.476,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,448.053,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,448.053,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,475.934,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,475.934,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,475.934,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,475.934,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,475.934,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,475.934,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,475.934,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,475.934,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,481.51,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,481.51,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,481.51,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,481.51,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,487.086,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,487.086,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,487.086,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,487.086,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,492.662,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,492.662,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,492.662,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,492.662,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,492.662,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,492.662,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,492.662,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,492.662,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,498.239,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,498.239,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,498.239,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,498.239,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,498.239,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,498.239,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,470.358,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,470.358,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,470.358,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,470.358,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,470.358,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,470.358,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,459.205,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,459.205,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,459.205,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,459.205,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,459.205,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,459.205,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,459.205,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,453.629,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,453.629,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,453.629,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,453.629,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,453.629,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,453.629,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,453.629,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,453.629,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036"/>
                </g>
            </g>
            <g style="fill: var(--figma-color-icon-tertiary)">
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,509.391,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,514.967,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,520.543,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,526.12,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,526.12,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,526.12,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,526.12,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,526.12,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,531.696,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,531.696,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,531.696,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,531.696,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,531.696,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,537.272,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,537.272,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,537.272,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,537.272,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,537.272,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,542.848,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,542.848,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,542.848,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,542.848,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,542.848,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,548.424,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,554.001,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,559.577,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,570.729,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,576.305,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-128.603)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-134.179)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-139.755)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-123.027)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-117.45)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-111.874)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-106.298)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-100.722)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-95.1456)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,581.882,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,587.458,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,593.034,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,598.61,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,604.187,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
                <g transform="matrix(0.146711,0,0,0.128088,609.763,-89.5694)">
                    <rect x="322.087" y="2864.86" width="34.081" height="39.036" />
                </g>
            </g>
        </g>
    </svg>

`;

// src/ui/screens/EmptyScreen.ts
var EmptyScreen = class extends Screen {
  updateTemplate(_data, _bus) {
    const template = x`
            <section class="centered">
                <div class="logo">${logoPhenoML}</div>
                <div class="row-full">
                    <div class="title">select an object to get started</div>
                </div>
                <div class="row-full"></div>
            </section>
        `;
    this.template = [template];
    return this.template;
  }
};

// src/ui/screens/ErrorScreen.ts
var ErrorScreen = class extends Screen {
  updateTemplate(data2, _bus) {
    const template = x`
            <section>
                <div class="row-full"></div>
                <div class="row-full">
                    <div class="error-title">${data2.error.title}</div>
                </div>
                <div class="row-full">
                    <div class="error-description">${data2.error.description}</div>
                </div>
            </section>
        `;
    this.template = [template];
    return this.template;
  }
};

// src/ui/screens/strapi/LoginScreen.ts
var LoginScreen = class extends Screen {
  constructor() {
    super(...arguments);
    this.working = false;
  }
  updateTemplate(data2, bus) {
    const template = x`
            <section>
                <div class="row-full flex-center">
                    <div class="logo">${logoPhenoML}</div>
                </div>
                <div class="row-full">
                    <div class="title">please connect to strapi</div>
                </div>
            </section>
            <section>
                <div class="row">
                    <div class="text-container bold">Credentials</div>
                </div>
                <div class="row">
                    ${textInput({
      id: "server",
      label: "strapi server url",
      icon: "S",
      placeholder: MetadataDefaults["com.phenoui.strapi.auth.server" /* strapiServer */],
      value: data2.credentials.server,
      onUpdate: (_id, value2) => bus.execute("setLocalData", {
        key: "com.phenoui.strapi.auth.server" /* strapiServer */,
        value: value2
      })
    })}
                </div>
                <div class="row">
                    ${textInput({
      id: "user",
      label: "user name",
      icon: "U",
      placeholder: "user name",
      value: data2.credentials.user,
      onUpdate: (id, value2) => bus.execute("setLocalData", {
        key: "com.phenoui.strapi.auth.user" /* strapiUser */,
        value: value2
      })
    })}
                </div>
                <div class="row">
                    ${passwordInput({
      id: "password",
      label: "password",
      icon: "P",
      placeholder: "password"
    })}
                </div>
                <div class="row">
                    ${data2.credentials.error ? x`<div class="error-description">${data2.credentials.error}</div>` : T}
                </div>
                <div class="row">
                    <div class="container">
                        ${button({
      id: data2.credentials.id,
      label: "Login",
      onClick: async (id) => await this._login(id, bus)
    })}
                    </div>
                </div>
            </section>
        `;
    this.template = [template];
    return this.template;
  }
  async _login(_2, bus) {
    if (!this.working) {
      this.working = true;
      const serverElement = document.getElementById("server");
      const userElement = document.getElementById("user");
      const passwordElement = document.getElementById("password");
      if (serverElement && userElement && passwordElement) {
        const loading = this._manager._getScreen(7 /* loading */);
        this._manager.renderScreen(loading, this._manager.root);
        const server = serverElement.value;
        const user = userElement.value;
        const password = passwordElement.value;
        await bus.execute("performStrapiLogin", { server, user, password });
      }
      this.working = false;
    }
  }
};

// src/ui/screens/github/LoginScreen.ts
var LoginScreen2 = class extends Screen {
  constructor() {
    super(...arguments);
    this.working = false;
  }
  updateTemplate(data2, bus) {
    const template = x`
            ${getHeader(data2.credentials.layerName, 2 /* github */, bus)}
            <section>
                <div class="row">
                    <div class="text-container bold">Please login:</div>
                </div>
                <div class="row">
                    ${passwordInput({
      id: "github-access-token",
      label: "access token",
      icon: "A",
      placeholder: "access token"
    })}
                </div>
            </section>
            <section>
                <div class="row-full">
                    <div class="container">
                        ${button({
      id: data2.credentials.id,
      label: "Login",
      onClick: async (id) => await this._login(id, bus, data2)
    })}
                    </div>
                </div>
                <div class="row">
                    ${data2.credentials.error ? x`<div class="error-description">${data2.credentials.error}</div>` : T}
                </div>
            </section>
        `;
    this.template = [template];
    return this.template;
  }
  async _login(_2, bus, data2) {
    if (!this.working) {
      this.working = true;
      try {
        const tokenElement = document.getElementById("github-access-token");
        const token = tokenElement.value;
        const loading = this._manager._getScreen(7 /* loading */);
        this._manager.renderScreen(loading, this._manager.root);
        const success = await this._manager.github.login(token);
        if (success) {
          await bus.execute("updateLayerView", void 0);
        } else {
          this._manager.updateScreen({
            screen: 2 /* github_login */,
            credentials: {
              id: data2.credentials.id,
              layerName: data2.credentials.layerName,
              error: "Invalid access token"
            }
          });
        }
      } catch (e5) {
        this._manager.updateScreen({
          screen: 2 /* github_login */,
          credentials: {
            id: data2.credentials.id,
            layerName: data2.credentials.layerName,
            error: e5.message
          }
        });
      }
      this.working = false;
    }
  }
};

// src/ui/screens/LoadingScreen.ts
var import_lottie_web2 = __toESM(require_lottie());

// src/ui/svg/loading_animation.json
var loading_animation_default = { v: "5.7.4", fr: 60, ip: 0, op: 80, w: 800, h: 600, nm: "Anim3", ddd: 0, assets: [], layers: [{ ddd: 0, ind: 1, ty: 4, nm: "circle3", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [300.03, 299.995, 0], ix: 2, l: 2 }, a: { a: 0, k: [-39.97, 5e-3, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, -100, 100], ix: 6, l: 2 } }, ao: 0, ef: [{ ty: 5, nm: "Elastic: Position - Transform", np: 5, mn: "Pseudo/MDS Elastic Controller", ix: 1, en: 1, ef: [{ ty: 0, nm: "Amplitude", mn: "Pseudo/MDS Elastic Controller-0001", ix: 1, v: { a: 0, k: 20, ix: 1 } }, { ty: 0, nm: "Frequency", mn: "Pseudo/MDS Elastic Controller-0002", ix: 2, v: { a: 0, k: 40, ix: 2 } }, { ty: 0, nm: "Decay", mn: "Pseudo/MDS Elastic Controller-0003", ix: 3, v: { a: 0, k: 60, ix: 3 } }] }, { ty: 5, nm: "Elastic: Scale - Transform", np: 5, mn: "Pseudo/MDS Elastic Controller", ix: 2, en: 1, ef: [{ ty: 0, nm: "Amplitude", mn: "Pseudo/MDS Elastic Controller-0001", ix: 1, v: { a: 0, k: 20, ix: 1 } }, { ty: 0, nm: "Frequency", mn: "Pseudo/MDS Elastic Controller-0002", ix: 2, v: { a: 0, k: 40, ix: 2 } }, { ty: 0, nm: "Decay", mn: "Pseudo/MDS Elastic Controller-0003", ix: 3, v: { a: 0, k: 60, ix: 3 } }] }], shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 22.091], [22.091, 0], [0, -22.091]], o: [[0, -22.091], [-22.091, 0], [0, 22.091]], v: [[80, 0], [40, -40], [0, 0]], c: false }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: false }, { ty: "tm", s: { a: 1, k: [{ i: { x: [0.15], y: [1] }, o: { x: [0.15], y: [0] }, t: 6, s: [0] }, { t: 36, s: [99.9] }], ix: 1 }, e: { a: 1, k: [{ i: { x: [0.15], y: [1] }, o: { x: [0.15], y: [0] }, t: 0, s: [0.1] }, { t: 30, s: [100] }], ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Trim Paths 1", mn: "ADBE Vector Filter - Trim", hd: false }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 1, k: [{ i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 0, s: [20] }, { i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 6, s: [30] }, { t: 36, s: [20] }], ix: 5 }, lc: 2, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: false }, { ty: "tr", p: { a: 1, k: [{ i: { x: 0.667, y: 1 }, o: { x: 0.333, y: 0 }, t: 0, s: [80, -0.126], to: [0, -3.312], ti: [0, 0] }, { i: { x: 0.833, y: 0.829 }, o: { x: 0.333, y: 0 }, t: 10, s: [80, -20], to: [0, 0], ti: [0, -3.577] }, { i: { x: 0.833, y: 0.875 }, o: { x: 0.167, y: 0.136 }, t: 20, s: [80, -0.126], to: [0, 3.577], ti: [0, -0.475] }, { i: { x: 0.833, y: 0.853 }, o: { x: 0.167, y: 0.248 }, t: 21, s: [80, 1.464], to: [0, 0.475], ti: [0, -0.369] }, { i: { x: 0.833, y: 0.857 }, o: { x: 0.167, y: 0.193 }, t: 22, s: [80, 2.723], to: [0, 0.369], ti: [0, -0.273] }, { i: { x: 0.833, y: 0.863 }, o: { x: 0.167, y: 0.2 }, t: 23, s: [80, 3.677], to: [0, 0.273], ti: [0, -0.186] }, { i: { x: 0.833, y: 0.873 }, o: { x: 0.167, y: 0.213 }, t: 24, s: [80, 4.358], to: [0, 0.186], ti: [0, -0.111] }, { i: { x: 0.833, y: 0.897 }, o: { x: 0.167, y: 0.244 }, t: 25, s: [80, 4.795], to: [0, 0.111], ti: [0, -0.046] }, { i: { x: 0.833, y: 0.762 }, o: { x: 0.167, y: 0.438 }, t: 26, s: [80, 5.022], to: [0, 0.046], ti: [0, 8e-3] }, { i: { x: 0.833, y: 0.734 }, o: { x: 0.167, y: 0.129 }, t: 27, s: [80, 5.07], to: [0, -8e-3], ti: [0, 0.053] }, { i: { x: 0.833, y: 0.798 }, o: { x: 0.167, y: 0.121 }, t: 28, s: [80, 4.971], to: [0, -0.053], ti: [0, 0.087] }, { i: { x: 0.833, y: 0.815 }, o: { x: 0.167, y: 0.142 }, t: 29, s: [80, 4.755], to: [0, -0.087], ti: [0, 0.114] }, { i: { x: 0.833, y: 0.823 }, o: { x: 0.167, y: 0.152 }, t: 30, s: [80, 4.447], to: [0, -0.114], ti: [0, 0.132] }, { i: { x: 0.833, y: 0.828 }, o: { x: 0.167, y: 0.158 }, t: 31, s: [80, 4.073], to: [0, -0.132], ti: [0, 0.144] }, { i: { x: 0.833, y: 0.832 }, o: { x: 0.167, y: 0.162 }, t: 32, s: [80, 3.655], to: [0, -0.144], ti: [0, 0.149] }, { i: { x: 0.833, y: 0.834 }, o: { x: 0.167, y: 0.165 }, t: 33, s: [80, 3.212], to: [0, -0.149], ti: [0, 0.15] }, { i: { x: 0.833, y: 0.836 }, o: { x: 0.167, y: 0.168 }, t: 34, s: [80, 2.76], to: [0, -0.15], ti: [0, 0.146] }, { i: { x: 0.833, y: 0.838 }, o: { x: 0.167, y: 0.17 }, t: 35, s: [80, 2.313], to: [0, -0.146], ti: [0, 0.14] }, { i: { x: 0.833, y: 0.84 }, o: { x: 0.167, y: 0.172 }, t: 36, s: [80, 1.882], to: [0, -0.14], ti: [0, 0.13] }, { i: { x: 0.833, y: 0.841 }, o: { x: 0.167, y: 0.174 }, t: 37, s: [80, 1.476], to: [0, -0.13], ti: [0, 0.119] }, { i: { x: 0.833, y: 0.843 }, o: { x: 0.167, y: 0.175 }, t: 38, s: [80, 1.1], to: [0, -0.119], ti: [0, 0.107] }, { i: { x: 0.833, y: 0.844 }, o: { x: 0.167, y: 0.177 }, t: 39, s: [80, 0.76], to: [0, -0.107], ti: [0, 0.094] }, { i: { x: 0.833, y: 0.846 }, o: { x: 0.167, y: 0.179 }, t: 40, s: [80, 0.458], to: [0, -0.094], ti: [0, 0.081] }, { i: { x: 0.833, y: 0.847 }, o: { x: 0.167, y: 0.181 }, t: 41, s: [80, 0.195], to: [0, -0.081], ti: [0, 0.068] }, { i: { x: 0.833, y: 0.849 }, o: { x: 0.167, y: 0.184 }, t: 42, s: [80, -0.028], to: [0, -0.068], ti: [0, 0.056] }, { i: { x: 0.833, y: 0.852 }, o: { x: 0.167, y: 0.187 }, t: 43, s: [80, -0.214], to: [0, -0.056], ti: [0, 0.044] }, { i: { x: 0.833, y: 0.855 }, o: { x: 0.167, y: 0.191 }, t: 44, s: [80, -0.364], to: [0, -0.044], ti: [0, 0.034] }, { i: { x: 0.833, y: 0.86 }, o: { x: 0.167, y: 0.196 }, t: 45, s: [80, -0.48], to: [0, -0.034], ti: [0, 0.024] }, { i: { x: 0.833, y: 0.867 }, o: { x: 0.167, y: 0.206 }, t: 46, s: [80, -0.566], to: [0, -0.024], ti: [0, 0.016] }, { i: { x: 0.833, y: 0.883 }, o: { x: 0.167, y: 0.224 }, t: 47, s: [80, -0.624], to: [0, -0.016], ti: [0, 8e-3] }, { i: { x: 0.833, y: 0.889 }, o: { x: 0.167, y: 0.288 }, t: 48, s: [80, -0.659], to: [0, -8e-3], ti: [0, 2e-3] }, { i: { x: 0.833, y: 0.612 }, o: { x: 0.167, y: 0.336 }, t: 49, s: [80, -0.673], to: [0, -2e-3], ti: [0, -3e-3] }, { i: { x: 0.833, y: 0.78 }, o: { x: 0.167, y: 0.106 }, t: 50, s: [80, -0.67], to: [0, 3e-3], ti: [0, -8e-3] }, { i: { x: 0.833, y: 0.809 }, o: { x: 0.167, y: 0.134 }, t: 51, s: [80, -0.653], to: [0, 8e-3], ti: [0, -0.011] }, { i: { x: 0.833, y: 0.82 }, o: { x: 0.167, y: 0.148 }, t: 52, s: [80, -0.625], to: [0, 0.011], ti: [0, -0.013] }, { i: { x: 0.833, y: 0.826 }, o: { x: 0.167, y: 0.155 }, t: 53, s: [80, -0.589], to: [0, 0.013], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.83 }, o: { x: 0.167, y: 0.16 }, t: 54, s: [80, -0.547], to: [0, 0.015], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.833 }, o: { x: 0.167, y: 0.164 }, t: 55, s: [80, -0.501], to: [0, 0.015], ti: [0, -0.016] }, { i: { x: 0.833, y: 0.835 }, o: { x: 0.167, y: 0.166 }, t: 56, s: [80, -0.454], to: [0, 0.016], ti: [0, -0.016] }, { i: { x: 0.833, y: 0.833 }, o: { x: 0.167, y: 0.169 }, t: 57, s: [80, -0.406], to: [0, 0.016], ti: [0, -8e-3] }, { t: 58, s: [80, -0.36] }], ix: 2 }, a: { a: 0, k: [80, -0.126], ix: 1 }, s: { a: 1, k: [{ i: { x: [0.667, 0.667], y: [1, 1] }, o: { x: [0.333, 0.333], y: [0, 0] }, t: 0, s: [100, 100] }, { i: { x: [0.833, 0.833], y: [0.836, 0.836] }, o: { x: [0.333, 0.333], y: [0, 0] }, t: 10, s: [110, 110] }, { i: { x: [0.833, 0.833], y: [0.851, 0.851] }, o: { x: [0.167, 0.167], y: [0.203, 0.203] }, t: 20, s: [100, 100] }, { i: { x: [0.833, 0.833], y: [0.853, 0.853] }, o: { x: [0.167, 0.167], y: [0.189, 0.189] }, t: 21, s: [99.193, 99.193] }, { i: { x: [0.833, 0.833], y: [0.857, 0.857] }, o: { x: [0.167, 0.167], y: [0.193, 0.193] }, t: 22, s: [98.553, 98.553] }, { i: { x: [0.833, 0.833], y: [0.863, 0.863] }, o: { x: [0.167, 0.167], y: [0.2, 0.2] }, t: 23, s: [98.068, 98.068] }, { i: { x: [0.833, 0.833], y: [0.873, 0.873] }, o: { x: [0.167, 0.167], y: [0.213, 0.213] }, t: 24, s: [97.722, 97.722] }, { i: { x: [0.833, 0.833], y: [0.899, 0.899] }, o: { x: [0.167, 0.167], y: [0.244, 0.244] }, t: 25, s: [97.5, 97.5] }, { i: { x: [0.833, 0.833], y: [1.087, 1.087] }, o: { x: [0.167, 0.167], y: [0.473, 0.473] }, t: 26, s: [97.385, 97.385] }, { i: { x: [0.833, 0.833], y: [0.734, 0.734] }, o: { x: [0.167, 0.167], y: [0.042, 0.042] }, t: 27, s: [97.36, 97.36] }, { i: { x: [0.833, 0.833], y: [0.798, 0.798] }, o: { x: [0.167, 0.167], y: [0.121, 0.121] }, t: 28, s: [97.41, 97.41] }, { i: { x: [0.833, 0.833], y: [0.815, 0.815] }, o: { x: [0.167, 0.167], y: [0.142, 0.142] }, t: 29, s: [97.521, 97.521] }, { i: { x: [0.833, 0.833], y: [0.823, 0.823] }, o: { x: [0.167, 0.167], y: [0.152, 0.152] }, t: 30, s: [97.677, 97.677] }, { i: { x: [0.833, 0.833], y: [0.828, 0.828] }, o: { x: [0.167, 0.167], y: [0.158, 0.158] }, t: 31, s: [97.867, 97.867] }, { i: { x: [0.833, 0.833], y: [0.832, 0.832] }, o: { x: [0.167, 0.167], y: [0.162, 0.162] }, t: 32, s: [98.079, 98.079] }, { i: { x: [0.833, 0.833], y: [0.834, 0.834] }, o: { x: [0.167, 0.167], y: [0.165, 0.165] }, t: 33, s: [98.304, 98.304] }, { i: { x: [0.833, 0.833], y: [0.836, 0.836] }, o: { x: [0.167, 0.167], y: [0.168, 0.168] }, t: 34, s: [98.534, 98.534] }, { i: { x: [0.833, 0.833], y: [0.838, 0.838] }, o: { x: [0.167, 0.167], y: [0.17, 0.17] }, t: 35, s: [98.761, 98.761] }, { i: { x: [0.833, 0.833], y: [0.84, 0.84] }, o: { x: [0.167, 0.167], y: [0.172, 0.172] }, t: 36, s: [98.98, 98.98] }, { i: { x: [0.833, 0.833], y: [0.841, 0.841] }, o: { x: [0.167, 0.167], y: [0.174, 0.174] }, t: 37, s: [99.186, 99.186] }, { i: { x: [0.833, 0.833], y: [0.843, 0.843] }, o: { x: [0.167, 0.167], y: [0.175, 0.175] }, t: 38, s: [99.377, 99.377] }, { i: { x: [0.833, 0.833], y: [0.844, 0.844] }, o: { x: [0.167, 0.167], y: [0.177, 0.177] }, t: 39, s: [99.55, 99.55] }, { i: { x: [0.833, 0.833], y: [0.846, 0.846] }, o: { x: [0.167, 0.167], y: [0.179, 0.179] }, t: 40, s: [99.703, 99.703] }, { i: { x: [0.833, 0.833], y: [0.847, 0.847] }, o: { x: [0.167, 0.167], y: [0.181, 0.181] }, t: 41, s: [99.837, 99.837] }, { i: { x: [0.833, 0.833], y: [0.849, 0.849] }, o: { x: [0.167, 0.167], y: [0.184, 0.184] }, t: 42, s: [99.95, 99.95] }, { i: { x: [0.833, 0.833], y: [0.852, 0.852] }, o: { x: [0.167, 0.167], y: [0.187, 0.187] }, t: 43, s: [100.045, 100.045] }, { i: { x: [0.833, 0.833], y: [0.855, 0.855] }, o: { x: [0.167, 0.167], y: [0.191, 0.191] }, t: 44, s: [100.121, 100.121] }, { i: { x: [0.833, 0.833], y: [0.86, 0.86] }, o: { x: [0.167, 0.167], y: [0.196, 0.196] }, t: 45, s: [100.18, 100.18] }, { i: { x: [0.833, 0.833], y: [0.867, 0.867] }, o: { x: [0.167, 0.167], y: [0.206, 0.206] }, t: 46, s: [100.224, 100.224] }, { i: { x: [0.833, 0.833], y: [0.883, 0.883] }, o: { x: [0.167, 0.167], y: [0.224, 0.224] }, t: 47, s: [100.253, 100.253] }, { i: { x: [0.833, 0.833], y: [0.935, 0.935] }, o: { x: [0.167, 0.167], y: [0.288, 0.288] }, t: 48, s: [100.271, 100.271] }, { i: { x: [0.833, 0.833], y: [0.453, 0.453] }, o: { x: [0.167, 0.167], y: [-0.301, -0.301] }, t: 49, s: [100.278, 100.278] }, { i: { x: [0.833, 0.833], y: [0.78, 0.78] }, o: { x: [0.167, 0.167], y: [0.098, 0.098] }, t: 50, s: [100.276, 100.276] }, { i: { x: [0.833, 0.833], y: [0.809, 0.809] }, o: { x: [0.167, 0.167], y: [0.134, 0.134] }, t: 51, s: [100.268, 100.268] }, { i: { x: [0.833, 0.833], y: [0.82, 0.82] }, o: { x: [0.167, 0.167], y: [0.148, 0.148] }, t: 52, s: [100.254, 100.254] }, { i: { x: [0.833, 0.833], y: [0.826, 0.826] }, o: { x: [0.167, 0.167], y: [0.155, 0.155] }, t: 53, s: [100.235, 100.235] }, { i: { x: [0.833, 0.833], y: [0.83, 0.83] }, o: { x: [0.167, 0.167], y: [0.16, 0.16] }, t: 54, s: [100.214, 100.214] }, { i: { x: [0.833, 0.833], y: [0.833, 0.833] }, o: { x: [0.167, 0.167], y: [0.164, 0.164] }, t: 55, s: [100.191, 100.191] }, { i: { x: [0.833, 0.833], y: [0.835, 0.835] }, o: { x: [0.167, 0.167], y: [0.166, 0.166] }, t: 56, s: [100.167, 100.167] }, { i: { x: [0.833, 0.833], y: [0.833, 0.833] }, o: { x: [0.167, 0.167], y: [0.169, 0.169] }, t: 57, s: [100.142, 100.142] }, { t: 58, s: [100.119, 100.119] }], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 4, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: false }, { ty: "gr", it: [{ ty: "tr", p: { a: 0, k: [80, -0.126], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Group 1", np: 0, cix: 2, bm: 0, ix: 2, mn: "ADBE Vector Group", hd: false }], ip: 0, op: 80, st: 0, bm: 0 }, { ddd: 0, ind: 2, ty: 4, nm: "circle2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [340.03, 299.995, 0], ix: 2, l: 2 }, a: { a: 0, k: [-39.97, 5e-3, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, -100, 100], ix: 6, l: 2 } }, ao: 0, ef: [{ ty: 5, nm: "Elastic: Position - Transform", np: 5, mn: "Pseudo/MDS Elastic Controller", ix: 1, en: 1, ef: [{ ty: 0, nm: "Amplitude", mn: "Pseudo/MDS Elastic Controller-0001", ix: 1, v: { a: 0, k: 20, ix: 1 } }, { ty: 0, nm: "Frequency", mn: "Pseudo/MDS Elastic Controller-0002", ix: 2, v: { a: 0, k: 40, ix: 2 } }, { ty: 0, nm: "Decay", mn: "Pseudo/MDS Elastic Controller-0003", ix: 3, v: { a: 0, k: 60, ix: 3 } }] }, { ty: 5, nm: "Elastic: Scale - Transform", np: 5, mn: "Pseudo/MDS Elastic Controller", ix: 2, en: 1, ef: [{ ty: 0, nm: "Amplitude", mn: "Pseudo/MDS Elastic Controller-0001", ix: 1, v: { a: 0, k: 20, ix: 1 } }, { ty: 0, nm: "Frequency", mn: "Pseudo/MDS Elastic Controller-0002", ix: 2, v: { a: 0, k: 40, ix: 2 } }, { ty: 0, nm: "Decay", mn: "Pseudo/MDS Elastic Controller-0003", ix: 3, v: { a: 0, k: 60, ix: 3 } }] }], shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 22.091], [22.091, 0], [0, -22.091]], o: [[0, -22.091], [-22.091, 0], [0, 22.091]], v: [[80, 0], [40, -40], [0, 0]], c: false }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: false }, { ty: "tm", s: { a: 1, k: [{ i: { x: [0.15], y: [1] }, o: { x: [0.15], y: [0] }, t: 18, s: [0] }, { t: 48, s: [99.9] }], ix: 1 }, e: { a: 1, k: [{ i: { x: [0.15], y: [1] }, o: { x: [0.15], y: [0] }, t: 12, s: [0.1] }, { t: 42, s: [100] }], ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Trim Paths 1", mn: "ADBE Vector Filter - Trim", hd: false }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 1, k: [{ i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 12, s: [20] }, { i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 18, s: [30] }, { t: 48, s: [20] }], ix: 5 }, lc: 2, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: false }, { ty: "tr", p: { a: 1, k: [{ i: { x: 0.667, y: 1 }, o: { x: 0.333, y: 0 }, t: 12, s: [80, -0.126], to: [0, -3.312], ti: [0, 0] }, { i: { x: 0.833, y: 0.829 }, o: { x: 0.333, y: 0 }, t: 22, s: [80, -20], to: [0, 0], ti: [0, -3.577] }, { i: { x: 0.833, y: 0.875 }, o: { x: 0.167, y: 0.136 }, t: 32, s: [80, -0.126], to: [0, 3.577], ti: [0, -0.475] }, { i: { x: 0.833, y: 0.853 }, o: { x: 0.167, y: 0.248 }, t: 33, s: [80, 1.464], to: [0, 0.475], ti: [0, -0.369] }, { i: { x: 0.833, y: 0.857 }, o: { x: 0.167, y: 0.193 }, t: 34, s: [80, 2.723], to: [0, 0.369], ti: [0, -0.273] }, { i: { x: 0.833, y: 0.863 }, o: { x: 0.167, y: 0.2 }, t: 35, s: [80, 3.677], to: [0, 0.273], ti: [0, -0.186] }, { i: { x: 0.833, y: 0.873 }, o: { x: 0.167, y: 0.213 }, t: 36, s: [80, 4.358], to: [0, 0.186], ti: [0, -0.111] }, { i: { x: 0.833, y: 0.897 }, o: { x: 0.167, y: 0.244 }, t: 37, s: [80, 4.795], to: [0, 0.111], ti: [0, -0.046] }, { i: { x: 0.833, y: 0.762 }, o: { x: 0.167, y: 0.438 }, t: 38, s: [80, 5.022], to: [0, 0.046], ti: [0, 8e-3] }, { i: { x: 0.833, y: 0.734 }, o: { x: 0.167, y: 0.129 }, t: 39, s: [80, 5.07], to: [0, -8e-3], ti: [0, 0.053] }, { i: { x: 0.833, y: 0.798 }, o: { x: 0.167, y: 0.121 }, t: 40, s: [80, 4.971], to: [0, -0.053], ti: [0, 0.087] }, { i: { x: 0.833, y: 0.815 }, o: { x: 0.167, y: 0.142 }, t: 41, s: [80, 4.755], to: [0, -0.087], ti: [0, 0.114] }, { i: { x: 0.833, y: 0.823 }, o: { x: 0.167, y: 0.152 }, t: 42, s: [80, 4.447], to: [0, -0.114], ti: [0, 0.132] }, { i: { x: 0.833, y: 0.828 }, o: { x: 0.167, y: 0.158 }, t: 43, s: [80, 4.073], to: [0, -0.132], ti: [0, 0.144] }, { i: { x: 0.833, y: 0.832 }, o: { x: 0.167, y: 0.162 }, t: 44, s: [80, 3.655], to: [0, -0.144], ti: [0, 0.149] }, { i: { x: 0.833, y: 0.834 }, o: { x: 0.167, y: 0.165 }, t: 45, s: [80, 3.212], to: [0, -0.149], ti: [0, 0.15] }, { i: { x: 0.833, y: 0.836 }, o: { x: 0.167, y: 0.168 }, t: 46, s: [80, 2.76], to: [0, -0.15], ti: [0, 0.146] }, { i: { x: 0.833, y: 0.838 }, o: { x: 0.167, y: 0.17 }, t: 47, s: [80, 2.313], to: [0, -0.146], ti: [0, 0.14] }, { i: { x: 0.833, y: 0.84 }, o: { x: 0.167, y: 0.172 }, t: 48, s: [80, 1.882], to: [0, -0.14], ti: [0, 0.13] }, { i: { x: 0.833, y: 0.841 }, o: { x: 0.167, y: 0.174 }, t: 49, s: [80, 1.476], to: [0, -0.13], ti: [0, 0.119] }, { i: { x: 0.833, y: 0.843 }, o: { x: 0.167, y: 0.175 }, t: 50, s: [80, 1.1], to: [0, -0.119], ti: [0, 0.107] }, { i: { x: 0.833, y: 0.844 }, o: { x: 0.167, y: 0.177 }, t: 51, s: [80, 0.76], to: [0, -0.107], ti: [0, 0.094] }, { i: { x: 0.833, y: 0.846 }, o: { x: 0.167, y: 0.179 }, t: 52, s: [80, 0.458], to: [0, -0.094], ti: [0, 0.081] }, { i: { x: 0.833, y: 0.847 }, o: { x: 0.167, y: 0.181 }, t: 53, s: [80, 0.195], to: [0, -0.081], ti: [0, 0.068] }, { i: { x: 0.833, y: 0.849 }, o: { x: 0.167, y: 0.184 }, t: 54, s: [80, -0.028], to: [0, -0.068], ti: [0, 0.056] }, { i: { x: 0.833, y: 0.852 }, o: { x: 0.167, y: 0.187 }, t: 55, s: [80, -0.214], to: [0, -0.056], ti: [0, 0.044] }, { i: { x: 0.833, y: 0.855 }, o: { x: 0.167, y: 0.191 }, t: 56, s: [80, -0.364], to: [0, -0.044], ti: [0, 0.034] }, { i: { x: 0.833, y: 0.86 }, o: { x: 0.167, y: 0.196 }, t: 57, s: [80, -0.48], to: [0, -0.034], ti: [0, 0.024] }, { i: { x: 0.833, y: 0.867 }, o: { x: 0.167, y: 0.206 }, t: 58, s: [80, -0.566], to: [0, -0.024], ti: [0, 0.016] }, { i: { x: 0.833, y: 0.883 }, o: { x: 0.167, y: 0.224 }, t: 59, s: [80, -0.624], to: [0, -0.016], ti: [0, 8e-3] }, { i: { x: 0.833, y: 0.889 }, o: { x: 0.167, y: 0.288 }, t: 60, s: [80, -0.659], to: [0, -8e-3], ti: [0, 2e-3] }, { i: { x: 0.833, y: 0.612 }, o: { x: 0.167, y: 0.336 }, t: 61, s: [80, -0.673], to: [0, -2e-3], ti: [0, -3e-3] }, { i: { x: 0.833, y: 0.78 }, o: { x: 0.167, y: 0.106 }, t: 62, s: [80, -0.67], to: [0, 3e-3], ti: [0, -8e-3] }, { i: { x: 0.833, y: 0.809 }, o: { x: 0.167, y: 0.134 }, t: 63, s: [80, -0.653], to: [0, 8e-3], ti: [0, -0.011] }, { i: { x: 0.833, y: 0.82 }, o: { x: 0.167, y: 0.148 }, t: 64, s: [80, -0.625], to: [0, 0.011], ti: [0, -0.013] }, { i: { x: 0.833, y: 0.826 }, o: { x: 0.167, y: 0.155 }, t: 65, s: [80, -0.589], to: [0, 0.013], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.83 }, o: { x: 0.167, y: 0.16 }, t: 66, s: [80, -0.547], to: [0, 0.015], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.833 }, o: { x: 0.167, y: 0.164 }, t: 67, s: [80, -0.501], to: [0, 0.015], ti: [0, -0.016] }, { i: { x: 0.833, y: 0.835 }, o: { x: 0.167, y: 0.166 }, t: 68, s: [80, -0.454], to: [0, 0.016], ti: [0, -0.016] }, { i: { x: 0.833, y: 0.837 }, o: { x: 0.167, y: 0.169 }, t: 69, s: [80, -0.406], to: [0, 0.016], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.839 }, o: { x: 0.167, y: 0.171 }, t: 70, s: [80, -0.36], to: [0, 0.015], ti: [0, -0.014] }, { i: { x: 0.833, y: 0.84 }, o: { x: 0.167, y: 0.173 }, t: 71, s: [80, -0.316], to: [0, 0.014], ti: [0, -0.013] }, { i: { x: 0.833, y: 0.842 }, o: { x: 0.167, y: 0.174 }, t: 72, s: [80, -0.274], to: [0, 0.013], ti: [0, -0.012] }, { i: { x: 0.833, y: 0.843 }, o: { x: 0.167, y: 0.176 }, t: 73, s: [80, -0.237], to: [0, 0.012], ti: [0, -0.011] }, { i: { x: 0.833, y: 0.833 }, o: { x: 0.167, y: 0.178 }, t: 74, s: [80, -0.203], to: [0, 0.011], ti: [0, -5e-3] }, { t: 75, s: [80, -0.173] }], ix: 2 }, a: { a: 0, k: [80, -0.126], ix: 1 }, s: { a: 1, k: [{ i: { x: [0.667, 0.667], y: [1, 1] }, o: { x: [0.333, 0.333], y: [0, 0] }, t: 12, s: [100, 100] }, { i: { x: [0.833, 0.833], y: [0.836, 0.836] }, o: { x: [0.333, 0.333], y: [0, 0] }, t: 22, s: [110, 110] }, { i: { x: [0.833, 0.833], y: [0.851, 0.851] }, o: { x: [0.167, 0.167], y: [0.203, 0.203] }, t: 32, s: [100, 100] }, { i: { x: [0.833, 0.833], y: [0.853, 0.853] }, o: { x: [0.167, 0.167], y: [0.189, 0.189] }, t: 33, s: [99.193, 99.193] }, { i: { x: [0.833, 0.833], y: [0.857, 0.857] }, o: { x: [0.167, 0.167], y: [0.193, 0.193] }, t: 34, s: [98.553, 98.553] }, { i: { x: [0.833, 0.833], y: [0.863, 0.863] }, o: { x: [0.167, 0.167], y: [0.2, 0.2] }, t: 35, s: [98.068, 98.068] }, { i: { x: [0.833, 0.833], y: [0.873, 0.873] }, o: { x: [0.167, 0.167], y: [0.213, 0.213] }, t: 36, s: [97.722, 97.722] }, { i: { x: [0.833, 0.833], y: [0.899, 0.899] }, o: { x: [0.167, 0.167], y: [0.244, 0.244] }, t: 37, s: [97.5, 97.5] }, { i: { x: [0.833, 0.833], y: [1.087, 1.087] }, o: { x: [0.167, 0.167], y: [0.473, 0.473] }, t: 38, s: [97.385, 97.385] }, { i: { x: [0.833, 0.833], y: [0.734, 0.734] }, o: { x: [0.167, 0.167], y: [0.042, 0.042] }, t: 39, s: [97.36, 97.36] }, { i: { x: [0.833, 0.833], y: [0.798, 0.798] }, o: { x: [0.167, 0.167], y: [0.121, 0.121] }, t: 40, s: [97.41, 97.41] }, { i: { x: [0.833, 0.833], y: [0.815, 0.815] }, o: { x: [0.167, 0.167], y: [0.142, 0.142] }, t: 41, s: [97.521, 97.521] }, { i: { x: [0.833, 0.833], y: [0.823, 0.823] }, o: { x: [0.167, 0.167], y: [0.152, 0.152] }, t: 42, s: [97.677, 97.677] }, { i: { x: [0.833, 0.833], y: [0.828, 0.828] }, o: { x: [0.167, 0.167], y: [0.158, 0.158] }, t: 43, s: [97.867, 97.867] }, { i: { x: [0.833, 0.833], y: [0.832, 0.832] }, o: { x: [0.167, 0.167], y: [0.162, 0.162] }, t: 44, s: [98.079, 98.079] }, { i: { x: [0.833, 0.833], y: [0.834, 0.834] }, o: { x: [0.167, 0.167], y: [0.165, 0.165] }, t: 45, s: [98.304, 98.304] }, { i: { x: [0.833, 0.833], y: [0.836, 0.836] }, o: { x: [0.167, 0.167], y: [0.168, 0.168] }, t: 46, s: [98.534, 98.534] }, { i: { x: [0.833, 0.833], y: [0.838, 0.838] }, o: { x: [0.167, 0.167], y: [0.17, 0.17] }, t: 47, s: [98.761, 98.761] }, { i: { x: [0.833, 0.833], y: [0.84, 0.84] }, o: { x: [0.167, 0.167], y: [0.172, 0.172] }, t: 48, s: [98.98, 98.98] }, { i: { x: [0.833, 0.833], y: [0.841, 0.841] }, o: { x: [0.167, 0.167], y: [0.174, 0.174] }, t: 49, s: [99.186, 99.186] }, { i: { x: [0.833, 0.833], y: [0.843, 0.843] }, o: { x: [0.167, 0.167], y: [0.175, 0.175] }, t: 50, s: [99.377, 99.377] }, { i: { x: [0.833, 0.833], y: [0.844, 0.844] }, o: { x: [0.167, 0.167], y: [0.177, 0.177] }, t: 51, s: [99.55, 99.55] }, { i: { x: [0.833, 0.833], y: [0.846, 0.846] }, o: { x: [0.167, 0.167], y: [0.179, 0.179] }, t: 52, s: [99.703, 99.703] }, { i: { x: [0.833, 0.833], y: [0.847, 0.847] }, o: { x: [0.167, 0.167], y: [0.181, 0.181] }, t: 53, s: [99.837, 99.837] }, { i: { x: [0.833, 0.833], y: [0.849, 0.849] }, o: { x: [0.167, 0.167], y: [0.184, 0.184] }, t: 54, s: [99.95, 99.95] }, { i: { x: [0.833, 0.833], y: [0.852, 0.852] }, o: { x: [0.167, 0.167], y: [0.187, 0.187] }, t: 55, s: [100.045, 100.045] }, { i: { x: [0.833, 0.833], y: [0.855, 0.855] }, o: { x: [0.167, 0.167], y: [0.191, 0.191] }, t: 56, s: [100.121, 100.121] }, { i: { x: [0.833, 0.833], y: [0.86, 0.86] }, o: { x: [0.167, 0.167], y: [0.196, 0.196] }, t: 57, s: [100.18, 100.18] }, { i: { x: [0.833, 0.833], y: [0.867, 0.867] }, o: { x: [0.167, 0.167], y: [0.206, 0.206] }, t: 58, s: [100.224, 100.224] }, { i: { x: [0.833, 0.833], y: [0.883, 0.883] }, o: { x: [0.167, 0.167], y: [0.224, 0.224] }, t: 59, s: [100.253, 100.253] }, { i: { x: [0.833, 0.833], y: [0.935, 0.935] }, o: { x: [0.167, 0.167], y: [0.288, 0.288] }, t: 60, s: [100.271, 100.271] }, { i: { x: [0.833, 0.833], y: [0.453, 0.453] }, o: { x: [0.167, 0.167], y: [-0.301, -0.301] }, t: 61, s: [100.278, 100.278] }, { i: { x: [0.833, 0.833], y: [0.78, 0.78] }, o: { x: [0.167, 0.167], y: [0.098, 0.098] }, t: 62, s: [100.276, 100.276] }, { i: { x: [0.833, 0.833], y: [0.809, 0.809] }, o: { x: [0.167, 0.167], y: [0.134, 0.134] }, t: 63, s: [100.268, 100.268] }, { i: { x: [0.833, 0.833], y: [0.82, 0.82] }, o: { x: [0.167, 0.167], y: [0.148, 0.148] }, t: 64, s: [100.254, 100.254] }, { i: { x: [0.833, 0.833], y: [0.826, 0.826] }, o: { x: [0.167, 0.167], y: [0.155, 0.155] }, t: 65, s: [100.235, 100.235] }, { i: { x: [0.833, 0.833], y: [0.83, 0.83] }, o: { x: [0.167, 0.167], y: [0.16, 0.16] }, t: 66, s: [100.214, 100.214] }, { i: { x: [0.833, 0.833], y: [0.833, 0.833] }, o: { x: [0.167, 0.167], y: [0.164, 0.164] }, t: 67, s: [100.191, 100.191] }, { i: { x: [0.833, 0.833], y: [0.835, 0.835] }, o: { x: [0.167, 0.167], y: [0.166, 0.166] }, t: 68, s: [100.167, 100.167] }, { i: { x: [0.833, 0.833], y: [0.837, 0.837] }, o: { x: [0.167, 0.167], y: [0.169, 0.169] }, t: 69, s: [100.142, 100.142] }, { i: { x: [0.833, 0.833], y: [0.839, 0.839] }, o: { x: [0.167, 0.167], y: [0.171, 0.171] }, t: 70, s: [100.119, 100.119] }, { i: { x: [0.833, 0.833], y: [0.84, 0.84] }, o: { x: [0.167, 0.167], y: [0.173, 0.173] }, t: 71, s: [100.096, 100.096] }, { i: { x: [0.833, 0.833], y: [0.842, 0.842] }, o: { x: [0.167, 0.167], y: [0.174, 0.174] }, t: 72, s: [100.075, 100.075] }, { i: { x: [0.833, 0.833], y: [0.843, 0.843] }, o: { x: [0.167, 0.167], y: [0.176, 0.176] }, t: 73, s: [100.056, 100.056] }, { i: { x: [0.833, 0.833], y: [0.833, 0.833] }, o: { x: [0.167, 0.167], y: [0.178, 0.178] }, t: 74, s: [100.039, 100.039] }, { t: 75, s: [100.024, 100.024] }], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 4, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: false }], ip: 0, op: 80, st: 12, bm: 0 }, { ddd: 0, ind: 3, ty: 4, nm: "circle4", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [460, 300, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ef: [{ ty: 5, nm: "Elastic Controller", np: 5, mn: "Pseudo/MDS Elastic Controller", ix: 1, en: 1, ef: [{ ty: 0, nm: "Amplitude", mn: "Pseudo/MDS Elastic Controller-0001", ix: 1, v: { a: 0, k: 20, ix: 1 } }, { ty: 0, nm: "Frequency", mn: "Pseudo/MDS Elastic Controller-0002", ix: 2, v: { a: 0, k: 40, ix: 2 } }, { ty: 0, nm: "Decay", mn: "Pseudo/MDS Elastic Controller-0003", ix: 3, v: { a: 0, k: 60, ix: 3 } }] }], shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 11.046], [-11.046, 0], [0, -11.046]], o: [[0, -11.046], [11.046, 0], [0, 11.046]], v: [[-80, 0], [-60, -20], [-40, 0]], c: false }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: false }, { ty: "tm", s: { a: 1, k: [{ i: { x: [0.15], y: [1] }, o: { x: [0.15], y: [0] }, t: 24, s: [0] }, { t: 54, s: [99.9] }], ix: 1 }, e: { a: 1, k: [{ i: { x: [0.15], y: [1] }, o: { x: [0.15], y: [0] }, t: 18, s: [0.1] }, { t: 48, s: [100] }], ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Trim Paths 1", mn: "ADBE Vector Filter - Trim", hd: false }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 1, k: [{ i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 18, s: [20] }, { i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 24, s: [25] }, { t: 54, s: [20] }], ix: 5 }, lc: 2, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: false }, { ty: "tr", p: { a: 1, k: [{ i: { x: 0.667, y: 1 }, o: { x: 0.333, y: 0 }, t: 18, s: [80, -0.126], to: [0, -3.312], ti: [0, 0] }, { i: { x: 0.833, y: 0.829 }, o: { x: 0.333, y: 0 }, t: 28, s: [80, -20], to: [0, 0], ti: [0, -3.577] }, { i: { x: 0.833, y: 0.875 }, o: { x: 0.167, y: 0.136 }, t: 38, s: [80, -0.126], to: [0, 3.577], ti: [0, -0.475] }, { i: { x: 0.833, y: 0.853 }, o: { x: 0.167, y: 0.248 }, t: 39, s: [80, 1.464], to: [0, 0.475], ti: [0, -0.369] }, { i: { x: 0.833, y: 0.857 }, o: { x: 0.167, y: 0.193 }, t: 40, s: [80, 2.723], to: [0, 0.369], ti: [0, -0.273] }, { i: { x: 0.833, y: 0.863 }, o: { x: 0.167, y: 0.2 }, t: 41, s: [80, 3.677], to: [0, 0.273], ti: [0, -0.186] }, { i: { x: 0.833, y: 0.873 }, o: { x: 0.167, y: 0.213 }, t: 42, s: [80, 4.358], to: [0, 0.186], ti: [0, -0.111] }, { i: { x: 0.833, y: 0.897 }, o: { x: 0.167, y: 0.244 }, t: 43, s: [80, 4.795], to: [0, 0.111], ti: [0, -0.046] }, { i: { x: 0.833, y: 0.762 }, o: { x: 0.167, y: 0.438 }, t: 44, s: [80, 5.022], to: [0, 0.046], ti: [0, 8e-3] }, { i: { x: 0.833, y: 0.734 }, o: { x: 0.167, y: 0.129 }, t: 45, s: [80, 5.07], to: [0, -8e-3], ti: [0, 0.053] }, { i: { x: 0.833, y: 0.798 }, o: { x: 0.167, y: 0.121 }, t: 46, s: [80, 4.971], to: [0, -0.053], ti: [0, 0.087] }, { i: { x: 0.833, y: 0.815 }, o: { x: 0.167, y: 0.142 }, t: 47, s: [80, 4.755], to: [0, -0.087], ti: [0, 0.114] }, { i: { x: 0.833, y: 0.823 }, o: { x: 0.167, y: 0.152 }, t: 48, s: [80, 4.447], to: [0, -0.114], ti: [0, 0.132] }, { i: { x: 0.833, y: 0.828 }, o: { x: 0.167, y: 0.158 }, t: 49, s: [80, 4.073], to: [0, -0.132], ti: [0, 0.144] }, { i: { x: 0.833, y: 0.832 }, o: { x: 0.167, y: 0.162 }, t: 50, s: [80, 3.655], to: [0, -0.144], ti: [0, 0.149] }, { i: { x: 0.833, y: 0.834 }, o: { x: 0.167, y: 0.165 }, t: 51, s: [80, 3.212], to: [0, -0.149], ti: [0, 0.15] }, { i: { x: 0.833, y: 0.836 }, o: { x: 0.167, y: 0.168 }, t: 52, s: [80, 2.76], to: [0, -0.15], ti: [0, 0.146] }, { i: { x: 0.833, y: 0.838 }, o: { x: 0.167, y: 0.17 }, t: 53, s: [80, 2.313], to: [0, -0.146], ti: [0, 0.14] }, { i: { x: 0.833, y: 0.84 }, o: { x: 0.167, y: 0.172 }, t: 54, s: [80, 1.882], to: [0, -0.14], ti: [0, 0.13] }, { i: { x: 0.833, y: 0.841 }, o: { x: 0.167, y: 0.174 }, t: 55, s: [80, 1.476], to: [0, -0.13], ti: [0, 0.119] }, { i: { x: 0.833, y: 0.843 }, o: { x: 0.167, y: 0.175 }, t: 56, s: [80, 1.1], to: [0, -0.119], ti: [0, 0.107] }, { i: { x: 0.833, y: 0.844 }, o: { x: 0.167, y: 0.177 }, t: 57, s: [80, 0.76], to: [0, -0.107], ti: [0, 0.094] }, { i: { x: 0.833, y: 0.846 }, o: { x: 0.167, y: 0.179 }, t: 58, s: [80, 0.458], to: [0, -0.094], ti: [0, 0.081] }, { i: { x: 0.833, y: 0.847 }, o: { x: 0.167, y: 0.181 }, t: 59, s: [80, 0.195], to: [0, -0.081], ti: [0, 0.068] }, { i: { x: 0.833, y: 0.849 }, o: { x: 0.167, y: 0.184 }, t: 60, s: [80, -0.028], to: [0, -0.068], ti: [0, 0.056] }, { i: { x: 0.833, y: 0.852 }, o: { x: 0.167, y: 0.187 }, t: 61, s: [80, -0.214], to: [0, -0.056], ti: [0, 0.044] }, { i: { x: 0.833, y: 0.855 }, o: { x: 0.167, y: 0.191 }, t: 62, s: [80, -0.364], to: [0, -0.044], ti: [0, 0.034] }, { i: { x: 0.833, y: 0.86 }, o: { x: 0.167, y: 0.196 }, t: 63, s: [80, -0.48], to: [0, -0.034], ti: [0, 0.024] }, { i: { x: 0.833, y: 0.867 }, o: { x: 0.167, y: 0.206 }, t: 64, s: [80, -0.566], to: [0, -0.024], ti: [0, 0.016] }, { i: { x: 0.833, y: 0.883 }, o: { x: 0.167, y: 0.224 }, t: 65, s: [80, -0.624], to: [0, -0.016], ti: [0, 8e-3] }, { i: { x: 0.833, y: 0.889 }, o: { x: 0.167, y: 0.288 }, t: 66, s: [80, -0.659], to: [0, -8e-3], ti: [0, 2e-3] }, { i: { x: 0.833, y: 0.612 }, o: { x: 0.167, y: 0.336 }, t: 67, s: [80, -0.673], to: [0, -2e-3], ti: [0, -3e-3] }, { i: { x: 0.833, y: 0.78 }, o: { x: 0.167, y: 0.106 }, t: 68, s: [80, -0.67], to: [0, 3e-3], ti: [0, -8e-3] }, { i: { x: 0.833, y: 0.809 }, o: { x: 0.167, y: 0.134 }, t: 69, s: [80, -0.653], to: [0, 8e-3], ti: [0, -0.011] }, { i: { x: 0.833, y: 0.82 }, o: { x: 0.167, y: 0.148 }, t: 70, s: [80, -0.625], to: [0, 0.011], ti: [0, -0.013] }, { i: { x: 0.833, y: 0.826 }, o: { x: 0.167, y: 0.155 }, t: 71, s: [80, -0.589], to: [0, 0.013], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.83 }, o: { x: 0.167, y: 0.16 }, t: 72, s: [80, -0.547], to: [0, 0.015], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.833 }, o: { x: 0.167, y: 0.164 }, t: 73, s: [80, -0.501], to: [0, 0.015], ti: [0, -0.016] }, { i: { x: 0.833, y: 0.835 }, o: { x: 0.167, y: 0.166 }, t: 74, s: [80, -0.454], to: [0, 0.016], ti: [0, -0.016] }, { i: { x: 0.833, y: 0.837 }, o: { x: 0.167, y: 0.169 }, t: 75, s: [80, -0.406], to: [0, 0.016], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.839 }, o: { x: 0.167, y: 0.171 }, t: 76, s: [80, -0.36], to: [0, 0.015], ti: [0, -0.014] }, { i: { x: 0.833, y: 0.833 }, o: { x: 0.167, y: 0.173 }, t: 77, s: [80, -0.316], to: [0, 0.014], ti: [0, -7e-3] }, { t: 78, s: [80, -0.274] }], ix: 2 }, a: { a: 0, k: [80, -0.126], ix: 1 }, s: { a: 1, k: [{ i: { x: [0.667, 0.667], y: [1, 1] }, o: { x: [0.333, 0.333], y: [0, 0] }, t: 18, s: [100, 100] }, { i: { x: [0.833, 0.833], y: [0.836, 0.836] }, o: { x: [0.333, 0.333], y: [0, 0] }, t: 28, s: [110, 110] }, { i: { x: [0.833, 0.833], y: [0.851, 0.851] }, o: { x: [0.167, 0.167], y: [0.203, 0.203] }, t: 38, s: [100, 100] }, { i: { x: [0.833, 0.833], y: [0.853, 0.853] }, o: { x: [0.167, 0.167], y: [0.189, 0.189] }, t: 39, s: [99.193, 99.193] }, { i: { x: [0.833, 0.833], y: [0.857, 0.857] }, o: { x: [0.167, 0.167], y: [0.193, 0.193] }, t: 40, s: [98.553, 98.553] }, { i: { x: [0.833, 0.833], y: [0.863, 0.863] }, o: { x: [0.167, 0.167], y: [0.2, 0.2] }, t: 41, s: [98.068, 98.068] }, { i: { x: [0.833, 0.833], y: [0.873, 0.873] }, o: { x: [0.167, 0.167], y: [0.213, 0.213] }, t: 42, s: [97.722, 97.722] }, { i: { x: [0.833, 0.833], y: [0.899, 0.899] }, o: { x: [0.167, 0.167], y: [0.244, 0.244] }, t: 43, s: [97.5, 97.5] }, { i: { x: [0.833, 0.833], y: [1.087, 1.087] }, o: { x: [0.167, 0.167], y: [0.473, 0.473] }, t: 44, s: [97.385, 97.385] }, { i: { x: [0.833, 0.833], y: [0.734, 0.734] }, o: { x: [0.167, 0.167], y: [0.042, 0.042] }, t: 45, s: [97.36, 97.36] }, { i: { x: [0.833, 0.833], y: [0.798, 0.798] }, o: { x: [0.167, 0.167], y: [0.121, 0.121] }, t: 46, s: [97.41, 97.41] }, { i: { x: [0.833, 0.833], y: [0.815, 0.815] }, o: { x: [0.167, 0.167], y: [0.142, 0.142] }, t: 47, s: [97.521, 97.521] }, { i: { x: [0.833, 0.833], y: [0.823, 0.823] }, o: { x: [0.167, 0.167], y: [0.152, 0.152] }, t: 48, s: [97.677, 97.677] }, { i: { x: [0.833, 0.833], y: [0.828, 0.828] }, o: { x: [0.167, 0.167], y: [0.158, 0.158] }, t: 49, s: [97.867, 97.867] }, { i: { x: [0.833, 0.833], y: [0.832, 0.832] }, o: { x: [0.167, 0.167], y: [0.162, 0.162] }, t: 50, s: [98.079, 98.079] }, { i: { x: [0.833, 0.833], y: [0.834, 0.834] }, o: { x: [0.167, 0.167], y: [0.165, 0.165] }, t: 51, s: [98.304, 98.304] }, { i: { x: [0.833, 0.833], y: [0.836, 0.836] }, o: { x: [0.167, 0.167], y: [0.168, 0.168] }, t: 52, s: [98.534, 98.534] }, { i: { x: [0.833, 0.833], y: [0.838, 0.838] }, o: { x: [0.167, 0.167], y: [0.17, 0.17] }, t: 53, s: [98.761, 98.761] }, { i: { x: [0.833, 0.833], y: [0.84, 0.84] }, o: { x: [0.167, 0.167], y: [0.172, 0.172] }, t: 54, s: [98.98, 98.98] }, { i: { x: [0.833, 0.833], y: [0.841, 0.841] }, o: { x: [0.167, 0.167], y: [0.174, 0.174] }, t: 55, s: [99.186, 99.186] }, { i: { x: [0.833, 0.833], y: [0.843, 0.843] }, o: { x: [0.167, 0.167], y: [0.175, 0.175] }, t: 56, s: [99.377, 99.377] }, { i: { x: [0.833, 0.833], y: [0.844, 0.844] }, o: { x: [0.167, 0.167], y: [0.177, 0.177] }, t: 57, s: [99.55, 99.55] }, { i: { x: [0.833, 0.833], y: [0.846, 0.846] }, o: { x: [0.167, 0.167], y: [0.179, 0.179] }, t: 58, s: [99.703, 99.703] }, { i: { x: [0.833, 0.833], y: [0.847, 0.847] }, o: { x: [0.167, 0.167], y: [0.181, 0.181] }, t: 59, s: [99.837, 99.837] }, { i: { x: [0.833, 0.833], y: [0.849, 0.849] }, o: { x: [0.167, 0.167], y: [0.184, 0.184] }, t: 60, s: [99.95, 99.95] }, { i: { x: [0.833, 0.833], y: [0.852, 0.852] }, o: { x: [0.167, 0.167], y: [0.187, 0.187] }, t: 61, s: [100.045, 100.045] }, { i: { x: [0.833, 0.833], y: [0.855, 0.855] }, o: { x: [0.167, 0.167], y: [0.191, 0.191] }, t: 62, s: [100.121, 100.121] }, { i: { x: [0.833, 0.833], y: [0.86, 0.86] }, o: { x: [0.167, 0.167], y: [0.196, 0.196] }, t: 63, s: [100.18, 100.18] }, { i: { x: [0.833, 0.833], y: [0.867, 0.867] }, o: { x: [0.167, 0.167], y: [0.206, 0.206] }, t: 64, s: [100.224, 100.224] }, { i: { x: [0.833, 0.833], y: [0.883, 0.883] }, o: { x: [0.167, 0.167], y: [0.224, 0.224] }, t: 65, s: [100.253, 100.253] }, { i: { x: [0.833, 0.833], y: [0.935, 0.935] }, o: { x: [0.167, 0.167], y: [0.288, 0.288] }, t: 66, s: [100.271, 100.271] }, { i: { x: [0.833, 0.833], y: [0.453, 0.453] }, o: { x: [0.167, 0.167], y: [-0.301, -0.301] }, t: 67, s: [100.278, 100.278] }, { i: { x: [0.833, 0.833], y: [0.78, 0.78] }, o: { x: [0.167, 0.167], y: [0.098, 0.098] }, t: 68, s: [100.276, 100.276] }, { i: { x: [0.833, 0.833], y: [0.809, 0.809] }, o: { x: [0.167, 0.167], y: [0.134, 0.134] }, t: 69, s: [100.268, 100.268] }, { i: { x: [0.833, 0.833], y: [0.82, 0.82] }, o: { x: [0.167, 0.167], y: [0.148, 0.148] }, t: 70, s: [100.254, 100.254] }, { i: { x: [0.833, 0.833], y: [0.826, 0.826] }, o: { x: [0.167, 0.167], y: [0.155, 0.155] }, t: 71, s: [100.235, 100.235] }, { i: { x: [0.833, 0.833], y: [0.83, 0.83] }, o: { x: [0.167, 0.167], y: [0.16, 0.16] }, t: 72, s: [100.214, 100.214] }, { i: { x: [0.833, 0.833], y: [0.833, 0.833] }, o: { x: [0.167, 0.167], y: [0.164, 0.164] }, t: 73, s: [100.191, 100.191] }, { i: { x: [0.833, 0.833], y: [0.835, 0.835] }, o: { x: [0.167, 0.167], y: [0.166, 0.166] }, t: 74, s: [100.167, 100.167] }, { i: { x: [0.833, 0.833], y: [0.837, 0.837] }, o: { x: [0.167, 0.167], y: [0.169, 0.169] }, t: 75, s: [100.142, 100.142] }, { i: { x: [0.833, 0.833], y: [0.839, 0.839] }, o: { x: [0.167, 0.167], y: [0.171, 0.171] }, t: 76, s: [100.119, 100.119] }, { i: { x: [0.833, 0.833], y: [0.833, 0.833] }, o: { x: [0.167, 0.167], y: [0.173, 0.173] }, t: 77, s: [100.096, 100.096] }, { t: 78, s: [100.075, 100.075] }], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 4, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: false }], ip: 0, op: 80, st: 18, bm: 0 }, { ddd: 0, ind: 4, ty: 4, nm: "circle1", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [420, 300, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ef: [{ ty: 5, nm: "Elastic Controller", np: 5, mn: "Pseudo/MDS Elastic Controller", ix: 1, en: 1, ef: [{ ty: 0, nm: "Amplitude", mn: "Pseudo/MDS Elastic Controller-0001", ix: 1, v: { a: 0, k: 20, ix: 1 } }, { ty: 0, nm: "Frequency", mn: "Pseudo/MDS Elastic Controller-0002", ix: 2, v: { a: 0, k: 40, ix: 2 } }, { ty: 0, nm: "Decay", mn: "Pseudo/MDS Elastic Controller-0003", ix: 3, v: { a: 0, k: 60, ix: 3 } }] }], shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 33.137], [-33.137, 0], [0, -33.137]], o: [[0, -33.137], [33.137, 0], [0, 33.137]], v: [[-80, 0], [-20, -60], [40, 0]], c: false }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: false }, { ty: "tm", s: { a: 1, k: [{ i: { x: [0.15], y: [1] }, o: { x: [0.15], y: [0] }, t: 12, s: [0] }, { t: 42, s: [99.9] }], ix: 1 }, e: { a: 1, k: [{ i: { x: [0.15], y: [1] }, o: { x: [0.15], y: [0] }, t: 6, s: [0.1] }, { t: 36, s: [100] }], ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Trim Paths 1", mn: "ADBE Vector Filter - Trim", hd: false }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 1, k: [{ i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 6, s: [20] }, { i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 12, s: [30] }, { t: 42, s: [20] }], ix: 5 }, lc: 2, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: false }, { ty: "tr", p: { a: 1, k: [{ i: { x: 0.667, y: 1 }, o: { x: 0.333, y: 0 }, t: 6, s: [80, -0.126], to: [0, -3.312], ti: [0, 0] }, { i: { x: 0.833, y: 0.829 }, o: { x: 0.333, y: 0 }, t: 16, s: [80, -20], to: [0, 0], ti: [0, -3.577] }, { i: { x: 0.833, y: 0.875 }, o: { x: 0.167, y: 0.136 }, t: 26, s: [80, -0.126], to: [0, 3.577], ti: [0, -0.475] }, { i: { x: 0.833, y: 0.853 }, o: { x: 0.167, y: 0.248 }, t: 27, s: [80, 1.464], to: [0, 0.475], ti: [0, -0.369] }, { i: { x: 0.833, y: 0.857 }, o: { x: 0.167, y: 0.193 }, t: 28, s: [80, 2.723], to: [0, 0.369], ti: [0, -0.273] }, { i: { x: 0.833, y: 0.863 }, o: { x: 0.167, y: 0.2 }, t: 29, s: [80, 3.677], to: [0, 0.273], ti: [0, -0.186] }, { i: { x: 0.833, y: 0.873 }, o: { x: 0.167, y: 0.213 }, t: 30, s: [80, 4.358], to: [0, 0.186], ti: [0, -0.111] }, { i: { x: 0.833, y: 0.897 }, o: { x: 0.167, y: 0.244 }, t: 31, s: [80, 4.795], to: [0, 0.111], ti: [0, -0.046] }, { i: { x: 0.833, y: 0.762 }, o: { x: 0.167, y: 0.438 }, t: 32, s: [80, 5.022], to: [0, 0.046], ti: [0, 8e-3] }, { i: { x: 0.833, y: 0.734 }, o: { x: 0.167, y: 0.129 }, t: 33, s: [80, 5.07], to: [0, -8e-3], ti: [0, 0.053] }, { i: { x: 0.833, y: 0.798 }, o: { x: 0.167, y: 0.121 }, t: 34, s: [80, 4.971], to: [0, -0.053], ti: [0, 0.087] }, { i: { x: 0.833, y: 0.815 }, o: { x: 0.167, y: 0.142 }, t: 35, s: [80, 4.755], to: [0, -0.087], ti: [0, 0.114] }, { i: { x: 0.833, y: 0.823 }, o: { x: 0.167, y: 0.152 }, t: 36, s: [80, 4.447], to: [0, -0.114], ti: [0, 0.132] }, { i: { x: 0.833, y: 0.828 }, o: { x: 0.167, y: 0.158 }, t: 37, s: [80, 4.073], to: [0, -0.132], ti: [0, 0.144] }, { i: { x: 0.833, y: 0.832 }, o: { x: 0.167, y: 0.162 }, t: 38, s: [80, 3.655], to: [0, -0.144], ti: [0, 0.149] }, { i: { x: 0.833, y: 0.834 }, o: { x: 0.167, y: 0.165 }, t: 39, s: [80, 3.212], to: [0, -0.149], ti: [0, 0.15] }, { i: { x: 0.833, y: 0.836 }, o: { x: 0.167, y: 0.168 }, t: 40, s: [80, 2.76], to: [0, -0.15], ti: [0, 0.146] }, { i: { x: 0.833, y: 0.838 }, o: { x: 0.167, y: 0.17 }, t: 41, s: [80, 2.313], to: [0, -0.146], ti: [0, 0.14] }, { i: { x: 0.833, y: 0.84 }, o: { x: 0.167, y: 0.172 }, t: 42, s: [80, 1.882], to: [0, -0.14], ti: [0, 0.13] }, { i: { x: 0.833, y: 0.841 }, o: { x: 0.167, y: 0.174 }, t: 43, s: [80, 1.476], to: [0, -0.13], ti: [0, 0.119] }, { i: { x: 0.833, y: 0.843 }, o: { x: 0.167, y: 0.175 }, t: 44, s: [80, 1.1], to: [0, -0.119], ti: [0, 0.107] }, { i: { x: 0.833, y: 0.844 }, o: { x: 0.167, y: 0.177 }, t: 45, s: [80, 0.76], to: [0, -0.107], ti: [0, 0.094] }, { i: { x: 0.833, y: 0.846 }, o: { x: 0.167, y: 0.179 }, t: 46, s: [80, 0.458], to: [0, -0.094], ti: [0, 0.081] }, { i: { x: 0.833, y: 0.847 }, o: { x: 0.167, y: 0.181 }, t: 47, s: [80, 0.195], to: [0, -0.081], ti: [0, 0.068] }, { i: { x: 0.833, y: 0.849 }, o: { x: 0.167, y: 0.184 }, t: 48, s: [80, -0.028], to: [0, -0.068], ti: [0, 0.056] }, { i: { x: 0.833, y: 0.852 }, o: { x: 0.167, y: 0.187 }, t: 49, s: [80, -0.214], to: [0, -0.056], ti: [0, 0.044] }, { i: { x: 0.833, y: 0.855 }, o: { x: 0.167, y: 0.191 }, t: 50, s: [80, -0.364], to: [0, -0.044], ti: [0, 0.034] }, { i: { x: 0.833, y: 0.86 }, o: { x: 0.167, y: 0.196 }, t: 51, s: [80, -0.48], to: [0, -0.034], ti: [0, 0.024] }, { i: { x: 0.833, y: 0.867 }, o: { x: 0.167, y: 0.206 }, t: 52, s: [80, -0.566], to: [0, -0.024], ti: [0, 0.016] }, { i: { x: 0.833, y: 0.883 }, o: { x: 0.167, y: 0.224 }, t: 53, s: [80, -0.624], to: [0, -0.016], ti: [0, 8e-3] }, { i: { x: 0.833, y: 0.889 }, o: { x: 0.167, y: 0.288 }, t: 54, s: [80, -0.659], to: [0, -8e-3], ti: [0, 2e-3] }, { i: { x: 0.833, y: 0.612 }, o: { x: 0.167, y: 0.336 }, t: 55, s: [80, -0.673], to: [0, -2e-3], ti: [0, -3e-3] }, { i: { x: 0.833, y: 0.78 }, o: { x: 0.167, y: 0.106 }, t: 56, s: [80, -0.67], to: [0, 3e-3], ti: [0, -8e-3] }, { i: { x: 0.833, y: 0.809 }, o: { x: 0.167, y: 0.134 }, t: 57, s: [80, -0.653], to: [0, 8e-3], ti: [0, -0.011] }, { i: { x: 0.833, y: 0.82 }, o: { x: 0.167, y: 0.148 }, t: 58, s: [80, -0.625], to: [0, 0.011], ti: [0, -0.013] }, { i: { x: 0.833, y: 0.826 }, o: { x: 0.167, y: 0.155 }, t: 59, s: [80, -0.589], to: [0, 0.013], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.83 }, o: { x: 0.167, y: 0.16 }, t: 60, s: [80, -0.547], to: [0, 0.015], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.833 }, o: { x: 0.167, y: 0.164 }, t: 61, s: [80, -0.501], to: [0, 0.015], ti: [0, -0.016] }, { i: { x: 0.833, y: 0.835 }, o: { x: 0.167, y: 0.166 }, t: 62, s: [80, -0.454], to: [0, 0.016], ti: [0, -0.016] }, { i: { x: 0.833, y: 0.837 }, o: { x: 0.167, y: 0.169 }, t: 63, s: [80, -0.406], to: [0, 0.016], ti: [0, -0.015] }, { i: { x: 0.833, y: 0.839 }, o: { x: 0.167, y: 0.171 }, t: 64, s: [80, -0.36], to: [0, 0.015], ti: [0, -0.014] }, { i: { x: 0.833, y: 0.833 }, o: { x: 0.167, y: 0.173 }, t: 65, s: [80, -0.316], to: [0, 0.014], ti: [0, -7e-3] }, { t: 66, s: [80, -0.274] }], ix: 2 }, a: { a: 0, k: [80, -0.126], ix: 1 }, s: { a: 1, k: [{ i: { x: [0.667, 0.667], y: [1, 1] }, o: { x: [0.333, 0.333], y: [0, 0] }, t: 6, s: [100, 100] }, { i: { x: [0.833, 0.833], y: [0.836, 0.836] }, o: { x: [0.333, 0.333], y: [0, 0] }, t: 16, s: [110, 110] }, { i: { x: [0.833, 0.833], y: [0.851, 0.851] }, o: { x: [0.167, 0.167], y: [0.203, 0.203] }, t: 26, s: [100, 100] }, { i: { x: [0.833, 0.833], y: [0.853, 0.853] }, o: { x: [0.167, 0.167], y: [0.189, 0.189] }, t: 27, s: [99.193, 99.193] }, { i: { x: [0.833, 0.833], y: [0.857, 0.857] }, o: { x: [0.167, 0.167], y: [0.193, 0.193] }, t: 28, s: [98.553, 98.553] }, { i: { x: [0.833, 0.833], y: [0.863, 0.863] }, o: { x: [0.167, 0.167], y: [0.2, 0.2] }, t: 29, s: [98.068, 98.068] }, { i: { x: [0.833, 0.833], y: [0.873, 0.873] }, o: { x: [0.167, 0.167], y: [0.213, 0.213] }, t: 30, s: [97.722, 97.722] }, { i: { x: [0.833, 0.833], y: [0.899, 0.899] }, o: { x: [0.167, 0.167], y: [0.244, 0.244] }, t: 31, s: [97.5, 97.5] }, { i: { x: [0.833, 0.833], y: [1.087, 1.087] }, o: { x: [0.167, 0.167], y: [0.473, 0.473] }, t: 32, s: [97.385, 97.385] }, { i: { x: [0.833, 0.833], y: [0.734, 0.734] }, o: { x: [0.167, 0.167], y: [0.042, 0.042] }, t: 33, s: [97.36, 97.36] }, { i: { x: [0.833, 0.833], y: [0.798, 0.798] }, o: { x: [0.167, 0.167], y: [0.121, 0.121] }, t: 34, s: [97.41, 97.41] }, { i: { x: [0.833, 0.833], y: [0.815, 0.815] }, o: { x: [0.167, 0.167], y: [0.142, 0.142] }, t: 35, s: [97.521, 97.521] }, { i: { x: [0.833, 0.833], y: [0.823, 0.823] }, o: { x: [0.167, 0.167], y: [0.152, 0.152] }, t: 36, s: [97.677, 97.677] }, { i: { x: [0.833, 0.833], y: [0.828, 0.828] }, o: { x: [0.167, 0.167], y: [0.158, 0.158] }, t: 37, s: [97.867, 97.867] }, { i: { x: [0.833, 0.833], y: [0.832, 0.832] }, o: { x: [0.167, 0.167], y: [0.162, 0.162] }, t: 38, s: [98.079, 98.079] }, { i: { x: [0.833, 0.833], y: [0.834, 0.834] }, o: { x: [0.167, 0.167], y: [0.165, 0.165] }, t: 39, s: [98.304, 98.304] }, { i: { x: [0.833, 0.833], y: [0.836, 0.836] }, o: { x: [0.167, 0.167], y: [0.168, 0.168] }, t: 40, s: [98.534, 98.534] }, { i: { x: [0.833, 0.833], y: [0.838, 0.838] }, o: { x: [0.167, 0.167], y: [0.17, 0.17] }, t: 41, s: [98.761, 98.761] }, { i: { x: [0.833, 0.833], y: [0.84, 0.84] }, o: { x: [0.167, 0.167], y: [0.172, 0.172] }, t: 42, s: [98.98, 98.98] }, { i: { x: [0.833, 0.833], y: [0.841, 0.841] }, o: { x: [0.167, 0.167], y: [0.174, 0.174] }, t: 43, s: [99.186, 99.186] }, { i: { x: [0.833, 0.833], y: [0.843, 0.843] }, o: { x: [0.167, 0.167], y: [0.175, 0.175] }, t: 44, s: [99.377, 99.377] }, { i: { x: [0.833, 0.833], y: [0.844, 0.844] }, o: { x: [0.167, 0.167], y: [0.177, 0.177] }, t: 45, s: [99.55, 99.55] }, { i: { x: [0.833, 0.833], y: [0.846, 0.846] }, o: { x: [0.167, 0.167], y: [0.179, 0.179] }, t: 46, s: [99.703, 99.703] }, { i: { x: [0.833, 0.833], y: [0.847, 0.847] }, o: { x: [0.167, 0.167], y: [0.181, 0.181] }, t: 47, s: [99.837, 99.837] }, { i: { x: [0.833, 0.833], y: [0.849, 0.849] }, o: { x: [0.167, 0.167], y: [0.184, 0.184] }, t: 48, s: [99.95, 99.95] }, { i: { x: [0.833, 0.833], y: [0.852, 0.852] }, o: { x: [0.167, 0.167], y: [0.187, 0.187] }, t: 49, s: [100.045, 100.045] }, { i: { x: [0.833, 0.833], y: [0.855, 0.855] }, o: { x: [0.167, 0.167], y: [0.191, 0.191] }, t: 50, s: [100.121, 100.121] }, { i: { x: [0.833, 0.833], y: [0.86, 0.86] }, o: { x: [0.167, 0.167], y: [0.196, 0.196] }, t: 51, s: [100.18, 100.18] }, { i: { x: [0.833, 0.833], y: [0.867, 0.867] }, o: { x: [0.167, 0.167], y: [0.206, 0.206] }, t: 52, s: [100.224, 100.224] }, { i: { x: [0.833, 0.833], y: [0.883, 0.883] }, o: { x: [0.167, 0.167], y: [0.224, 0.224] }, t: 53, s: [100.253, 100.253] }, { i: { x: [0.833, 0.833], y: [0.935, 0.935] }, o: { x: [0.167, 0.167], y: [0.288, 0.288] }, t: 54, s: [100.271, 100.271] }, { i: { x: [0.833, 0.833], y: [0.453, 0.453] }, o: { x: [0.167, 0.167], y: [-0.301, -0.301] }, t: 55, s: [100.278, 100.278] }, { i: { x: [0.833, 0.833], y: [0.78, 0.78] }, o: { x: [0.167, 0.167], y: [0.098, 0.098] }, t: 56, s: [100.276, 100.276] }, { i: { x: [0.833, 0.833], y: [0.809, 0.809] }, o: { x: [0.167, 0.167], y: [0.134, 0.134] }, t: 57, s: [100.268, 100.268] }, { i: { x: [0.833, 0.833], y: [0.82, 0.82] }, o: { x: [0.167, 0.167], y: [0.148, 0.148] }, t: 58, s: [100.254, 100.254] }, { i: { x: [0.833, 0.833], y: [0.826, 0.826] }, o: { x: [0.167, 0.167], y: [0.155, 0.155] }, t: 59, s: [100.235, 100.235] }, { i: { x: [0.833, 0.833], y: [0.83, 0.83] }, o: { x: [0.167, 0.167], y: [0.16, 0.16] }, t: 60, s: [100.214, 100.214] }, { i: { x: [0.833, 0.833], y: [0.833, 0.833] }, o: { x: [0.167, 0.167], y: [0.164, 0.164] }, t: 61, s: [100.191, 100.191] }, { i: { x: [0.833, 0.833], y: [0.835, 0.835] }, o: { x: [0.167, 0.167], y: [0.166, 0.166] }, t: 62, s: [100.167, 100.167] }, { i: { x: [0.833, 0.833], y: [0.837, 0.837] }, o: { x: [0.167, 0.167], y: [0.169, 0.169] }, t: 63, s: [100.142, 100.142] }, { i: { x: [0.833, 0.833], y: [0.839, 0.839] }, o: { x: [0.167, 0.167], y: [0.171, 0.171] }, t: 64, s: [100.119, 100.119] }, { i: { x: [0.833, 0.833], y: [0.833, 0.833] }, o: { x: [0.167, 0.167], y: [0.173, 0.173] }, t: 65, s: [100.096, 100.096] }, { t: 66, s: [100.075, 100.075] }], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 4, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: false }], ip: 0, op: 80, st: 6, bm: 0 }], markers: [] };

// src/ui/screens/LoadingScreen.ts
var LoadingScreen = class extends Screen {
  constructor(manager) {
    super(manager);
    this.updateTemplate();
  }
  updateTemplate(_data, _bus) {
    const template = x`
            <section class="centered">
                <div id="loading-animation" class="loading-animation"></div>
                <div class="row-full"></div>
            </section>
        `;
    this.template = [template];
    return this.template;
  }
  renderComplete(parent2) {
    super.renderComplete(parent2);
    const animationNode = parent2.querySelector("#loading-animation");
    import_lottie_web2.default.loadAnimation({
      container: animationNode,
      // the dom element that will contain the animation
      renderer: "svg",
      loop: true,
      autoplay: true,
      animationData: loading_animation_default
    });
  }
};

// node_modules/octokit/dist-web/index.js
var import_core2 = __toESM(require_dist_node4());

// node_modules/@octokit/plugin-paginate-rest/dist-web/index.js
var VERSION3 = "9.1.5";
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data2 = response.data[namespaceKey];
  response.data = data2;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url)
          return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(
            /<([^>]+)>;\s*rel="next"/
          ) || [])[1];
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = void 0;
  }
  return gather(
    octokit,
    [],
    iterator(octokit, route, parameters)[Symbol.asyncIterator](),
    mapFn
  );
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(
      mapFn ? mapFn(result.value, done) : result.value.data
    );
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}
var composePaginateRest = Object.assign(paginate, {
  iterator
});
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION3;

// node_modules/@octokit/plugin-paginate-graphql/dist-web/index.js
var generateMessage = (path, cursorValue) => `The cursor at "${path.join(
  ","
)}" did not change its value "${cursorValue}" after a page transition. Please make sure your that your query is set up correctly.`;
var MissingCursorChange = class extends Error {
  constructor(pageInfo, cursorValue) {
    super(generateMessage(pageInfo.pathInQuery, cursorValue));
    this.pageInfo = pageInfo;
    this.cursorValue = cursorValue;
    this.name = "MissingCursorChangeError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var MissingPageInfo = class extends Error {
  constructor(response) {
    super(
      `No pageInfo property found in response. Please make sure to specify the pageInfo in your query. Response-Data: ${JSON.stringify(
        response,
        null,
        2
      )}`
    );
    this.response = response;
    this.name = "MissingPageInfo";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var isObject = (value2) => Object.prototype.toString.call(value2) === "[object Object]";
function findPaginatedResourcePath(responseData) {
  const paginatedResourcePath = deepFindPathToProperty(
    responseData,
    "pageInfo"
  );
  if (paginatedResourcePath.length === 0) {
    throw new MissingPageInfo(responseData);
  }
  return paginatedResourcePath;
}
var deepFindPathToProperty = (object, searchProp, path = []) => {
  for (const key2 of Object.keys(object)) {
    const currentPath = [...path, key2];
    const currentValue = object[key2];
    if (currentValue.hasOwnProperty(searchProp)) {
      return currentPath;
    }
    if (isObject(currentValue)) {
      const result = deepFindPathToProperty(
        currentValue,
        searchProp,
        currentPath
      );
      if (result.length > 0) {
        return result;
      }
    }
  }
  return [];
};
var get = (object, path) => {
  return path.reduce((current, nextProperty) => current[nextProperty], object);
};
var set = (object, path, mutator) => {
  const lastProperty = path[path.length - 1];
  const parentPath = [...path].slice(0, -1);
  const parent2 = get(object, parentPath);
  if (typeof mutator === "function") {
    parent2[lastProperty] = mutator(parent2[lastProperty]);
  } else {
    parent2[lastProperty] = mutator;
  }
};
var extractPageInfos = (responseData) => {
  const pageInfoPath = findPaginatedResourcePath(responseData);
  return {
    pathInQuery: pageInfoPath,
    pageInfo: get(responseData, [...pageInfoPath, "pageInfo"])
  };
};
var isForwardSearch = (givenPageInfo) => {
  return givenPageInfo.hasOwnProperty("hasNextPage");
};
var getCursorFrom = (pageInfo) => isForwardSearch(pageInfo) ? pageInfo.endCursor : pageInfo.startCursor;
var hasAnotherPage = (pageInfo) => isForwardSearch(pageInfo) ? pageInfo.hasNextPage : pageInfo.hasPreviousPage;
var createIterator = (octokit) => {
  return (query, initialParameters = {}) => {
    let nextPageExists = true;
    let parameters = { ...initialParameters };
    return {
      [Symbol.asyncIterator]: () => ({
        async next() {
          if (!nextPageExists)
            return { done: true, value: {} };
          const response = await octokit.graphql(
            query,
            parameters
          );
          const pageInfoContext = extractPageInfos(response);
          const nextCursorValue = getCursorFrom(pageInfoContext.pageInfo);
          nextPageExists = hasAnotherPage(pageInfoContext.pageInfo);
          if (nextPageExists && nextCursorValue === parameters.cursor) {
            throw new MissingCursorChange(pageInfoContext, nextCursorValue);
          }
          parameters = {
            ...parameters,
            cursor: nextCursorValue
          };
          return { done: false, value: response };
        }
      })
    };
  };
};
var mergeResponses = (response1, response2) => {
  if (Object.keys(response1).length === 0) {
    return Object.assign(response1, response2);
  }
  const path = findPaginatedResourcePath(response1);
  const nodesPath = [...path, "nodes"];
  const newNodes = get(response2, nodesPath);
  if (newNodes) {
    set(response1, nodesPath, (values) => {
      return [...values, ...newNodes];
    });
  }
  const edgesPath = [...path, "edges"];
  const newEdges = get(response2, edgesPath);
  if (newEdges) {
    set(response1, edgesPath, (values) => {
      return [...values, ...newEdges];
    });
  }
  const pageInfoPath = [...path, "pageInfo"];
  set(response1, pageInfoPath, get(response2, pageInfoPath));
  return response1;
};
var createPaginate = (octokit) => {
  const iterator2 = createIterator(octokit);
  return async (query, initialParameters = {}) => {
    let mergedResponse = {};
    for await (const response of iterator2(
      query,
      initialParameters
    )) {
      mergedResponse = mergeResponses(mergedResponse, response);
    }
    return mergedResponse;
  };
};
function paginateGraphql(octokit) {
  octokit.graphql;
  return {
    graphql: Object.assign(octokit.graphql, {
      paginate: Object.assign(createPaginate(octokit), {
        iterator: createIterator(octokit)
      })
    })
  };
}

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js
var VERSION4 = "10.2.0";
var Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    createOrUpdateEnvironmentSecret: [
      "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getEnvironmentPublicKey: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotForBusinessSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotForBusinessSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: [
      "DELETE /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
      }
    ],
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getCommitAuthors: [
      "GET /repos/{owner}/{repo}/import/authors",
      {},
      {
        deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
      }
    ],
    getImportStatus: [
      "GET /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
      }
    ],
    getLargeFiles: [
      "GET /repos/{owner}/{repo}/import/large_files",
      {},
      {
        deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
      }
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    mapCommitAuthor: [
      "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
      {},
      {
        deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
      }
    ],
    setLfsPreference: [
      "PATCH /repos/{owner}/{repo}/import/lfs",
      {},
      {
        deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
      }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: [
      "PUT /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
      }
    ],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    updateImport: [
      "PATCH /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
      }
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}"
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: [
      "GET /projects/{project_id}/collaborators/{username}/permission"
    ],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: [
      "DELETE /projects/{project_id}/collaborators/{username}"
    ],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployment"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteTagProtection: [
      "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
    ],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateProjectPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForProjectInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeProjectInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;
var endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint2] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint2;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url
      },
      defaults
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
var handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      // ensures method is in the cache
      configurable: true,
      writable: true,
      enumerable: true
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value2) {
    return target.cache[methodName] = value2;
  },
  get({ octokit, scope, cache }, methodName) {
    if (cache[methodName]) {
      return cache[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return void 0;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache[methodName] = decorate(
        octokit,
        scope,
        methodName,
        endpointDefaults,
        decorations
      );
    } else {
      cache[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: void 0
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(
        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
      );
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name2, alias] of Object.entries(
        decorations.renamedParameters
      )) {
        if (name2 in options2) {
          octokit.log.warn(
            `"${name2}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
          );
          if (!(alias in options2)) {
            options2[alias] = options2[name2];
          }
          delete options2[name2];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION4;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
legacyRestEndpointMethods.VERSION = VERSION4;

// node_modules/@octokit/plugin-retry/dist-web/index.js
var import_light = __toESM(require_light());
init_dist_web2();
async function errorRequest(state, octokit, error, options) {
  if (!error.request || !error.request.request) {
    throw error;
  }
  if (error.status >= 400 && !state.doNotRetry.includes(error.status)) {
    const retries = options.request.retries != null ? options.request.retries : state.retries;
    const retryAfter = Math.pow((options.request.retryCount || 0) + 1, 2);
    throw octokit.retry.retryRequest(error, retries, retryAfter);
  }
  throw error;
}
async function wrapRequest(state, octokit, request2, options) {
  const limiter = new import_light.default();
  limiter.on("failed", function(error, info) {
    const maxRetries = ~~error.request.request.retries;
    const after = ~~error.request.request.retryAfter;
    options.request.retryCount = info.retryCount + 1;
    if (maxRetries > info.retryCount) {
      return after * state.retryAfterBaseValue;
    }
  });
  return limiter.schedule(
    requestWithGraphqlErrorHandling.bind(null, state, octokit, request2),
    options
  );
}
async function requestWithGraphqlErrorHandling(state, octokit, request2, options) {
  const response = await request2(request2, options);
  if (response.data && response.data.errors && /Something went wrong while executing your query/.test(
    response.data.errors[0].message
  )) {
    const error = new RequestError(response.data.errors[0].message, 500, {
      request: options,
      response
    });
    return errorRequest(state, octokit, error, options);
  }
  return response;
}
var VERSION5 = "6.0.1";
function retry(octokit, octokitOptions) {
  const state = Object.assign(
    {
      enabled: true,
      retryAfterBaseValue: 1e3,
      doNotRetry: [400, 401, 403, 404, 422, 451],
      retries: 3
    },
    octokitOptions.retry
  );
  if (state.enabled) {
    octokit.hook.error("request", errorRequest.bind(null, state, octokit));
    octokit.hook.wrap("request", wrapRequest.bind(null, state, octokit));
  }
  return {
    retry: {
      retryRequest: (error, retries, retryAfter) => {
        error.request.request = Object.assign({}, error.request.request, {
          retries,
          retryAfter
        });
        return error;
      }
    }
  };
}
retry.VERSION = VERSION5;

// node_modules/@octokit/plugin-throttling/dist-web/index.js
var import_light2 = __toESM(require_light());
var VERSION6 = "8.1.3";
var noop = () => Promise.resolve();
function wrapRequest2(state, request2, options) {
  return state.retryLimiter.schedule(doRequest, state, request2, options);
}
async function doRequest(state, request2, options) {
  const isWrite = options.method !== "GET" && options.method !== "HEAD";
  const { pathname } = new URL(options.url, "http://github.test");
  const isSearch = options.method === "GET" && pathname.startsWith("/search/");
  const isGraphQL = pathname.startsWith("/graphql");
  const retryCount = ~~request2.retryCount;
  const jobOptions = retryCount > 0 ? { priority: 0, weight: 0 } : {};
  if (state.clustering) {
    jobOptions.expiration = 1e3 * 60;
  }
  if (isWrite || isGraphQL) {
    await state.write.key(state.id).schedule(jobOptions, noop);
  }
  if (isWrite && state.triggersNotification(pathname)) {
    await state.notifications.key(state.id).schedule(jobOptions, noop);
  }
  if (isSearch) {
    await state.search.key(state.id).schedule(jobOptions, noop);
  }
  const req = state.global.key(state.id).schedule(
    jobOptions,
    request2,
    options
  );
  if (isGraphQL) {
    const res = await req;
    if (res.data.errors != null && res.data.errors.some((error) => error.type === "RATE_LIMITED")) {
      const error = Object.assign(new Error("GraphQL Rate Limit Exceeded"), {
        response: res,
        data: res.data
      });
      throw error;
    }
  }
  return req;
}
var triggers_notification_paths_default = [
  "/orgs/{org}/invitations",
  "/orgs/{org}/invitations/{invitation_id}",
  "/orgs/{org}/teams/{team_slug}/discussions",
  "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
  "/repos/{owner}/{repo}/collaborators/{username}",
  "/repos/{owner}/{repo}/commits/{commit_sha}/comments",
  "/repos/{owner}/{repo}/issues",
  "/repos/{owner}/{repo}/issues/{issue_number}/comments",
  "/repos/{owner}/{repo}/pulls",
  "/repos/{owner}/{repo}/pulls/{pull_number}/comments",
  "/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
  "/repos/{owner}/{repo}/pulls/{pull_number}/merge",
  "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
  "/repos/{owner}/{repo}/pulls/{pull_number}/reviews",
  "/repos/{owner}/{repo}/releases",
  "/teams/{team_id}/discussions",
  "/teams/{team_id}/discussions/{discussion_number}/comments"
];
function routeMatcher(paths) {
  const regexes = paths.map(
    (path) => path.split("/").map((c2) => c2.startsWith("{") ? "(?:.+?)" : c2).join("/")
  );
  const regex2 = `^(?:${regexes.map((r3) => `(?:${r3})`).join("|")})[^/]*$`;
  return new RegExp(regex2, "i");
}
var regex = routeMatcher(triggers_notification_paths_default);
var triggersNotification = regex.test.bind(regex);
var groups = {};
var createGroups = function(Bottleneck2, common) {
  groups.global = new Bottleneck2.Group({
    id: "octokit-global",
    maxConcurrent: 10,
    ...common
  });
  groups.search = new Bottleneck2.Group({
    id: "octokit-search",
    maxConcurrent: 1,
    minTime: 2e3,
    ...common
  });
  groups.write = new Bottleneck2.Group({
    id: "octokit-write",
    maxConcurrent: 1,
    minTime: 1e3,
    ...common
  });
  groups.notifications = new Bottleneck2.Group({
    id: "octokit-notifications",
    maxConcurrent: 1,
    minTime: 3e3,
    ...common
  });
};
function throttling(octokit, octokitOptions) {
  const {
    enabled = true,
    Bottleneck: Bottleneck2 = import_light2.default,
    id = "no-id",
    timeout = 1e3 * 60 * 2,
    // Redis TTL: 2 minutes
    connection
  } = octokitOptions.throttle || {};
  if (!enabled) {
    return {};
  }
  const common = { connection, timeout };
  if (groups.global == null) {
    createGroups(Bottleneck2, common);
  }
  const state = Object.assign(
    {
      clustering: connection != null,
      triggersNotification,
      fallbackSecondaryRateRetryAfter: 60,
      retryAfterBaseValue: 1e3,
      retryLimiter: new Bottleneck2(),
      id,
      ...groups
    },
    octokitOptions.throttle
  );
  if (typeof state.onSecondaryRateLimit !== "function" || typeof state.onRateLimit !== "function") {
    throw new Error(`octokit/plugin-throttling error:
        You must pass the onSecondaryRateLimit and onRateLimit error handlers.
        See https://octokit.github.io/rest.js/#throttling

        const octokit = new Octokit({
          throttle: {
            onSecondaryRateLimit: (retryAfter, options) => {/* ... */},
            onRateLimit: (retryAfter, options) => {/* ... */}
          }
        })
    `);
  }
  const events = {};
  const emitter = new Bottleneck2.Events(events);
  events.on("secondary-limit", state.onSecondaryRateLimit);
  events.on("rate-limit", state.onRateLimit);
  events.on(
    "error",
    (e5) => octokit.log.warn("Error in throttling-plugin limit handler", e5)
  );
  state.retryLimiter.on("failed", async function(error, info) {
    const [state2, request2, options] = info.args;
    const { pathname } = new URL(options.url, "http://github.test");
    const shouldRetryGraphQL = pathname.startsWith("/graphql") && error.status !== 401;
    if (!(shouldRetryGraphQL || error.status === 403)) {
      return;
    }
    const retryCount = ~~request2.retryCount;
    request2.retryCount = retryCount;
    options.request.retryCount = retryCount;
    const { wantRetry, retryAfter = 0 } = await async function() {
      var _a3, _b;
      if (/\bsecondary rate\b/i.test(error.message)) {
        const retryAfter2 = Number(error.response.headers["retry-after"]) || state2.fallbackSecondaryRateRetryAfter;
        const wantRetry2 = await emitter.trigger(
          "secondary-limit",
          retryAfter2,
          options,
          octokit,
          retryCount
        );
        return { wantRetry: wantRetry2, retryAfter: retryAfter2 };
      }
      if (error.response.headers != null && error.response.headers["x-ratelimit-remaining"] === "0" || ((_b = (_a3 = error.response.data) == null ? void 0 : _a3.errors) != null ? _b : []).some(
        (error2) => error2.type === "RATE_LIMITED"
      )) {
        const rateLimitReset = new Date(
          ~~error.response.headers["x-ratelimit-reset"] * 1e3
        ).getTime();
        const retryAfter2 = Math.max(
          // Add one second so we retry _after_ the reset time
          // https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#exceeding-the-rate-limit
          Math.ceil((rateLimitReset - Date.now()) / 1e3) + 1,
          0
        );
        const wantRetry2 = await emitter.trigger(
          "rate-limit",
          retryAfter2,
          options,
          octokit,
          retryCount
        );
        return { wantRetry: wantRetry2, retryAfter: retryAfter2 };
      }
      return {};
    }();
    if (wantRetry) {
      request2.retryCount++;
      return retryAfter * state2.retryAfterBaseValue;
    }
  });
  octokit.hook.wrap("request", wrapRequest2.bind(null, state));
  return {};
}
throttling.VERSION = VERSION6;
throttling.triggersNotification = triggersNotification;

// node_modules/@octokit/app/dist-web/index.js
var import_core = __toESM(require_dist_node4());
var import_auth_app = __toESM(require_dist_node6());
var import_oauth_app = __toESM(require_dist_node8());

// node_modules/@octokit/webhooks/dist-web/index.js
var import_aggregate_error = __toESM(require_aggregate_error());

// node_modules/@octokit/webhooks-methods/dist-web/index.js
var Algorithm = /* @__PURE__ */ ((Algorithm2) => {
  Algorithm2["SHA1"] = "sha1";
  Algorithm2["SHA256"] = "sha256";
  return Algorithm2;
})(Algorithm || {});
var getAlgorithm = (signature) => {
  return signature.startsWith("sha256=") ? "sha256" : "sha1";
};
var enc = new TextEncoder();
function hexToUInt8Array(string) {
  const pairs = string.match(/[\dA-F]{2}/gi);
  const integers = pairs.map(function(s2) {
    return parseInt(s2, 16);
  });
  return new Uint8Array(integers);
}
function UInt8ArrayToHex(signature) {
  return Array.prototype.map.call(new Uint8Array(signature), (x2) => x2.toString(16).padStart(2, "0")).join("");
}
function getHMACHashName(algorithm) {
  return {
    [Algorithm.SHA1]: "SHA-1",
    [Algorithm.SHA256]: "SHA-256"
  }[algorithm];
}
async function importKey(secret, algorithm) {
  return crypto.subtle.importKey(
    "raw",
    // raw format of the key - should be Uint8Array
    enc.encode(secret),
    {
      // algorithm details
      name: "HMAC",
      hash: { name: getHMACHashName(algorithm) }
    },
    false,
    // export = false
    ["sign", "verify"]
    // what this key can do
  );
}
async function sign(options, payload) {
  const { secret, algorithm } = typeof options === "object" ? {
    secret: options.secret,
    algorithm: options.algorithm || Algorithm.SHA256
  } : { secret: options, algorithm: Algorithm.SHA256 };
  if (!secret || !payload) {
    throw new TypeError(
      "[@octokit/webhooks-methods] secret & payload required for sign()"
    );
  }
  if (!Object.values(Algorithm).includes(algorithm)) {
    throw new TypeError(
      `[@octokit/webhooks] Algorithm ${algorithm} is not supported. Must be  'sha1' or 'sha256'`
    );
  }
  const signature = await crypto.subtle.sign(
    "HMAC",
    await importKey(secret, algorithm),
    enc.encode(payload)
  );
  return `${algorithm}=${UInt8ArrayToHex(signature)}`;
}
async function verify(secret, eventPayload, signature) {
  if (!secret || !eventPayload || !signature) {
    throw new TypeError(
      "[@octokit/webhooks-methods] secret, eventPayload & signature required"
    );
  }
  const algorithm = getAlgorithm(signature);
  return await crypto.subtle.verify(
    "HMAC",
    await importKey(secret, algorithm),
    hexToUInt8Array(signature.replace(`${algorithm}=`, "")),
    enc.encode(eventPayload)
  );
}

// node_modules/@octokit/webhooks/dist-web/index.js
var import_aggregate_error2 = __toESM(require_aggregate_error());
var import_aggregate_error3 = __toESM(require_aggregate_error());
var createLogger = (logger) => ({
  debug: () => {
  },
  info: () => {
  },
  warn: console.warn.bind(console),
  error: console.error.bind(console),
  ...logger
});
var emitterEventNames = [
  "branch_protection_rule",
  "branch_protection_rule.created",
  "branch_protection_rule.deleted",
  "branch_protection_rule.edited",
  "check_run",
  "check_run.completed",
  "check_run.created",
  "check_run.requested_action",
  "check_run.rerequested",
  "check_suite",
  "check_suite.completed",
  "check_suite.requested",
  "check_suite.rerequested",
  "code_scanning_alert",
  "code_scanning_alert.appeared_in_branch",
  "code_scanning_alert.closed_by_user",
  "code_scanning_alert.created",
  "code_scanning_alert.fixed",
  "code_scanning_alert.reopened",
  "code_scanning_alert.reopened_by_user",
  "commit_comment",
  "commit_comment.created",
  "create",
  "delete",
  "dependabot_alert",
  "dependabot_alert.created",
  "dependabot_alert.dismissed",
  "dependabot_alert.fixed",
  "dependabot_alert.reintroduced",
  "dependabot_alert.reopened",
  "deploy_key",
  "deploy_key.created",
  "deploy_key.deleted",
  "deployment",
  "deployment.created",
  "deployment_protection_rule",
  "deployment_protection_rule.requested",
  "deployment_status",
  "deployment_status.created",
  "discussion",
  "discussion.answered",
  "discussion.category_changed",
  "discussion.created",
  "discussion.deleted",
  "discussion.edited",
  "discussion.labeled",
  "discussion.locked",
  "discussion.pinned",
  "discussion.transferred",
  "discussion.unanswered",
  "discussion.unlabeled",
  "discussion.unlocked",
  "discussion.unpinned",
  "discussion_comment",
  "discussion_comment.created",
  "discussion_comment.deleted",
  "discussion_comment.edited",
  "fork",
  "github_app_authorization",
  "github_app_authorization.revoked",
  "gollum",
  "installation",
  "installation.created",
  "installation.deleted",
  "installation.new_permissions_accepted",
  "installation.suspend",
  "installation.unsuspend",
  "installation_repositories",
  "installation_repositories.added",
  "installation_repositories.removed",
  "installation_target",
  "installation_target.renamed",
  "issue_comment",
  "issue_comment.created",
  "issue_comment.deleted",
  "issue_comment.edited",
  "issues",
  "issues.assigned",
  "issues.closed",
  "issues.deleted",
  "issues.demilestoned",
  "issues.edited",
  "issues.labeled",
  "issues.locked",
  "issues.milestoned",
  "issues.opened",
  "issues.pinned",
  "issues.reopened",
  "issues.transferred",
  "issues.unassigned",
  "issues.unlabeled",
  "issues.unlocked",
  "issues.unpinned",
  "label",
  "label.created",
  "label.deleted",
  "label.edited",
  "marketplace_purchase",
  "marketplace_purchase.cancelled",
  "marketplace_purchase.changed",
  "marketplace_purchase.pending_change",
  "marketplace_purchase.pending_change_cancelled",
  "marketplace_purchase.purchased",
  "member",
  "member.added",
  "member.edited",
  "member.removed",
  "membership",
  "membership.added",
  "membership.removed",
  "merge_group",
  "merge_group.checks_requested",
  "meta",
  "meta.deleted",
  "milestone",
  "milestone.closed",
  "milestone.created",
  "milestone.deleted",
  "milestone.edited",
  "milestone.opened",
  "org_block",
  "org_block.blocked",
  "org_block.unblocked",
  "organization",
  "organization.deleted",
  "organization.member_added",
  "organization.member_invited",
  "organization.member_removed",
  "organization.renamed",
  "package",
  "package.published",
  "package.updated",
  "page_build",
  "ping",
  "project",
  "project.closed",
  "project.created",
  "project.deleted",
  "project.edited",
  "project.reopened",
  "project_card",
  "project_card.converted",
  "project_card.created",
  "project_card.deleted",
  "project_card.edited",
  "project_card.moved",
  "project_column",
  "project_column.created",
  "project_column.deleted",
  "project_column.edited",
  "project_column.moved",
  "projects_v2_item",
  "projects_v2_item.archived",
  "projects_v2_item.converted",
  "projects_v2_item.created",
  "projects_v2_item.deleted",
  "projects_v2_item.edited",
  "projects_v2_item.reordered",
  "projects_v2_item.restored",
  "public",
  "pull_request",
  "pull_request.assigned",
  "pull_request.auto_merge_disabled",
  "pull_request.auto_merge_enabled",
  "pull_request.closed",
  "pull_request.converted_to_draft",
  "pull_request.demilestoned",
  "pull_request.dequeued",
  "pull_request.edited",
  "pull_request.enqueued",
  "pull_request.labeled",
  "pull_request.locked",
  "pull_request.milestoned",
  "pull_request.opened",
  "pull_request.ready_for_review",
  "pull_request.reopened",
  "pull_request.review_request_removed",
  "pull_request.review_requested",
  "pull_request.synchronize",
  "pull_request.unassigned",
  "pull_request.unlabeled",
  "pull_request.unlocked",
  "pull_request_review",
  "pull_request_review.dismissed",
  "pull_request_review.edited",
  "pull_request_review.submitted",
  "pull_request_review_comment",
  "pull_request_review_comment.created",
  "pull_request_review_comment.deleted",
  "pull_request_review_comment.edited",
  "pull_request_review_thread",
  "pull_request_review_thread.resolved",
  "pull_request_review_thread.unresolved",
  "push",
  "registry_package",
  "registry_package.published",
  "registry_package.updated",
  "release",
  "release.created",
  "release.deleted",
  "release.edited",
  "release.prereleased",
  "release.published",
  "release.released",
  "release.unpublished",
  "repository",
  "repository.archived",
  "repository.created",
  "repository.deleted",
  "repository.edited",
  "repository.privatized",
  "repository.publicized",
  "repository.renamed",
  "repository.transferred",
  "repository.unarchived",
  "repository_dispatch",
  "repository_import",
  "repository_vulnerability_alert",
  "repository_vulnerability_alert.create",
  "repository_vulnerability_alert.dismiss",
  "repository_vulnerability_alert.reopen",
  "repository_vulnerability_alert.resolve",
  "secret_scanning_alert",
  "secret_scanning_alert.created",
  "secret_scanning_alert.reopened",
  "secret_scanning_alert.resolved",
  "secret_scanning_alert.revoked",
  "secret_scanning_alert_location",
  "secret_scanning_alert_location.created",
  "security_advisory",
  "security_advisory.performed",
  "security_advisory.published",
  "security_advisory.updated",
  "security_advisory.withdrawn",
  "sponsorship",
  "sponsorship.cancelled",
  "sponsorship.created",
  "sponsorship.edited",
  "sponsorship.pending_cancellation",
  "sponsorship.pending_tier_change",
  "sponsorship.tier_changed",
  "star",
  "star.created",
  "star.deleted",
  "status",
  "team",
  "team.added_to_repository",
  "team.created",
  "team.deleted",
  "team.edited",
  "team.removed_from_repository",
  "team_add",
  "watch",
  "watch.started",
  "workflow_dispatch",
  "workflow_job",
  "workflow_job.completed",
  "workflow_job.in_progress",
  "workflow_job.queued",
  "workflow_job.waiting",
  "workflow_run",
  "workflow_run.completed",
  "workflow_run.in_progress",
  "workflow_run.requested"
];
function handleEventHandlers(state, webhookName, handler2) {
  if (!state.hooks[webhookName]) {
    state.hooks[webhookName] = [];
  }
  state.hooks[webhookName].push(handler2);
}
function receiverOn(state, webhookNameOrNames, handler2) {
  if (Array.isArray(webhookNameOrNames)) {
    webhookNameOrNames.forEach(
      (webhookName) => receiverOn(state, webhookName, handler2)
    );
    return;
  }
  if (["*", "error"].includes(webhookNameOrNames)) {
    const webhookName = webhookNameOrNames === "*" ? "any" : webhookNameOrNames;
    const message = `Using the "${webhookNameOrNames}" event with the regular Webhooks.on() function is not supported. Please use the Webhooks.on${webhookName.charAt(0).toUpperCase() + webhookName.slice(1)}() method instead`;
    throw new Error(message);
  }
  if (!emitterEventNames.includes(webhookNameOrNames)) {
    state.log.warn(
      `"${webhookNameOrNames}" is not a known webhook name (https://developer.github.com/v3/activity/events/types/)`
    );
  }
  handleEventHandlers(state, webhookNameOrNames, handler2);
}
function receiverOnAny(state, handler2) {
  handleEventHandlers(state, "*", handler2);
}
function receiverOnError(state, handler2) {
  handleEventHandlers(state, "error", handler2);
}
function wrapErrorHandler(handler2, error) {
  let returnValue;
  try {
    returnValue = handler2(error);
  } catch (error2) {
    console.log('FATAL: Error occurred in "error" event handler');
    console.log(error2);
  }
  if (returnValue && returnValue.catch) {
    returnValue.catch((error2) => {
      console.log('FATAL: Error occurred in "error" event handler');
      console.log(error2);
    });
  }
}
function getHooks(state, eventPayloadAction, eventName) {
  const hooks = [state.hooks[eventName], state.hooks["*"]];
  if (eventPayloadAction) {
    hooks.unshift(state.hooks[`${eventName}.${eventPayloadAction}`]);
  }
  return [].concat(...hooks.filter(Boolean));
}
function receiverHandle(state, event) {
  const errorHandlers = state.hooks.error || [];
  if (event instanceof Error) {
    const error = Object.assign(new import_aggregate_error.default([event]), {
      event,
      errors: [event]
    });
    errorHandlers.forEach((handler2) => wrapErrorHandler(handler2, error));
    return Promise.reject(error);
  }
  if (!event || !event.name) {
    throw new import_aggregate_error.default(["Event name not passed"]);
  }
  if (!event.payload) {
    throw new import_aggregate_error.default(["Event payload not passed"]);
  }
  const hooks = getHooks(
    state,
    "action" in event.payload ? event.payload.action : null,
    event.name
  );
  if (hooks.length === 0) {
    return Promise.resolve();
  }
  const errors = [];
  const promises = hooks.map((handler2) => {
    let promise = Promise.resolve(event);
    if (state.transform) {
      promise = promise.then(state.transform);
    }
    return promise.then((event2) => {
      return handler2(event2);
    }).catch((error) => errors.push(Object.assign(error, { event })));
  });
  return Promise.all(promises).then(() => {
    if (errors.length === 0) {
      return;
    }
    const error = new import_aggregate_error.default(errors);
    Object.assign(error, {
      event,
      errors
    });
    errorHandlers.forEach((handler2) => wrapErrorHandler(handler2, error));
    throw error;
  });
}
function removeListener(state, webhookNameOrNames, handler2) {
  if (Array.isArray(webhookNameOrNames)) {
    webhookNameOrNames.forEach(
      (webhookName) => removeListener(state, webhookName, handler2)
    );
    return;
  }
  if (!state.hooks[webhookNameOrNames]) {
    return;
  }
  for (let i4 = state.hooks[webhookNameOrNames].length - 1; i4 >= 0; i4--) {
    if (state.hooks[webhookNameOrNames][i4] === handler2) {
      state.hooks[webhookNameOrNames].splice(i4, 1);
      return;
    }
  }
}
function createEventHandler(options) {
  const state = {
    hooks: {},
    log: createLogger(options && options.log)
  };
  if (options && options.transform) {
    state.transform = options.transform;
  }
  return {
    on: receiverOn.bind(null, state),
    onAny: receiverOnAny.bind(null, state),
    onError: receiverOnError.bind(null, state),
    removeListener: removeListener.bind(null, state),
    receive: receiverHandle.bind(null, state)
  };
}
async function verifyAndReceive(state, event) {
  const matchesSignature = await verify(
    state.secret,
    event.payload,
    event.signature
  ).catch(() => false);
  if (!matchesSignature) {
    const error = new Error(
      "[@octokit/webhooks] signature does not match event payload and secret"
    );
    return state.eventHandler.receive(
      Object.assign(error, { event, status: 400 })
    );
  }
  let payload;
  try {
    payload = JSON.parse(event.payload);
  } catch (error) {
    error.message = "Invalid JSON";
    error.status = 400;
    throw new import_aggregate_error2.default([error]);
  }
  return state.eventHandler.receive({
    id: event.id,
    name: event.name,
    payload
  });
}
var Webhooks = class {
  constructor(options) {
    if (!options || !options.secret) {
      throw new Error("[@octokit/webhooks] options.secret required");
    }
    const state = {
      eventHandler: createEventHandler(options),
      secret: options.secret,
      hooks: {},
      log: createLogger(options.log)
    };
    this.sign = sign.bind(null, options.secret);
    this.verify = verify.bind(null, options.secret);
    this.on = state.eventHandler.on;
    this.onAny = state.eventHandler.onAny;
    this.onError = state.eventHandler.onError;
    this.removeListener = state.eventHandler.removeListener;
    this.receive = state.eventHandler.receive;
    this.verifyAndReceive = verifyAndReceive.bind(null, state);
  }
};

// node_modules/@octokit/app/dist-web/index.js
var import_auth_app2 = __toESM(require_dist_node6());
var import_auth_unauthenticated = __toESM(require_dist_node7());
var import_auth_app3 = __toESM(require_dist_node6());
var VERSION10 = "14.0.2";
function webhooks(appOctokit, options) {
  return new Webhooks({
    secret: options.secret,
    transform: async (event) => {
      if (!("installation" in event.payload) || typeof event.payload.installation !== "object") {
        const octokit2 = new appOctokit.constructor({
          authStrategy: import_auth_unauthenticated.createUnauthenticatedAuth,
          auth: {
            reason: `"installation" key missing in webhook event payload`
          }
        });
        return {
          ...event,
          octokit: octokit2
        };
      }
      const installationId = event.payload.installation.id;
      const octokit = await appOctokit.auth({
        type: "installation",
        installationId,
        factory(auth5) {
          return new auth5.octokit.constructor({
            ...auth5.octokitOptions,
            authStrategy: import_auth_app2.createAppAuth,
            ...{
              auth: {
                ...auth5,
                installationId
              }
            }
          });
        }
      });
      octokit.hook.before("request", (options2) => {
        options2.headers["x-github-delivery"] = event.id;
      });
      return {
        ...event,
        octokit
      };
    }
  });
}
async function getInstallationOctokit(app, installationId) {
  return app.octokit.auth({
    type: "installation",
    installationId,
    factory(auth5) {
      const options = {
        ...auth5.octokitOptions,
        authStrategy: import_auth_app3.createAppAuth,
        ...{ auth: { ...auth5, installationId } }
      };
      return new auth5.octokit.constructor(options);
    }
  });
}
function eachInstallationFactory(app) {
  return Object.assign(eachInstallation.bind(null, app), {
    iterator: eachInstallationIterator.bind(null, app)
  });
}
async function eachInstallation(app, callback) {
  const i4 = eachInstallationIterator(app)[Symbol.asyncIterator]();
  let result = await i4.next();
  while (!result.done) {
    await callback(result.value);
    result = await i4.next();
  }
}
function eachInstallationIterator(app) {
  return {
    async *[Symbol.asyncIterator]() {
      const iterator2 = composePaginateRest.iterator(
        app.octokit,
        "GET /app/installations"
      );
      for await (const { data: installations } of iterator2) {
        for (const installation of installations) {
          const installationOctokit = await getInstallationOctokit(
            app,
            installation.id
          );
          yield { octokit: installationOctokit, installation };
        }
      }
    }
  };
}
function eachRepositoryFactory(app) {
  return Object.assign(eachRepository.bind(null, app), {
    iterator: eachRepositoryIterator.bind(null, app)
  });
}
async function eachRepository(app, queryOrCallback, callback) {
  const i4 = eachRepositoryIterator(
    app,
    callback ? queryOrCallback : void 0
  )[Symbol.asyncIterator]();
  let result = await i4.next();
  while (!result.done) {
    if (callback) {
      await callback(result.value);
    } else {
      await queryOrCallback(result.value);
    }
    result = await i4.next();
  }
}
function singleInstallationIterator(app, installationId) {
  return {
    async *[Symbol.asyncIterator]() {
      yield {
        octokit: await app.getInstallationOctokit(installationId)
      };
    }
  };
}
function eachRepositoryIterator(app, query) {
  return {
    async *[Symbol.asyncIterator]() {
      const iterator2 = query ? singleInstallationIterator(app, query.installationId) : app.eachInstallation.iterator();
      for await (const { octokit } of iterator2) {
        const repositoriesIterator = composePaginateRest.iterator(
          octokit,
          "GET /installation/repositories"
        );
        for await (const { data: repositories } of repositoriesIterator) {
          for (const repository of repositories) {
            yield { octokit, repository };
          }
        }
      }
    }
  };
}
var _a2;
var App = (_a2 = class {
  static defaults(defaults) {
    const AppWithDefaults = class extends this {
      constructor(...args) {
        super({
          ...defaults,
          ...args[0]
        });
      }
    };
    return AppWithDefaults;
  }
  constructor(options) {
    const Octokit5 = options.Octokit || import_core.Octokit;
    const authOptions = Object.assign(
      {
        appId: options.appId,
        privateKey: options.privateKey
      },
      options.oauth ? {
        clientId: options.oauth.clientId,
        clientSecret: options.oauth.clientSecret
      } : {}
    );
    this.octokit = new Octokit5({
      authStrategy: import_auth_app.createAppAuth,
      auth: authOptions,
      log: options.log
    });
    this.log = Object.assign(
      {
        debug: () => {
        },
        info: () => {
        },
        warn: console.warn.bind(console),
        error: console.error.bind(console)
      },
      options.log
    );
    if (options.webhooks) {
      this.webhooks = webhooks(this.octokit, options.webhooks);
    } else {
      Object.defineProperty(this, "webhooks", {
        get() {
          throw new Error("[@octokit/app] webhooks option not set");
        }
      });
    }
    if (options.oauth) {
      this.oauth = new import_oauth_app.OAuthApp({
        ...options.oauth,
        clientType: "github-app",
        Octokit: Octokit5
      });
    } else {
      Object.defineProperty(this, "oauth", {
        get() {
          throw new Error(
            "[@octokit/app] oauth.clientId / oauth.clientSecret options are not set"
          );
        }
      });
    }
    this.getInstallationOctokit = getInstallationOctokit.bind(
      null,
      this
    );
    this.eachInstallation = eachInstallationFactory(
      this
    );
    this.eachRepository = eachRepositoryFactory(
      this
    );
  }
}, _a2.VERSION = VERSION10, _a2);

// node_modules/octokit/dist-web/index.js
var import_oauth_app2 = __toESM(require_dist_node8());
var VERSION11 = "3.1.2";
var Octokit = import_core2.Octokit.plugin(
  restEndpointMethods,
  paginateRest,
  paginateGraphql,
  retry,
  throttling
).defaults({
  userAgent: `octokit.js/${VERSION11}`,
  throttle: {
    onRateLimit,
    onSecondaryRateLimit
  }
});
function onRateLimit(retryAfter, options, octokit) {
  octokit.log.warn(
    `Request quota exhausted for request ${options.method} ${options.url}`
  );
  if (options.request.retryCount === 0) {
    octokit.log.info(`Retrying after ${retryAfter} seconds!`);
    return true;
  }
}
function onSecondaryRateLimit(retryAfter, options, octokit) {
  octokit.log.warn(
    `SecondaryRateLimit detected for request ${options.method} ${options.url}`
  );
  if (options.request.retryCount === 0) {
    octokit.log.info(`Retrying after ${retryAfter} seconds!`);
    return true;
  }
}
var App2 = App.defaults({ Octokit });
var OAuthApp2 = import_oauth_app2.OAuthApp.defaults({ Octokit });

// src/ui/Github.ts
var GithubBadResponseError = class extends Error {
};
async function bufferToBase64(buffer) {
  const base64url = await new Promise((r3) => {
    const reader = new FileReader();
    reader.onload = () => r3(reader.result);
    reader.readAsDataURL(new Blob([buffer]));
  });
  return base64url.slice(base64url.indexOf(",") + 1);
}
var Github = class {
  constructor(bus) {
    this._branchCommitSha = null;
    this._branchCommitShaTimeout = null;
    this.bus = bus;
    this.loginPromise = this._tryLogin();
  }
  get branchCommitSha() {
    if (this._branchCommitSha) {
      return Promise.resolve(this._branchCommitSha);
    }
    return this._getBranch().then((branch) => {
      this.branchCommitSha = branch.commit.sha;
      return this._branchCommitSha;
    });
  }
  set branchCommitSha(sha) {
    if (this._branchCommitShaTimeout) {
      window.clearTimeout(this._branchCommitShaTimeout);
    }
    this._branchCommitSha = sha;
    this._branchCommitShaTimeout = window.setTimeout(() => {
      this._branchCommitSha = null;
      this._branchCommitShaTimeout = null;
    }, 1e3 * 60 * 2);
  }
  get user() {
    return this.loginPromise.then(() => this._user);
  }
  get repo() {
    return this.loginPromise.then(() => this._repo);
  }
  get isLoggedIn() {
    return this.loginPromise;
  }
  async login(authToken) {
    this.loginPromise = this._tryLogin(authToken);
    return this.loginPromise;
  }
  async logout() {
    this.octokit = void 0;
    this._user = void 0;
    this._repo = void 0;
    await this._setAuthToken(this.bus, "");
    this.loginPromise = Promise.resolve(false);
  }
  async fileExists(path) {
    if (!await this.isLoggedIn) {
      return false;
    }
    try {
      await this.octokit.rest.repos.getContent({
        owner: this._repo.owner.login,
        repo: this._repo.name,
        path,
        ref: `heads/${this._user.login}`
      });
      return true;
    } catch (e5) {
      return false;
    }
  }
  async commitFiles(files, message) {
    if (!await this.isLoggedIn) {
      return;
    }
    const sha = await this.branchCommitSha;
    const commit = await this._getCommit(sha);
    const blobs = await Promise.all(files.map(async (file) => {
      const content2 = ArrayBuffer.isView(file.content) ? await bufferToBase64(file.content) : file.content;
      const blob = this._checkResponse(await this.octokit.rest.git.createBlob({
        owner: this._repo.owner.login,
        repo: this._repo.name,
        content: content2,
        encoding: ArrayBuffer.isView(file.content) || file.isBinary ? "base64" : "utf-8"
      }));
      return {
        path: file.path,
        sha: blob.data.sha
      };
    }));
    const tree = this._checkResponse(await this.octokit.rest.git.createTree({
      owner: this._repo.owner.login,
      repo: this._repo.name,
      tree: blobs.map((blob) => ({
        path: blob.path,
        mode: "100644",
        type: "blob",
        sha: blob.sha
      })),
      base_tree: commit.tree.sha
    }));
    const newCommit = this._checkResponse(await this.octokit.rest.git.createCommit({
      owner: this._repo.owner.login,
      repo: this._repo.name,
      message,
      tree: tree.data.sha,
      parents: [commit.sha]
    }));
    this._checkResponse(await this.octokit.rest.git.updateRef({
      owner: this._repo.owner.login,
      repo: this._repo.name,
      ref: `heads/${this._user.login}`,
      sha: newCommit.data.sha
    }));
    this.branchCommitSha = newCommit.data.sha;
  }
  async createPullRequest(title, body) {
    if (!await this.isLoggedIn || !this.octokit) {
      return false;
    }
    const branchName = `${this._user.login}-${Date.now()}`;
    await this._createBranch(branchName, await this.branchCommitSha);
    const branch = await this._getBranch(branchName);
    this._checkResponse(await this.octokit.rest.pulls.create({
      owner: this._repo.owner.login,
      repo: this._repo.name,
      title,
      body,
      head: branch.name,
      base: "develop"
    }));
    return true;
  }
  async _tryLogin(authToken) {
    authToken = authToken || await this._getAuthToken(this.bus);
    if (!authToken) {
      return false;
    }
    this.octokit = new Octokit({ auth: authToken });
    const userResponse = await this.octokit.rest.users.getAuthenticated();
    if (userResponse.status !== 200) {
      this.octokit = void 0;
      return false;
    }
    this._user = userResponse.data;
    try {
      await this._initGithub();
    } catch (e5) {
      this.octokit = void 0;
      return false;
    }
    await this._setAuthToken(this.bus, authToken);
    return true;
  }
  async _getAuthToken(bus) {
    return await bus.execute("getLocalData", "com.phenoui.github.auth.token" /* githubAccessToken */) || "";
  }
  async _setAuthToken(bus, token) {
    await bus.execute("setLocalData", {
      key: "com.phenoui.github.auth.token" /* githubAccessToken */,
      value: token
    });
  }
  _checkResponse(response) {
    if (response.status < 200 || response.status >= 300) {
      throw new GithubBadResponseError(`Bad response from Github: ${response.status}`);
    }
    return response;
  }
  async _initGithub() {
    if (!this.octokit) {
      return;
    }
    const repos = this._checkResponse(await this.octokit.rest.repos.listForAuthenticatedUser({
      type: "private"
    }));
    this._repo = repos.data[0];
    const branches = this._checkResponse(await this.octokit.rest.repos.listBranches({
      owner: this._repo.owner.login,
      repo: this._repo.name
    }));
    const hasBranch = branches.data.some((branch) => branch.name === this._user.login);
    if (!hasBranch) {
      await this._createBranch(this._user.login, branches.data.find((branch) => branch.name === "develop").commit.sha);
    }
  }
  async _createBranch(branch, sha) {
    return this._checkResponse(await this.octokit.rest.git.createRef({
      owner: this._repo.owner.login,
      repo: this._repo.name,
      ref: `refs/heads/${branch}`,
      sha
    })).data;
  }
  async _getBranch(branchName = this._user.login) {
    const branch = this._checkResponse(await this.octokit.rest.repos.getBranch({
      owner: this._repo.owner.login,
      repo: this._repo.name,
      branch: branchName
    }));
    return branch.data;
  }
  async _getCommit(commit_sha) {
    const commit = this._checkResponse(await this.octokit.rest.git.getCommit({
      owner: this._repo.owner.login,
      repo: this._repo.name,
      commit_sha
    }));
    return commit.data;
  }
};

// src/ui/UIManager.ts
var UIManager = class {
  constructor(root, bus) {
    // screens
    this.screens = /* @__PURE__ */ new Map();
    this.root = root;
    this.bus = bus;
    this.github = new Github(bus);
    this.bus.executors.push(this);
    this._initScreens();
  }
  _initScreens() {
    this.screens.set(0 /* error */, new ErrorScreen(this));
    this.screens.set(1 /* strapi_login */, new LoginScreen(this));
    this.screens.set(2 /* github_login */, new LoginScreen2(this));
    this.screens.set(3 /* empty */, new EmptyScreen(this));
    this.screens.set(4 /* figma_layer */, new LayerScreen(this));
    this.screens.set(5 /* strapi_layer */, new LayerScreen2(this));
    this.screens.set(6 /* github_layer */, new LayerScreen3(this));
    this.screens.set(7 /* loading */, new LoadingScreen(this));
  }
  _getScreen(screen) {
    if (this.screens.has(screen)) {
      return this.screens.get(screen);
    }
    return this.screens.get(0 /* error */);
  }
  render(template, root) {
    return j(x`
            ${getStyles()}
            <main>
                ${template}
            </main>
        `, root);
  }
  renderScreen(screen, root) {
    const part = this.render(screen.template, root);
    screen.renderComplete(part.parentNode);
  }
  async updateScreen(data2) {
    const screen = this._getScreen(data2.screen);
    await screen.updateTemplate(data2, this.bus);
    this.renderScreen(screen, this.root);
  }
  async isGithubLoggedIn() {
    return await this.github.isLoggedIn;
  }
};

// src/ui/mod.ts
async function main() {
  const messageBus = new MessageBus(window, []);
  const manager = new UIManager(document.body, messageBus);
  console.log(manager);
}
document.addEventListener("DOMContentLoaded", main);
/*! Bundled license information:

lottie-web/build/player/lottie.js:
  (*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
</script>
